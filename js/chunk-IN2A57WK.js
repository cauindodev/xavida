var Jp = Object.defineProperty, Xp = Object.defineProperties; var em = Object.getOwnPropertyDescriptors; var Er = Object.getOwnPropertySymbols; var _u = Object.prototype.hasOwnProperty, Iu = Object.prototype.propertyIsEnumerable; var wu = (t, e, n) => e in t ? Jp(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n, me = (t, e) => { for (var n in e ||= {}) _u.call(e, n) && wu(t, n, e[n]); if (Er) for (var n of Er(e)) Iu.call(e, n) && wu(t, n, e[n]); return t }, We = (t, e) => Xp(t, em(e)); var bu = (t, e) => { var n = {}; for (var r in t) _u.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]); if (t != null && Er) for (var r of Er(t)) e.indexOf(r) < 0 && Iu.call(t, r) && (n[r] = t[r]); return n }; var tm = (t, e, n) => new Promise((r, o) => { var i = l => { try { a(n.next(l)) } catch (u) { o(u) } }, s = l => { try { a(n.throw(l)) } catch (u) { o(u) } }, a = l => l.done ? r(l.value) : Promise.resolve(l.value).then(i, s); a((n = n.apply(t, e)).next()) }); function Cu(t, e) { return Object.is(t, e) } var Q = null, wr = !1, _r = 1, Qe = Symbol("SIGNAL"); function A(t) { let e = Q; return Q = t, e } function Su() { return Q } var Vn = { version: 0, lastCleanEpoch: 0, dirty: !1, producerNode: void 0, producerLastReadVersion: void 0, producerIndexOfThis: void 0, nextProducerIndex: 0, liveConsumerNode: void 0, liveConsumerIndexOfThis: void 0, consumerAllowSignalWrites: !1, consumerIsAlwaysLive: !1, producerMustRecompute: () => !1, producerRecomputeValue: () => { }, consumerMarkedDirty: () => { }, consumerOnSignalRead: () => { } }; function Fi(t) { if (wr) throw new Error(""); if (Q === null) return; Q.consumerOnSignalRead(t); let e = Q.nextProducerIndex++; if (Sr(Q), e < Q.producerNode.length && Q.producerNode[e] !== t && jn(Q)) { let n = Q.producerNode[e]; Cr(n, Q.producerIndexOfThis[e]) } Q.producerNode[e] !== t && (Q.producerNode[e] = t, Q.producerIndexOfThis[e] = jn(Q) ? xu(t, Q, e) : 0), Q.producerLastReadVersion[e] = t.version } function nm() { _r++ } function Mu(t) { if (!(jn(t) && !t.dirty) && !(!t.dirty && t.lastCleanEpoch === _r)) { if (!t.producerMustRecompute(t) && !ki(t)) { t.dirty = !1, t.lastCleanEpoch = _r; return } t.producerRecomputeValue(t), t.dirty = !1, t.lastCleanEpoch = _r } } function Tu(t) { if (t.liveConsumerNode === void 0) return; let e = wr; wr = !0; try { for (let n of t.liveConsumerNode) n.dirty || rm(n) } finally { wr = e } } function Nu() { return Q?.consumerAllowSignalWrites !== !1 } function rm(t) { t.dirty = !0, Tu(t), t.consumerMarkedDirty?.(t) } function br(t) { return t && (t.nextProducerIndex = 0), A(t) } function Ri(t, e) { if (A(e), !(!t || t.producerNode === void 0 || t.producerIndexOfThis === void 0 || t.producerLastReadVersion === void 0)) { if (jn(t)) for (let n = t.nextProducerIndex; n < t.producerNode.length; n++)Cr(t.producerNode[n], t.producerIndexOfThis[n]); for (; t.producerNode.length > t.nextProducerIndex;)t.producerNode.pop(), t.producerLastReadVersion.pop(), t.producerIndexOfThis.pop() } } function ki(t) { Sr(t); for (let e = 0; e < t.producerNode.length; e++) { let n = t.producerNode[e], r = t.producerLastReadVersion[e]; if (r !== n.version || (Mu(n), r !== n.version)) return !0 } return !1 } function Li(t) { if (Sr(t), jn(t)) for (let e = 0; e < t.producerNode.length; e++)Cr(t.producerNode[e], t.producerIndexOfThis[e]); t.producerNode.length = t.producerLastReadVersion.length = t.producerIndexOfThis.length = 0, t.liveConsumerNode && (t.liveConsumerNode.length = t.liveConsumerIndexOfThis.length = 0) } function xu(t, e, n) { if (Au(t), t.liveConsumerNode.length === 0 && Ou(t)) for (let r = 0; r < t.producerNode.length; r++)t.producerIndexOfThis[r] = xu(t.producerNode[r], t, r); return t.liveConsumerIndexOfThis.push(n), t.liveConsumerNode.push(e) - 1 } function Cr(t, e) { if (Au(t), t.liveConsumerNode.length === 1 && Ou(t)) for (let r = 0; r < t.producerNode.length; r++)Cr(t.producerNode[r], t.producerIndexOfThis[r]); let n = t.liveConsumerNode.length - 1; if (t.liveConsumerNode[e] = t.liveConsumerNode[n], t.liveConsumerIndexOfThis[e] = t.liveConsumerIndexOfThis[n], t.liveConsumerNode.length--, t.liveConsumerIndexOfThis.length--, e < t.liveConsumerNode.length) { let r = t.liveConsumerIndexOfThis[e], o = t.liveConsumerNode[e]; Sr(o), o.producerIndexOfThis[r] = e } } function jn(t) { return t.consumerIsAlwaysLive || (t?.liveConsumerNode?.length ?? 0) > 0 } function Sr(t) { t.producerNode ??= [], t.producerIndexOfThis ??= [], t.producerLastReadVersion ??= [] } function Au(t) { t.liveConsumerNode ??= [], t.liveConsumerIndexOfThis ??= [] } function Ou(t) { return t.producerNode !== void 0 } function Pu(t) { let e = Object.create(om); e.computation = t; let n = () => { if (Mu(e), Fi(e), e.value === Ir) throw e.error; return e.value }; return n[Qe] = e, n } var Oi = Symbol("UNSET"), Pi = Symbol("COMPUTING"), Ir = Symbol("ERRORED"), om = We(me({}, Vn), { value: Oi, dirty: !0, error: null, equal: Cu, producerMustRecompute(t) { return t.value === Oi || t.value === Pi }, producerRecomputeValue(t) { if (t.value === Pi) throw new Error("Detected cycle in computations."); let e = t.value; t.value = Pi; let n = br(t), r; try { r = t.computation() } catch (o) { r = Ir, t.error = o } finally { Ri(t, n) } if (e !== Oi && e !== Ir && r !== Ir && t.equal(e, r)) { t.value = e; return } t.value = r, t.version++ } }); function im() { throw new Error } var Fu = im; function Ru() { Fu() } function ku(t) { Fu = t } var sm = null; function Lu(t) { let e = Object.create(Vu); e.value = t; let n = () => (Fi(e), e.value); return n[Qe] = e, n } function ji(t, e) { Nu() || Ru(), t.equal(t.value, e) || (t.value = e, am(t)) } function ju(t, e) { Nu() || Ru(), ji(t, e(t.value)) } var Vu = We(me({}, Vn), { equal: Cu, value: void 0 }); function am(t) { t.version++, nm(), Tu(t), sm?.() } function I(t) { return typeof t == "function" } function en(t) { let n = t(r => { Error.call(r), r.stack = new Error().stack }); return n.prototype = Object.create(Error.prototype), n.prototype.constructor = n, n } var Mr = en(t => function (n) {
    t(this), this.message = n ? `${n.length} errors occurred during unsubscription:
${n.map((r, o) => `${o + 1}) ${r.toString()}`).join(`
  `)}` : "", this.name = "UnsubscriptionError", this.errors = n
}); function Tt(t, e) { if (t) { let n = t.indexOf(e); 0 <= n && t.splice(n, 1) } } var W = class t { constructor(e) { this.initialTeardown = e, this.closed = !1, this._parentage = null, this._finalizers = null } unsubscribe() { let e; if (!this.closed) { this.closed = !0; let { _parentage: n } = this; if (n) if (this._parentage = null, Array.isArray(n)) for (let i of n) i.remove(this); else n.remove(this); let { initialTeardown: r } = this; if (I(r)) try { r() } catch (i) { e = i instanceof Mr ? i.errors : [i] } let { _finalizers: o } = this; if (o) { this._finalizers = null; for (let i of o) try { Bu(i) } catch (s) { e = e ?? [], s instanceof Mr ? e = [...e, ...s.errors] : e.push(s) } } if (e) throw new Mr(e) } } add(e) { var n; if (e && e !== this) if (this.closed) Bu(e); else { if (e instanceof t) { if (e.closed || e._hasParent(this)) return; e._addParent(this) } (this._finalizers = (n = this._finalizers) !== null && n !== void 0 ? n : []).push(e) } } _hasParent(e) { let { _parentage: n } = this; return n === e || Array.isArray(n) && n.includes(e) } _addParent(e) { let { _parentage: n } = this; this._parentage = Array.isArray(n) ? (n.push(e), n) : n ? [n, e] : e } _removeParent(e) { let { _parentage: n } = this; n === e ? this._parentage = null : Array.isArray(n) && Tt(n, e) } remove(e) { let { _finalizers: n } = this; n && Tt(n, e), e instanceof t && e._removeParent(this) } }; W.EMPTY = (() => { let t = new W; return t.closed = !0, t })(); var Vi = W.EMPTY; function Tr(t) { return t instanceof W || t && "closed" in t && I(t.remove) && I(t.add) && I(t.unsubscribe) } function Bu(t) { I(t) ? t() : t.unsubscribe() } var Me = { onUnhandledError: null, onStoppedNotification: null, Promise: void 0, useDeprecatedSynchronousErrorHandling: !1, useDeprecatedNextContext: !1 }; var tn = { setTimeout(t, e, ...n) { let { delegate: r } = tn; return r?.setTimeout ? r.setTimeout(t, e, ...n) : setTimeout(t, e, ...n) }, clearTimeout(t) { let { delegate: e } = tn; return (e?.clearTimeout || clearTimeout)(t) }, delegate: void 0 }; function Nr(t) { tn.setTimeout(() => { let { onUnhandledError: e } = Me; if (e) e(t); else throw t }) } function Te() { } var $u = Bi("C", void 0, void 0); function Hu(t) { return Bi("E", void 0, t) } function Uu(t) { return Bi("N", t, void 0) } function Bi(t, e, n) { return { kind: t, value: e, error: n } } var Nt = null; function nn(t) { if (Me.useDeprecatedSynchronousErrorHandling) { let e = !Nt; if (e && (Nt = { errorThrown: !1, error: null }), t(), e) { let { errorThrown: n, error: r } = Nt; if (Nt = null, n) throw r } } else t() } function zu(t) { Me.useDeprecatedSynchronousErrorHandling && Nt && (Nt.errorThrown = !0, Nt.error = t) } var xt = class extends W { constructor(e) { super(), this.isStopped = !1, e ? (this.destination = e, Tr(e) && e.add(this)) : this.destination = cm } static create(e, n, r) { return new Ze(e, n, r) } next(e) { this.isStopped ? Hi(Uu(e), this) : this._next(e) } error(e) { this.isStopped ? Hi(Hu(e), this) : (this.isStopped = !0, this._error(e)) } complete() { this.isStopped ? Hi($u, this) : (this.isStopped = !0, this._complete()) } unsubscribe() { this.closed || (this.isStopped = !0, super.unsubscribe(), this.destination = null) } _next(e) { this.destination.next(e) } _error(e) { try { this.destination.error(e) } finally { this.unsubscribe() } } _complete() { try { this.destination.complete() } finally { this.unsubscribe() } } }, lm = Function.prototype.bind; function $i(t, e) { return lm.call(t, e) } var Ui = class { constructor(e) { this.partialObserver = e } next(e) { let { partialObserver: n } = this; if (n.next) try { n.next(e) } catch (r) { xr(r) } } error(e) { let { partialObserver: n } = this; if (n.error) try { n.error(e) } catch (r) { xr(r) } else xr(e) } complete() { let { partialObserver: e } = this; if (e.complete) try { e.complete() } catch (n) { xr(n) } } }, Ze = class extends xt { constructor(e, n, r) { super(); let o; if (I(e) || !e) o = { next: e ?? void 0, error: n ?? void 0, complete: r ?? void 0 }; else { let i; this && Me.useDeprecatedNextContext ? (i = Object.create(e), i.unsubscribe = () => this.unsubscribe(), o = { next: e.next && $i(e.next, i), error: e.error && $i(e.error, i), complete: e.complete && $i(e.complete, i) }) : o = e } this.destination = new Ui(o) } }; function xr(t) { Me.useDeprecatedSynchronousErrorHandling ? zu(t) : Nr(t) } function um(t) { throw t } function Hi(t, e) { let { onStoppedNotification: n } = Me; n && tn.setTimeout(() => n(t, e)) } var cm = { closed: !0, next: Te, error: um, complete: Te }; var rn = typeof Symbol == "function" && Symbol.observable || "@@observable"; function X(t) { return t } function dm(...t) { return zi(t) } function zi(t) { return t.length === 0 ? X : t.length === 1 ? t[0] : function (n) { return t.reduce((r, o) => o(r), n) } } var P = (() => { class t { constructor(n) { n && (this._subscribe = n) } lift(n) { let r = new t; return r.source = this, r.operator = n, r } subscribe(n, r, o) { let i = hm(n) ? n : new Ze(n, r, o); return nn(() => { let { operator: s, source: a } = this; i.add(s ? s.call(i, a) : a ? this._subscribe(i) : this._trySubscribe(i)) }), i } _trySubscribe(n) { try { return this._subscribe(n) } catch (r) { n.error(r) } } forEach(n, r) { return r = qu(r), new r((o, i) => { let s = new Ze({ next: a => { try { n(a) } catch (l) { i(l), s.unsubscribe() } }, error: i, complete: o }); this.subscribe(s) }) } _subscribe(n) { var r; return (r = this.source) === null || r === void 0 ? void 0 : r.subscribe(n) } [rn]() { return this } pipe(...n) { return zi(n)(this) } toPromise(n) { return n = qu(n), new n((r, o) => { let i; this.subscribe(s => i = s, s => o(s), () => r(i)) }) } } return t.create = e => new t(e), t })(); function qu(t) { var e; return (e = t ?? Me.Promise) !== null && e !== void 0 ? e : Promise } function fm(t) { return t && I(t.next) && I(t.error) && I(t.complete) } function hm(t) { return t && t instanceof xt || fm(t) && Tr(t) } function qi(t) { return I(t?.lift) } function _(t) { return e => { if (qi(e)) return e.lift(function (n) { try { return t(n, this) } catch (r) { this.error(r) } }); throw new TypeError("Unable to lift unknown Observable type") } } function E(t, e, n, r, o) { return new Gi(t, e, n, r, o) } var Gi = class extends xt { constructor(e, n, r, o, i, s) { super(e), this.onFinalize = i, this.shouldUnsubscribe = s, this._next = n ? function (a) { try { n(a) } catch (l) { e.error(l) } } : super._next, this._error = o ? function (a) { try { o(a) } catch (l) { e.error(l) } finally { this.unsubscribe() } } : super._error, this._complete = r ? function () { try { r() } catch (a) { e.error(a) } finally { this.unsubscribe() } } : super._complete } unsubscribe() { var e; if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) { let { closed: n } = this; super.unsubscribe(), !n && ((e = this.onFinalize) === null || e === void 0 || e.call(this)) } } }; function Wi() { return _((t, e) => { let n = null; t._refCount++; let r = E(e, void 0, void 0, void 0, () => { if (!t || t._refCount <= 0 || 0 < --t._refCount) { n = null; return } let o = t._connection, i = n; n = null, o && (!i || o === i) && o.unsubscribe(), e.unsubscribe() }); t.subscribe(r), r.closed || (n = t.connect()) }) } var Qi = class extends P { constructor(e, n) { super(), this.source = e, this.subjectFactory = n, this._subject = null, this._refCount = 0, this._connection = null, qi(e) && (this.lift = e.lift) } _subscribe(e) { return this.getSubject().subscribe(e) } getSubject() { let e = this._subject; return (!e || e.isStopped) && (this._subject = this.subjectFactory()), this._subject } _teardown() { this._refCount = 0; let { _connection: e } = this; this._subject = this._connection = null, e?.unsubscribe() } connect() { let e = this._connection; if (!e) { e = this._connection = new W; let n = this.getSubject(); e.add(this.source.subscribe(E(n, void 0, () => { this._teardown(), n.complete() }, r => { this._teardown(), n.error(r) }, () => this._teardown()))), e.closed && (this._connection = null, e = W.EMPTY) } return e } refCount() { return Wi()(this) } }; var on = { schedule(t) { let e = requestAnimationFrame, n = cancelAnimationFrame, { delegate: r } = on; r && (e = r.requestAnimationFrame, n = r.cancelAnimationFrame); let o = e(i => { n = void 0, t(i) }); return new W(() => n?.(o)) }, requestAnimationFrame(...t) { let { delegate: e } = on; return (e?.requestAnimationFrame || requestAnimationFrame)(...t) }, cancelAnimationFrame(...t) { let { delegate: e } = on; return (e?.cancelAnimationFrame || cancelAnimationFrame)(...t) }, delegate: void 0 }; var Gu = en(t => function () { t(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed" }); var _e = (() => { class t extends P { constructor() { super(), this.closed = !1, this.currentObservers = null, this.observers = [], this.isStopped = !1, this.hasError = !1, this.thrownError = null } lift(n) { let r = new Ar(this, this); return r.operator = n, r } _throwIfClosed() { if (this.closed) throw new Gu } next(n) { nn(() => { if (this._throwIfClosed(), !this.isStopped) { this.currentObservers || (this.currentObservers = Array.from(this.observers)); for (let r of this.currentObservers) r.next(n) } }) } error(n) { nn(() => { if (this._throwIfClosed(), !this.isStopped) { this.hasError = this.isStopped = !0, this.thrownError = n; let { observers: r } = this; for (; r.length;)r.shift().error(n) } }) } complete() { nn(() => { if (this._throwIfClosed(), !this.isStopped) { this.isStopped = !0; let { observers: n } = this; for (; n.length;)n.shift().complete() } }) } unsubscribe() { this.isStopped = this.closed = !0, this.observers = this.currentObservers = null } get observed() { var n; return ((n = this.observers) === null || n === void 0 ? void 0 : n.length) > 0 } _trySubscribe(n) { return this._throwIfClosed(), super._trySubscribe(n) } _subscribe(n) { return this._throwIfClosed(), this._checkFinalizedStatuses(n), this._innerSubscribe(n) } _innerSubscribe(n) { let { hasError: r, isStopped: o, observers: i } = this; return r || o ? Vi : (this.currentObservers = null, i.push(n), new W(() => { this.currentObservers = null, Tt(i, n) })) } _checkFinalizedStatuses(n) { let { hasError: r, thrownError: o, isStopped: i } = this; r ? n.error(o) : i && n.complete() } asObservable() { let n = new P; return n.source = this, n } } return t.create = (e, n) => new Ar(e, n), t })(), Ar = class extends _e { constructor(e, n) { super(), this.destination = e, this.source = n } next(e) { var n, r; (r = (n = this.destination) === null || n === void 0 ? void 0 : n.next) === null || r === void 0 || r.call(n, e) } error(e) { var n, r; (r = (n = this.destination) === null || n === void 0 ? void 0 : n.error) === null || r === void 0 || r.call(n, e) } complete() { var e, n; (n = (e = this.destination) === null || e === void 0 ? void 0 : e.complete) === null || n === void 0 || n.call(e) } _subscribe(e) { var n, r; return (r = (n = this.source) === null || n === void 0 ? void 0 : n.subscribe(e)) !== null && r !== void 0 ? r : Vi } }; var Bn = class extends _e { constructor(e) { super(), this._value = e } get value() { return this.getValue() } _subscribe(e) { let n = super._subscribe(e); return !n.closed && e.next(this._value), n } getValue() { let { hasError: e, thrownError: n, _value: r } = this; if (e) throw n; return this._throwIfClosed(), r } next(e) { super.next(this._value = e) } }; var $n = { now() { return ($n.delegate || Date).now() }, delegate: void 0 }; var Hn = class extends _e { constructor(e = 1 / 0, n = 1 / 0, r = $n) { super(), this._bufferSize = e, this._windowTime = n, this._timestampProvider = r, this._buffer = [], this._infiniteTimeWindow = !0, this._infiniteTimeWindow = n === 1 / 0, this._bufferSize = Math.max(1, e), this._windowTime = Math.max(1, n) } next(e) { let { isStopped: n, _buffer: r, _infiniteTimeWindow: o, _timestampProvider: i, _windowTime: s } = this; n || (r.push(e), !o && r.push(i.now() + s)), this._trimBuffer(), super.next(e) } _subscribe(e) { this._throwIfClosed(), this._trimBuffer(); let n = this._innerSubscribe(e), { _infiniteTimeWindow: r, _buffer: o } = this, i = o.slice(); for (let s = 0; s < i.length && !e.closed; s += r ? 1 : 2)e.next(i[s]); return this._checkFinalizedStatuses(e), n } _trimBuffer() { let { _bufferSize: e, _timestampProvider: n, _buffer: r, _infiniteTimeWindow: o } = this, i = (o ? 1 : 2) * e; if (e < 1 / 0 && i < r.length && r.splice(0, r.length - i), !o) { let s = n.now(), a = 0; for (let l = 1; l < r.length && r[l] <= s; l += 2)a = l; a && r.splice(0, a + 1) } } }; var Or = class extends W { constructor(e, n) { super() } schedule(e, n = 0) { return this } }; var Un = { setInterval(t, e, ...n) { let { delegate: r } = Un; return r?.setInterval ? r.setInterval(t, e, ...n) : setInterval(t, e, ...n) }, clearInterval(t) { let { delegate: e } = Un; return (e?.clearInterval || clearInterval)(t) }, delegate: void 0 }; var at = class extends Or { constructor(e, n) { super(e, n), this.scheduler = e, this.work = n, this.pending = !1 } schedule(e, n = 0) { var r; if (this.closed) return this; this.state = e; let o = this.id, i = this.scheduler; return o != null && (this.id = this.recycleAsyncId(i, o, n)), this.pending = !0, this.delay = n, this.id = (r = this.id) !== null && r !== void 0 ? r : this.requestAsyncId(i, this.id, n), this } requestAsyncId(e, n, r = 0) { return Un.setInterval(e.flush.bind(e, this), r) } recycleAsyncId(e, n, r = 0) { if (r != null && this.delay === r && this.pending === !1) return n; n != null && Un.clearInterval(n) } execute(e, n) { if (this.closed) return new Error("executing a cancelled action"); this.pending = !1; let r = this._execute(e, n); if (r) return r; this.pending === !1 && this.id != null && (this.id = this.recycleAsyncId(this.scheduler, this.id, null)) } _execute(e, n) { let r = !1, o; try { this.work(e) } catch (i) { r = !0, o = i || new Error("Scheduled action threw falsy error") } if (r) return this.unsubscribe(), o } unsubscribe() { if (!this.closed) { let { id: e, scheduler: n } = this, { actions: r } = n; this.work = this.state = this.scheduler = null, this.pending = !1, Tt(r, this), e != null && (this.id = this.recycleAsyncId(n, e, null)), this.delay = null, super.unsubscribe() } } }; var pm = 1, Zi, Ki = {}; function Wu(t) { return t in Ki ? (delete Ki[t], !0) : !1 } var Qu = { setImmediate(t) { let e = pm++; return Ki[e] = !0, Zi || (Zi = Promise.resolve()), Zi.then(() => Wu(e) && t()), e }, clearImmediate(t) { Wu(t) } }; var { setImmediate: mm, clearImmediate: gm } = Qu, zn = { setImmediate(...t) { let { delegate: e } = zn; return (e?.setImmediate || mm)(...t) }, clearImmediate(t) { let { delegate: e } = zn; return (e?.clearImmediate || gm)(t) }, delegate: void 0 }; var Pr = class extends at { constructor(e, n) { super(e, n), this.scheduler = e, this.work = n } requestAsyncId(e, n, r = 0) { return r !== null && r > 0 ? super.requestAsyncId(e, n, r) : (e.actions.push(this), e._scheduled || (e._scheduled = zn.setImmediate(e.flush.bind(e, void 0)))) } recycleAsyncId(e, n, r = 0) { var o; if (r != null ? r > 0 : this.delay > 0) return super.recycleAsyncId(e, n, r); let { actions: i } = e; n != null && ((o = i[i.length - 1]) === null || o === void 0 ? void 0 : o.id) !== n && (zn.clearImmediate(n), e._scheduled === n && (e._scheduled = void 0)) } }; var sn = class t { constructor(e, n = t.now) { this.schedulerActionCtor = e, this.now = n } schedule(e, n = 0, r) { return new this.schedulerActionCtor(this, e).schedule(r, n) } }; sn.now = $n.now; var lt = class extends sn { constructor(e, n = sn.now) { super(e, n), this.actions = [], this._active = !1 } flush(e) { let { actions: n } = this; if (this._active) { n.push(e); return } let r; this._active = !0; do if (r = e.execute(e.state, e.delay)) break; while (e = n.shift()); if (this._active = !1, r) { for (; e = n.shift();)e.unsubscribe(); throw r } } }; var Fr = class extends lt { flush(e) { this._active = !0; let n = this._scheduled; this._scheduled = void 0; let { actions: r } = this, o; e = e || r.shift(); do if (o = e.execute(e.state, e.delay)) break; while ((e = r[0]) && e.id === n && r.shift()); if (this._active = !1, o) { for (; (e = r[0]) && e.id === n && r.shift();)e.unsubscribe(); throw o } } }; var ym = new Fr(Pr); var Ke = new lt(at), Zu = Ke; var Rr = class extends at { constructor(e, n) { super(e, n), this.scheduler = e, this.work = n } requestAsyncId(e, n, r = 0) { return r !== null && r > 0 ? super.requestAsyncId(e, n, r) : (e.actions.push(this), e._scheduled || (e._scheduled = on.requestAnimationFrame(() => e.flush(void 0)))) } recycleAsyncId(e, n, r = 0) { var o; if (r != null ? r > 0 : this.delay > 0) return super.recycleAsyncId(e, n, r); let { actions: i } = e; n != null && ((o = i[i.length - 1]) === null || o === void 0 ? void 0 : o.id) !== n && (on.cancelAnimationFrame(n), e._scheduled = void 0) } }; var kr = class extends lt { flush(e) { this._active = !0; let n = this._scheduled; this._scheduled = void 0; let { actions: r } = this, o; e = e || r.shift(); do if (o = e.execute(e.state, e.delay)) break; while ((e = r[0]) && e.id === n && r.shift()); if (this._active = !1, o) { for (; (e = r[0]) && e.id === n && r.shift();)e.unsubscribe(); throw o } } }; var vm = new kr(Rr); var At = new P(t => t.complete()); function Lr(t) { return t && I(t.schedule) } function Yi(t) { return t[t.length - 1] } function an(t) { return I(Yi(t)) ? t.pop() : void 0 } function ke(t) { return Lr(Yi(t)) ? t.pop() : void 0 } function Ku(t, e) { return typeof Yi(t) == "number" ? t.pop() : e } function TS(t, e, n, r) { var o = arguments.length, i = o < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, n) : r, s; if (typeof Reflect == "object" && typeof Reflect.decorate == "function") i = Reflect.decorate(t, e, n, r); else for (var a = t.length - 1; a >= 0; a--)(s = t[a]) && (i = (o < 3 ? s(i) : o > 3 ? s(e, n, i) : s(e, n)) || i); return o > 3 && i && Object.defineProperty(e, n, i), i } function Ju(t, e, n, r) { function o(i) { return i instanceof n ? i : new n(function (s) { s(i) }) } return new (n || (n = Promise))(function (i, s) { function a(c) { try { u(r.next(c)) } catch (d) { s(d) } } function l(c) { try { u(r.throw(c)) } catch (d) { s(d) } } function u(c) { c.done ? i(c.value) : o(c.value).then(a, l) } u((r = r.apply(t, e || [])).next()) }) } function Yu(t) { var e = typeof Symbol == "function" && Symbol.iterator, n = e && t[e], r = 0; if (n) return n.call(t); if (t && typeof t.length == "number") return { next: function () { return t && r >= t.length && (t = void 0), { value: t && t[r++], done: !t } } }; throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.") } function Ot(t) { return this instanceof Ot ? (this.v = t, this) : new Ot(t) } function Xu(t, e, n) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var r = n.apply(t, e || []), o, i = []; return o = Object.create((typeof AsyncIterator == "function" ? AsyncIterator : Object).prototype), a("next"), a("throw"), a("return", s), o[Symbol.asyncIterator] = function () { return this }, o; function s(f) { return function (p) { return Promise.resolve(p).then(f, d) } } function a(f, p) { r[f] && (o[f] = function (m) { return new Promise(function (D, v) { i.push([f, m, D, v]) > 1 || l(f, m) }) }, p && (o[f] = p(o[f]))) } function l(f, p) { try { u(r[f](p)) } catch (m) { h(i[0][3], m) } } function u(f) { f.value instanceof Ot ? Promise.resolve(f.value.v).then(c, d) : h(i[0][2], f) } function c(f) { l("next", f) } function d(f) { l("throw", f) } function h(f, p) { f(p), i.shift(), i.length && l(i[0][0], i[0][1]) } } function ec(t) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var e = t[Symbol.asyncIterator], n; return e ? e.call(t) : (t = typeof Yu == "function" ? Yu(t) : t[Symbol.iterator](), n = {}, r("next"), r("throw"), r("return"), n[Symbol.asyncIterator] = function () { return this }, n); function r(i) { n[i] = t[i] && function (s) { return new Promise(function (a, l) { s = t[i](s), o(a, l, s.done, s.value) }) } } function o(i, s, a, l) { Promise.resolve(l).then(function (u) { i({ value: u, done: a }) }, s) } } var ln = t => t && typeof t.length == "number" && typeof t != "function"; function jr(t) { return I(t?.then) } function Vr(t) { return I(t[rn]) } function Br(t) { return Symbol.asyncIterator && I(t?.[Symbol.asyncIterator]) } function $r(t) { return new TypeError(`You provided ${t !== null && typeof t == "object" ? "an invalid object" : `'${t}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`) } function Dm() { return typeof Symbol != "function" || !Symbol.iterator ? "@@iterator" : Symbol.iterator } var Hr = Dm(); function Ur(t) { return I(t?.[Hr]) } function zr(t) { return Xu(this, arguments, function* () { let n = t.getReader(); try { for (; ;) { let { value: r, done: o } = yield Ot(n.read()); if (o) return yield Ot(void 0); yield yield Ot(r) } } finally { n.releaseLock() } }) } function qr(t) { return I(t?.getReader) } function F(t) { if (t instanceof P) return t; if (t != null) { if (Vr(t)) return Em(t); if (ln(t)) return wm(t); if (jr(t)) return _m(t); if (Br(t)) return tc(t); if (Ur(t)) return Im(t); if (qr(t)) return bm(t) } throw $r(t) } function Em(t) { return new P(e => { let n = t[rn](); if (I(n.subscribe)) return n.subscribe(e); throw new TypeError("Provided object does not correctly implement Symbol.observable") }) } function wm(t) { return new P(e => { for (let n = 0; n < t.length && !e.closed; n++)e.next(t[n]); e.complete() }) } function _m(t) { return new P(e => { t.then(n => { e.closed || (e.next(n), e.complete()) }, n => e.error(n)).then(null, Nr) }) } function Im(t) { return new P(e => { for (let n of t) if (e.next(n), e.closed) return; e.complete() }) } function tc(t) { return new P(e => { Cm(t, e).catch(n => e.error(n)) }) } function bm(t) { return tc(zr(t)) } function Cm(t, e) { var n, r, o, i; return Ju(this, void 0, void 0, function* () { try { for (n = ec(t); r = yield n.next(), !r.done;) { let s = r.value; if (e.next(s), e.closed) return } } catch (s) { o = { error: s } } finally { try { r && !r.done && (i = n.return) && (yield i.call(n)) } finally { if (o) throw o.error } } e.complete() }) } function le(t, e, n, r = 0, o = !1) { let i = e.schedule(function () { n(), o ? t.add(this.schedule(null, r)) : this.unsubscribe() }, r); if (t.add(i), !o) return i } function Gr(t, e = 0) { return _((n, r) => { n.subscribe(E(r, o => le(r, t, () => r.next(o), e), () => le(r, t, () => r.complete(), e), o => le(r, t, () => r.error(o), e))) }) } function Wr(t, e = 0) { return _((n, r) => { r.add(t.schedule(() => n.subscribe(r), e)) }) } function nc(t, e) { return F(t).pipe(Wr(e), Gr(e)) } function rc(t, e) { return F(t).pipe(Wr(e), Gr(e)) } function oc(t, e) { return new P(n => { let r = 0; return e.schedule(function () { r === t.length ? n.complete() : (n.next(t[r++]), n.closed || this.schedule()) }) }) } function ic(t, e) { return new P(n => { let r; return le(n, e, () => { r = t[Hr](), le(n, e, () => { let o, i; try { ({ value: o, done: i } = r.next()) } catch (s) { n.error(s); return } i ? n.complete() : n.next(o) }, 0, !0) }), () => I(r?.return) && r.return() }) } function Qr(t, e) { if (!t) throw new Error("Iterable cannot be null"); return new P(n => { le(n, e, () => { let r = t[Symbol.asyncIterator](); le(n, e, () => { r.next().then(o => { o.done ? n.complete() : n.next(o.value) }) }, 0, !0) }) }) } function sc(t, e) { return Qr(zr(t), e) } function ac(t, e) { if (t != null) { if (Vr(t)) return nc(t, e); if (ln(t)) return oc(t, e); if (jr(t)) return rc(t, e); if (Br(t)) return Qr(t, e); if (Ur(t)) return ic(t, e); if (qr(t)) return sc(t, e) } throw $r(t) } function Le(t, e) { return e ? ac(t, e) : F(t) } function Sm(...t) { let e = ke(t); return Le(t, e) } function Mm(t, e) { let n = I(t) ? t : () => t, r = o => o.error(n()); return new P(e ? o => e.schedule(r, 0, o) : r) } function Tm(t) { return !!t && (t instanceof P || I(t.lift) && I(t.subscribe)) } var Pt = en(t => function () { t(this), this.name = "EmptyError", this.message = "no elements in sequence" }); function lc(t) { return t instanceof Date && !isNaN(t) } function je(t, e) { return _((n, r) => { let o = 0; n.subscribe(E(r, i => { r.next(t.call(e, i, o++)) })) }) } var { isArray: Nm } = Array; function xm(t, e) { return Nm(e) ? t(...e) : t(e) } function un(t) { return je(e => xm(t, e)) } var { isArray: Am } = Array, { getPrototypeOf: Om, prototype: Pm, keys: Fm } = Object; function Zr(t) { if (t.length === 1) { let e = t[0]; if (Am(e)) return { args: e, keys: null }; if (Rm(e)) { let n = Fm(e); return { args: n.map(r => e[r]), keys: n } } } return { args: t, keys: null } } function Rm(t) { return t && typeof t == "object" && Om(t) === Pm } function Kr(t, e) { return t.reduce((n, r, o) => (n[r] = e[o], n), {}) } function km(...t) { let e = ke(t), n = an(t), { args: r, keys: o } = Zr(t); if (r.length === 0) return Le([], e); let i = new P(Lm(r, e, o ? s => Kr(o, s) : X)); return n ? i.pipe(un(n)) : i } function Lm(t, e, n = X) { return r => { uc(e, () => { let { length: o } = t, i = new Array(o), s = o, a = o; for (let l = 0; l < o; l++)uc(e, () => { let u = Le(t[l], e), c = !1; u.subscribe(E(r, d => { i[l] = d, c || (c = !0, a--), a || r.next(n(i.slice())) }, () => { --s || r.complete() })) }, r) }, r) } } function uc(t, e, n) { t ? le(n, t, e) : e() } function cc(t, e, n, r, o, i, s, a) { let l = [], u = 0, c = 0, d = !1, h = () => { d && !l.length && !u && e.complete() }, f = m => u < r ? p(m) : l.push(m), p = m => { i && e.next(m), u++; let D = !1; F(n(m, c++)).subscribe(E(e, v => { o?.(v), i ? f(v) : e.next(v) }, () => { D = !0 }, void 0, () => { if (D) try { for (u--; l.length && u < r;) { let v = l.shift(); s ? le(e, s, () => p(v)) : p(v) } h() } catch (v) { e.error(v) } })) }; return t.subscribe(E(e, f, () => { d = !0, h() })), () => { a?.() } } function Ne(t, e, n = 1 / 0) { return I(e) ? Ne((r, o) => je((i, s) => e(r, i, o, s))(F(t(r, o))), n) : (typeof e == "number" && (n = e), _((r, o) => cc(r, o, t, n))) } function Yr(t = 1 / 0) { return Ne(X, t) } function dc() { return Yr(1) } function cn(...t) { return dc()(Le(t, ke(t))) } function jm(t) { return new P(e => { F(t()).subscribe(e) }) } function Vm(...t) { let e = an(t), { args: n, keys: r } = Zr(t), o = new P(i => { let { length: s } = n; if (!s) { i.complete(); return } let a = new Array(s), l = s, u = s; for (let c = 0; c < s; c++) { let d = !1; F(n[c]).subscribe(E(i, h => { d || (d = !0, u--), a[c] = h }, () => l--, void 0, () => { (!l || !d) && (u || i.next(r ? Kr(r, a) : a), i.complete()) })) } }); return e ? o.pipe(un(e)) : o } var Bm = ["addListener", "removeListener"], $m = ["addEventListener", "removeEventListener"], Hm = ["on", "off"]; function Ji(t, e, n, r) { if (I(n) && (r = n, n = void 0), r) return Ji(t, e, n).pipe(un(r)); let [o, i] = qm(t) ? $m.map(s => a => t[s](e, a, n)) : Um(t) ? Bm.map(fc(t, e)) : zm(t) ? Hm.map(fc(t, e)) : []; if (!o && ln(t)) return Ne(s => Ji(s, e, n))(F(t)); if (!o) throw new TypeError("Invalid event target"); return new P(s => { let a = (...l) => s.next(1 < l.length ? l : l[0]); return o(a), () => i(a) }) } function fc(t, e) { return n => r => t[n](e, r) } function Um(t) { return I(t.addListener) && I(t.removeListener) } function zm(t) { return I(t.on) && I(t.off) } function qm(t) { return I(t.addEventListener) && I(t.removeEventListener) } function Ft(t = 0, e, n = Zu) { let r = -1; return e != null && (Lr(e) ? n = e : r = e), new P(o => { let i = lc(t) ? +t - n.now() : t; i < 0 && (i = 0); let s = 0; return n.schedule(function () { o.closed || (o.next(s++), 0 <= r ? this.schedule(void 0, r) : o.complete()) }, i) }) } function Gm(t = 0, e = Ke) { return t < 0 && (t = 0), Ft(t, t, e) } function Wm(...t) { let e = ke(t), n = Ku(t, 1 / 0), r = t; return r.length ? r.length === 1 ? F(r[0]) : Yr(n)(Le(r, e)) : At } function Rt(t, e) { return _((n, r) => { let o = 0; n.subscribe(E(r, i => t.call(e, i, o++) && r.next(i))) }) } function hc(t) { return _((e, n) => { let r = !1, o = null, i = null, s = !1, a = () => { if (i?.unsubscribe(), i = null, r) { r = !1; let u = o; o = null, n.next(u) } s && n.complete() }, l = () => { i = null, s && n.complete() }; e.subscribe(E(n, u => { r = !0, o = u, i || F(t(u)).subscribe(i = E(n, a, l)) }, () => { s = !0, (!r || !i || i.closed) && n.complete() })) }) } function Qm(t, e = Ke) { return hc(() => Ft(t, e)) } function pc(t) { return _((e, n) => { let r = null, o = !1, i; r = e.subscribe(E(n, void 0, void 0, s => { i = F(t(s, pc(t)(e))), r ? (r.unsubscribe(), r = null, i.subscribe(n)) : o = !0 })), o && (r.unsubscribe(), r = null, i.subscribe(n)) }) } function mc(t, e, n, r, o) { return (i, s) => { let a = n, l = e, u = 0; i.subscribe(E(s, c => { let d = u++; l = a ? t(l, c, d) : (a = !0, c), r && s.next(l) }, o && (() => { a && s.next(l), s.complete() }))) } } function Zm(t, e) { return I(e) ? Ne(t, e, 1) : Ne(t, 1) } function Km(t) { return _((e, n) => { let r = !1, o = null, i = null, s = () => { if (i?.unsubscribe(), i = null, r) { r = !1; let a = o; o = null, n.next(a) } }; e.subscribe(E(n, a => { i?.unsubscribe(), r = !0, o = a, i = E(n, s, Te), F(t(a)).subscribe(i) }, () => { s(), n.complete() }, void 0, () => { o = i = null })) }) } function Ym(t, e = Ke) { return _((n, r) => { let o = null, i = null, s = null, a = () => { if (o) { o.unsubscribe(), o = null; let u = i; i = null, r.next(u) } }; function l() { let u = s + t, c = e.now(); if (c < u) { o = this.schedule(void 0, u - c), r.add(o); return } a() } n.subscribe(E(r, u => { i = u, s = e.now(), o || (o = e.schedule(l, t), r.add(o)) }, () => { a(), r.complete() }, void 0, () => { i = o = null })) }) } function qn(t) { return _((e, n) => { let r = !1; e.subscribe(E(n, o => { r = !0, n.next(o) }, () => { r || n.next(t), n.complete() })) }) } function dn(t) { return t <= 0 ? () => At : _((e, n) => { let r = 0; e.subscribe(E(n, o => { ++r <= t && (n.next(o), t <= r && n.complete()) })) }) } function gc() { return _((t, e) => { t.subscribe(E(e, Te)) }) } function Xi(t) { return je(() => t) } function es(t, e) { return e ? n => cn(e.pipe(dn(1), gc()), n.pipe(es(t))) : Ne((n, r) => F(t(n, r)).pipe(dn(1), Xi(n))) } function Jm(t, e = Ke) { let n = Ft(t, e); return es(() => n) } function Xm(t, e = X) { return t = t ?? eg, _((n, r) => { let o, i = !0; n.subscribe(E(r, s => { let a = e(s); (i || !t(o, a)) && (i = !1, o = a, r.next(s)) })) }) } function eg(t, e) { return t === e } function Jr(t = tg) { return _((e, n) => { let r = !1; e.subscribe(E(n, o => { r = !0, n.next(o) }, () => r ? n.complete() : n.error(t()))) }) } function tg() { return new Pt } function ng(t) { return _((e, n) => { try { e.subscribe(n) } finally { n.add(t) } }) } function yc(t, e) { let n = arguments.length >= 2; return r => r.pipe(t ? Rt((o, i) => t(o, i, r)) : X, dn(1), n ? qn(e) : Jr(() => new Pt)) } function ts(t) { return t <= 0 ? () => At : _((e, n) => { let r = []; e.subscribe(E(n, o => { r.push(o), t < r.length && r.shift() }, () => { for (let o of r) n.next(o); n.complete() }, void 0, () => { r = null })) }) } function rg(t, e) { let n = arguments.length >= 2; return r => r.pipe(t ? Rt((o, i) => t(o, i, r)) : X, ts(1), n ? qn(e) : Jr(() => new Pt)) } function og() { return _((t, e) => { let n, r = !1; t.subscribe(E(e, o => { let i = n; n = o, r && e.next([i, o]), r = !0 })) }) } function ig(t, e) { return _(mc(t, e, arguments.length >= 2, !0)) } function rs(t = {}) { let { connector: e = () => new _e, resetOnError: n = !0, resetOnComplete: r = !0, resetOnRefCountZero: o = !0 } = t; return i => { let s, a, l, u = 0, c = !1, d = !1, h = () => { a?.unsubscribe(), a = void 0 }, f = () => { h(), s = l = void 0, c = d = !1 }, p = () => { let m = s; f(), m?.unsubscribe() }; return _((m, D) => { u++, !d && !c && h(); let v = l = l ?? e(); D.add(() => { u--, u === 0 && !d && !c && (a = ns(p, o)) }), v.subscribe(D), !s && u > 0 && (s = new Ze({ next: b => v.next(b), error: b => { d = !0, h(), a = ns(f, n, b), v.error(b) }, complete: () => { c = !0, h(), a = ns(f, r), v.complete() } }), F(m).subscribe(s)) })(i) } } function ns(t, e, ...n) { if (e === !0) { t(); return } if (e === !1) return; let r = new Ze({ next: () => { r.unsubscribe(), t() } }); return F(e(...n)).subscribe(r) } function sg(t, e, n) { let r, o = !1; return t && typeof t == "object" ? { bufferSize: r = 1 / 0, windowTime: e = 1 / 0, refCount: o = !1, scheduler: n } = t : r = t ?? 1 / 0, rs({ connector: () => new Hn(r, e, n), resetOnError: !0, resetOnComplete: !1, resetOnRefCountZero: o }) } function ag(t) { return Rt((e, n) => t <= n) } function lg(...t) { let e = ke(t); return _((n, r) => { (e ? cn(t, n, e) : cn(t, n)).subscribe(r) }) } function ug(t, e) { return _((n, r) => { let o = null, i = 0, s = !1, a = () => s && !o && r.complete(); n.subscribe(E(r, l => { o?.unsubscribe(); let u = 0, c = i++; F(t(l, c)).subscribe(o = E(r, d => r.next(e ? e(l, d, c, u++) : d), () => { o = null, a() })) }, () => { s = !0, a() })) }) } function cg(t) { return _((e, n) => { F(t).subscribe(E(n, () => n.complete(), Te)), !n.closed && e.subscribe(n) }) } function dg(t, e = !1) { return _((n, r) => { let o = 0; n.subscribe(E(r, i => { let s = t(i, o++); (s || e) && r.next(i), !s && r.complete() })) }) } function fg(t, e, n) { let r = I(t) || e || n ? { next: t, error: e, complete: n } : t; return r ? _((o, i) => { var s; (s = r.subscribe) === null || s === void 0 || s.call(r); let a = !0; o.subscribe(E(i, l => { var u; (u = r.next) === null || u === void 0 || u.call(r, l), i.next(l) }, () => { var l; a = !1, (l = r.complete) === null || l === void 0 || l.call(r), i.complete() }, l => { var u; a = !1, (u = r.error) === null || u === void 0 || u.call(r, l), i.error(l) }, () => { var l, u; a && ((l = r.unsubscribe) === null || l === void 0 || l.call(r)), (u = r.finalize) === null || u === void 0 || u.call(r) })) }) : X } function hg(...t) { let e = an(t); return _((n, r) => { let o = t.length, i = new Array(o), s = t.map(() => !1), a = !1; for (let l = 0; l < o; l++)F(t[l]).subscribe(E(r, u => { i[l] = u, !a && !s[l] && (s[l] = !0, (a = s.every(X)) && (s = null)) }, Te)); n.subscribe(E(r, l => { if (a) { let u = [l, ...i]; r.next(e ? e(...u) : u) } })) }) } var ud = "https://g.co/ng/security#xss", g = class extends Error { constructor(e, n) { super(cd(e, n)), this.code = e } }; function cd(t, e) { return `${`NG0${Math.abs(t)}`}${e ? ": " + e : ""}` } function rr(t) { return { toString: t }.toString() } var Xr = "__parameters__"; function pg(t) { return function (...n) { if (t) { let r = t(...n); for (let o in r) this[o] = r[o] } } } function Pa(t, e, n) { return rr(() => { let r = pg(e); function o(...i) { if (this instanceof o) return r.apply(this, i), this; let s = new o(...i); return a.annotation = s, a; function a(l, u, c) { let d = l.hasOwnProperty(Xr) ? l[Xr] : Object.defineProperty(l, Xr, { value: [] })[Xr]; for (; d.length <= c;)d.push(null); return (d[c] = d[c] || []).push(s), l } } return n && (o.prototype = Object.create(n.prototype)), o.prototype.ngMetadataName = t, o.annotationCls = o, o }) } var ct = globalThis; function B(t) { for (let e in t) if (t[e] === B) return e; throw Error("Could not find renamed property on target object.") } function mg(t, e) { for (let n in e) e.hasOwnProperty(n) && !t.hasOwnProperty(n) && (t[n] = e[n]) } function ae(t) {
    if (typeof t == "string") return t; if (Array.isArray(t)) return "[" + t.map(ae).join(", ") + "]"; if (t == null) return "" + t; if (t.overriddenName) return `${t.overriddenName}`; if (t.name) return `${t.name}`; let e = t.toString(); if (e == null) return "" + e; let n = e.indexOf(`
`); return n === -1 ? e : e.substring(0, n)
} function vs(t, e) { return t == null || t === "" ? e === null ? "" : e : e == null || e === "" ? t : t + " " + e } var gg = B({ __forward_ref__: B }); function dd(t) { return t.__forward_ref__ = dd, t.toString = function () { return ae(this()) }, t } function ee(t) { return fd(t) ? t() : t } function fd(t) { return typeof t == "function" && t.hasOwnProperty(gg) && t.__forward_ref__ === dd } function $(t) { return { token: t.token, providedIn: t.providedIn || null, factory: t.factory, value: void 0 } } function hd(t) { return { providers: t.providers || [], imports: t.imports || [] } } function $o(t) { return vc(t, pd) || vc(t, md) } function WA(t) { return $o(t) !== null } function vc(t, e) { return t.hasOwnProperty(e) ? t[e] : null } function yg(t) { let e = t && (t[pd] || t[md]); return e || null } function Dc(t) { return t && (t.hasOwnProperty(Ec) || t.hasOwnProperty(vg)) ? t[Ec] : null } var pd = B({ \u0275prov: B }), Ec = B({ \u0275inj: B }), md = B({ ngInjectableDef: B }), vg = B({ ngInjectorDef: B }), V = class { constructor(e, n) { this._desc = e, this.ngMetadataName = "InjectionToken", this.\u0275prov = void 0, typeof n == "number" ? this.__NG_ELEMENT_ID__ = n : n !== void 0 && (this.\u0275prov = $({ token: this, providedIn: n.providedIn || "root", factory: n.factory })) } get multi() { return this } toString() { return `InjectionToken ${this._desc}` } }; function gd(t) { return t && !!t.\u0275providers } var Dg = B({ \u0275cmp: B }), Eg = B({ \u0275dir: B }), wg = B({ \u0275pipe: B }), _g = B({ \u0275mod: B }), ho = B({ \u0275fac: B }), Wn = B({ __NG_ELEMENT_ID__: B }), wc = B({ __NG_ENV_ID__: B }); function jt(t) { return typeof t == "string" ? t : t == null ? "" : String(t) } function Ig(t) { return typeof t == "function" ? t.name || t.toString() : typeof t == "object" && t != null && typeof t.type == "function" ? t.type.name || t.type.toString() : jt(t) } function bg(t, e) { let n = e ? `. Dependency path: ${e.join(" > ")} > ${t}` : ""; throw new g(-200, t) } function Fa(t, e) { throw new g(-201, !1) } var O = function (t) { return t[t.Default = 0] = "Default", t[t.Host = 1] = "Host", t[t.Self = 2] = "Self", t[t.SkipSelf = 4] = "SkipSelf", t[t.Optional = 8] = "Optional", t }(O || {}), Ds; function yd() { return Ds } function ue(t) { let e = Ds; return Ds = t, e } function vd(t, e, n) { let r = $o(t); if (r && r.providedIn == "root") return r.value === void 0 ? r.value = r.factory() : r.value; if (n & O.Optional) return null; if (e !== void 0) return e; Fa(t, "Injector") } var Cg = {}, Zn = Cg, Es = "__NG_DI_FLAG__", po = "ngTempTokenPath", Sg = "ngTokenPath", Mg = /\n/gm, Tg = "\u0275", _c = "__source", gn; function Ng() { return gn } function ut(t) { let e = gn; return gn = t, e } function xg(t, e = O.Default) { if (gn === void 0) throw new g(-203, !1); return gn === null ? vd(t, void 0, e) : gn.get(t, e & O.Optional ? null : void 0, e) } function de(t, e = O.Default) { return (yd() || xg)(ee(t), e) } function R(t, e = O.Default) { return de(t, Ho(e)) } function Ho(t) { return typeof t > "u" || typeof t == "number" ? t : 0 | (t.optional && 8) | (t.host && 1) | (t.self && 2) | (t.skipSelf && 4) } function ws(t) { let e = []; for (let n = 0; n < t.length; n++) { let r = ee(t[n]); if (Array.isArray(r)) { if (r.length === 0) throw new g(900, !1); let o, i = O.Default; for (let s = 0; s < r.length; s++) { let a = r[s], l = Ag(a); typeof l == "number" ? l === -1 ? o = a.token : i |= l : o = a } e.push(de(o, i)) } else e.push(de(r)) } return e } function Ra(t, e) { return t[Es] = e, t.prototype[Es] = e, t } function Ag(t) { return t[Es] } function Og(t, e, n, r) {
    let o = t[po]; throw e[_c] && o.unshift(e[_c]), t.message = Pg(`
`+ t.message, o, n, r), t[Sg] = o, t[po] = null, t
} function Pg(t, e, n, r = null) {
    t = t && t.charAt(0) === `
`&& t.charAt(1) == Tg ? t.slice(2) : t; let o = ae(e); if (Array.isArray(e)) o = e.map(ae).join(" -> "); else if (typeof e == "object") { let i = []; for (let s in e) if (e.hasOwnProperty(s)) { let a = e[s]; i.push(s + ":" + (typeof a == "string" ? JSON.stringify(a) : ae(a))) } o = `{${i.join(", ")}}` } return `${n}${r ? "(" + r + ")" : ""}[${o}]: ${t.replace(Mg, `
  `)}`
} var QA = Ra(Pa("Inject", t => ({ token: t })), -1), Dd = Ra(Pa("Optional"), 8); var Ed = Ra(Pa("SkipSelf"), 4); function Vt(t, e) { let n = t.hasOwnProperty(ho); return n ? t[ho] : null } function Fg(t, e, n) { if (t.length !== e.length) return !1; for (let r = 0; r < t.length; r++) { let o = t[r], i = e[r]; if (n && (o = n(o), i = n(i)), i !== o) return !1 } return !0 } function Rg(t) { return t.flat(Number.POSITIVE_INFINITY) } function ka(t, e) { t.forEach(n => Array.isArray(n) ? ka(n, e) : e(n)) } function wd(t, e, n) { e >= t.length ? t.push(n) : t.splice(e, 0, n) } function mo(t, e) { return e >= t.length - 1 ? t.pop() : t.splice(e, 1)[0] } function kg(t, e) { let n = []; for (let r = 0; r < t; r++)n.push(e); return n } function Lg(t, e, n, r) { let o = t.length; if (o == e) t.push(n, r); else if (o === 1) t.push(r, t[0]), t[0] = n; else { for (o--, t.push(t[o - 1], t[o]); o > e;) { let i = o - 2; t[o] = t[i], o-- } t[e] = n, t[e + 1] = r } } function La(t, e, n) { let r = or(t, e); return r >= 0 ? t[r | 1] = n : (r = ~r, Lg(t, r, e, n)), r } function os(t, e) { let n = or(t, e); if (n >= 0) return t[n | 1] } function or(t, e) { return jg(t, e, 1) } function jg(t, e, n) { let r = 0, o = t.length >> n; for (; o !== r;) { let i = r + (o - r >> 1), s = t[i << n]; if (e === s) return i << n; s > e ? o = i : r = i + 1 } return ~(o << n) } var Ye = {}, ce = [], go = new V(""), _d = new V("", -1), Id = new V(""), yo = class { get(e, n = Zn) { if (n === Zn) { let r = new Error(`NullInjectorError: No provider for ${ae(e)}!`); throw r.name = "NullInjectorError", r } return n } }, bd = function (t) { return t[t.OnPush = 0] = "OnPush", t[t.Default = 1] = "Default", t }(bd || {}), Kn = function (t) { return t[t.Emulated = 0] = "Emulated", t[t.None = 2] = "None", t[t.ShadowDom = 3] = "ShadowDom", t }(Kn || {}), ht = function (t) { return t[t.None = 0] = "None", t[t.SignalBased = 1] = "SignalBased", t[t.HasDecoratorInputTransform = 2] = "HasDecoratorInputTransform", t }(ht || {}); function Vg(t, e, n) { let r = t.length; for (; ;) { let o = t.indexOf(e, n); if (o === -1) return o; if (o === 0 || t.charCodeAt(o - 1) <= 32) { let i = e.length; if (o + i === r || t.charCodeAt(o + i) <= 32) return o } n = o + 1 } } function _s(t, e, n) { let r = 0; for (; r < n.length;) { let o = n[r]; if (typeof o == "number") { if (o !== 0) break; r++; let i = n[r++], s = n[r++], a = n[r++]; t.setAttribute(e, s, a, i) } else { let i = o, s = n[++r]; Bg(i) ? t.setProperty(e, i, s) : t.setAttribute(e, i, s), r++ } } return r } function Cd(t) { return t === 3 || t === 4 || t === 6 } function Bg(t) { return t.charCodeAt(0) === 64 } function Yn(t, e) { if (!(e === null || e.length === 0)) if (t === null || t.length === 0) t = e.slice(); else { let n = -1; for (let r = 0; r < e.length; r++) { let o = e[r]; typeof o == "number" ? n = o : n === 0 || (n === -1 || n === 2 ? Ic(t, n, o, null, e[++r]) : Ic(t, n, o, null, null)) } } return t } function Ic(t, e, n, r, o) { let i = 0, s = t.length; if (e === -1) s = -1; else for (; i < t.length;) { let a = t[i++]; if (typeof a == "number") { if (a === e) { s = -1; break } else if (a > e) { s = i - 1; break } } } for (; i < t.length;) { let a = t[i]; if (typeof a == "number") break; if (a === n) { if (r === null) { o !== null && (t[i + 1] = o); return } else if (r === t[i + 1]) { t[i + 2] = o; return } } i++, r !== null && i++, o !== null && i++ } s !== -1 && (t.splice(s, 0, e), i = s + 1), t.splice(i++, 0, n), r !== null && t.splice(i++, 0, r), o !== null && t.splice(i++, 0, o) } var Sd = "ng-template"; function $g(t, e, n, r) { let o = 0; if (r) { for (; o < e.length && typeof e[o] == "string"; o += 2)if (e[o] === "class" && Vg(e[o + 1].toLowerCase(), n, 0) !== -1) return !0 } else if (ja(t)) return !1; if (o = e.indexOf(1, o), o > -1) { let i; for (; ++o < e.length && typeof (i = e[o]) == "string";)if (i.toLowerCase() === n) return !0 } return !1 } function ja(t) { return t.type === 4 && t.value !== Sd } function Hg(t, e, n) { let r = t.type === 4 && !n ? Sd : t.value; return e === r } function Ug(t, e, n) { let r = 4, o = t.attrs, i = o !== null ? Gg(o) : 0, s = !1; for (let a = 0; a < e.length; a++) { let l = e[a]; if (typeof l == "number") { if (!s && !xe(r) && !xe(l)) return !1; if (s && xe(l)) continue; s = !1, r = l | r & 1; continue } if (!s) if (r & 4) { if (r = 2 | r & 1, l !== "" && !Hg(t, l, n) || l === "" && e.length === 1) { if (xe(r)) return !1; s = !0 } } else if (r & 8) { if (o === null || !$g(t, o, l, n)) { if (xe(r)) return !1; s = !0 } } else { let u = e[++a], c = zg(l, o, ja(t), n); if (c === -1) { if (xe(r)) return !1; s = !0; continue } if (u !== "") { let d; if (c > i ? d = "" : d = o[c + 1].toLowerCase(), r & 2 && u !== d) { if (xe(r)) return !1; s = !0 } } } } return xe(r) || s } function xe(t) { return (t & 1) === 0 } function zg(t, e, n, r) { if (e === null) return -1; let o = 0; if (r || !n) { let i = !1; for (; o < e.length;) { let s = e[o]; if (s === t) return o; if (s === 3 || s === 6) i = !0; else if (s === 1 || s === 2) { let a = e[++o]; for (; typeof a == "string";)a = e[++o]; continue } else { if (s === 4) break; if (s === 0) { o += 4; continue } } o += i ? 1 : 2 } return -1 } else return Wg(e, t) } function Md(t, e, n = !1) { for (let r = 0; r < e.length; r++)if (Ug(t, e[r], n)) return !0; return !1 } function qg(t) { let e = t.attrs; if (e != null) { let n = e.indexOf(5); if (!(n & 1)) return e[n + 1] } return null } function Gg(t) { for (let e = 0; e < t.length; e++) { let n = t[e]; if (Cd(n)) return e } return t.length } function Wg(t, e) { let n = t.indexOf(4); if (n > -1) for (n++; n < t.length;) { let r = t[n]; if (typeof r == "number") return -1; if (r === e) return n; n++ } return -1 } function Qg(t, e) { e: for (let n = 0; n < e.length; n++) { let r = e[n]; if (t.length === r.length) { for (let o = 0; o < t.length; o++)if (t[o] !== r[o]) continue e; return !0 } } return !1 } function bc(t, e) { return t ? ":not(" + e.trim() + ")" : e } function Zg(t) { let e = t[0], n = 1, r = 2, o = "", i = !1; for (; n < t.length;) { let s = t[n]; if (typeof s == "string") if (r & 2) { let a = t[++n]; o += "[" + s + (a.length > 0 ? '="' + a + '"' : "") + "]" } else r & 8 ? o += "." + s : r & 4 && (o += " " + s); else o !== "" && !xe(s) && (e += bc(i, o), o = ""), r = s, i = i || !xe(r); n++ } return o !== "" && (e += bc(i, o)), e } function Kg(t) { return t.map(Zg).join(",") } function Yg(t) { let e = [], n = [], r = 1, o = 2; for (; r < t.length;) { let i = t[r]; if (typeof i == "string") o === 2 ? i !== "" && e.push(i, t[++r]) : o === 8 && n.push(i); else { if (!xe(o)) break; o = i } r++ } return { attrs: e, classes: n } } function ZA(t) { return rr(() => { let e = Ad(t), n = We(me({}, e), { decls: t.decls, vars: t.vars, template: t.template, consts: t.consts || null, ngContentSelectors: t.ngContentSelectors, onPush: t.changeDetection === bd.OnPush, directiveDefs: null, pipeDefs: null, dependencies: e.standalone && t.dependencies || null, getStandaloneInjector: null, signals: t.signals ?? !1, data: t.data || {}, encapsulation: t.encapsulation || Kn.Emulated, styles: t.styles || ce, _: null, schemas: t.schemas || null, tView: null, id: "" }); Od(n); let r = t.dependencies; return n.directiveDefs = Sc(r, !1), n.pipeDefs = Sc(r, !0), n.id = ty(n), n }) } function Jg(t) { return pt(t) || Va(t) } function Xg(t) { return t !== null } function Td(t) { return rr(() => ({ type: t.type, bootstrap: t.bootstrap || ce, declarations: t.declarations || ce, imports: t.imports || ce, exports: t.exports || ce, transitiveCompileScopes: null, schemas: t.schemas || null, id: t.id || null })) } function Cc(t, e) { if (t == null) return Ye; let n = {}; for (let r in t) if (t.hasOwnProperty(r)) { let o = t[r], i, s, a = ht.None; Array.isArray(o) ? (a = o[0], i = o[1], s = o[2] ?? i) : (i = o, s = o), e ? (n[i] = a !== ht.None ? [r, a] : r, e[i] = s) : n[i] = r } return n } function ir(t) { return rr(() => { let e = Ad(t); return Od(e), e }) } function Uo(t) { return { type: t.type, name: t.name, factory: null, pure: t.pure !== !1, standalone: t.standalone === !0, onDestroy: t.type.prototype.ngOnDestroy || null } } function pt(t) { return t[Dg] || null } function Va(t) { return t[Eg] || null } function Nd(t) { return t[wg] || null } function ey(t) { let e = pt(t) || Va(t) || Nd(t); return e !== null ? e.standalone : !1 } function xd(t, e) { let n = t[_g] || null; if (!n && e === !0) throw new Error(`Type ${ae(t)} does not have '\u0275mod' property.`); return n } function Ad(t) { let e = {}; return { type: t.type, providersResolver: null, factory: null, hostBindings: t.hostBindings || null, hostVars: t.hostVars || 0, hostAttrs: t.hostAttrs || null, contentQueries: t.contentQueries || null, declaredInputs: e, inputTransforms: null, inputConfig: t.inputs || Ye, exportAs: t.exportAs || null, standalone: t.standalone === !0, signals: t.signals === !0, selectors: t.selectors || ce, viewQuery: t.viewQuery || null, features: t.features || null, setInput: null, findHostDirectiveDefs: null, hostDirectives: null, inputs: Cc(t.inputs, e), outputs: Cc(t.outputs), debugInfo: null } } function Od(t) { t.features?.forEach(e => e(t)) } function Sc(t, e) { if (!t) return null; let n = e ? Nd : Jg; return () => (typeof t == "function" ? t() : t).map(r => n(r)).filter(Xg) } function ty(t) { let e = 0, n = [t.selectors, t.ngContentSelectors, t.hostVars, t.hostAttrs, t.consts, t.vars, t.decls, t.encapsulation, t.standalone, t.signals, t.exportAs, JSON.stringify(t.inputs), JSON.stringify(t.outputs), Object.getOwnPropertyNames(t.type.prototype), !!t.contentQueries, !!t.viewQuery].join("|"); for (let o of n) e = Math.imul(31, e) + o.charCodeAt(0) << 0; return e += 2147483648, "c" + e } function KA(t) { return { \u0275providers: t } } function ny(...t) { return { \u0275providers: Pd(!0, t), \u0275fromNgModule: !0 } } function Pd(t, ...e) { let n = [], r = new Set, o, i = s => { n.push(s) }; return ka(e, s => { let a = s; Is(a, i, [], r) && (o ||= [], o.push(a)) }), o !== void 0 && Fd(o, i), n } function Fd(t, e) { for (let n = 0; n < t.length; n++) { let { ngModule: r, providers: o } = t[n]; Ba(o, i => { e(i, r) }) } } function Is(t, e, n, r) { if (t = ee(t), !t) return !1; let o = null, i = Dc(t), s = !i && pt(t); if (!i && !s) { let l = t.ngModule; if (i = Dc(l), i) o = l; else return !1 } else { if (s && !s.standalone) return !1; o = t } let a = r.has(o); if (s) { if (a) return !1; if (r.add(o), s.dependencies) { let l = typeof s.dependencies == "function" ? s.dependencies() : s.dependencies; for (let u of l) Is(u, e, n, r) } } else if (i) { if (i.imports != null && !a) { r.add(o); let u; try { ka(i.imports, c => { Is(c, e, n, r) && (u ||= [], u.push(c)) }) } finally { } u !== void 0 && Fd(u, e) } if (!a) { let u = Vt(o) || (() => new o); e({ provide: o, useFactory: u, deps: ce }, o), e({ provide: Id, useValue: o, multi: !0 }, o), e({ provide: go, useValue: () => de(o), multi: !0 }, o) } let l = i.providers; if (l != null && !a) { let u = t; Ba(l, c => { e(c, u) }) } } else return !1; return o !== t && t.providers !== void 0 } function Ba(t, e) { for (let n of t) gd(n) && (n = n.\u0275providers), Array.isArray(n) ? Ba(n, e) : e(n) } var ry = B({ provide: String, useValue: B }); function Rd(t) { return t !== null && typeof t == "object" && ry in t } function oy(t) { return !!(t && t.useExisting) } function iy(t) { return !!(t && t.useFactory) } function vn(t) { return typeof t == "function" } function sy(t) { return !!t.useClass } var kd = new V(""), so = {}, ay = {}, is; function zo() { return is === void 0 && (is = new yo), is } var mt = class { }, Jn = class extends mt { get destroyed() { return this._destroyed } constructor(e, n, r, o) { super(), this.parent = n, this.source = r, this.scopes = o, this.records = new Map, this._ngOnDestroyHooks = new Set, this._onDestroyHooks = [], this._destroyed = !1, Cs(e, s => this.processProvider(s)), this.records.set(_d, fn(void 0, this)), o.has("environment") && this.records.set(mt, fn(void 0, this)); let i = this.records.get(kd); i != null && typeof i.value == "string" && this.scopes.add(i.value), this.injectorDefTypes = new Set(this.get(Id, ce, O.Self)) } destroy() { this.assertNotDestroyed(), this._destroyed = !0; let e = A(null); try { for (let r of this._ngOnDestroyHooks) r.ngOnDestroy(); let n = this._onDestroyHooks; this._onDestroyHooks = []; for (let r of n) r() } finally { this.records.clear(), this._ngOnDestroyHooks.clear(), this.injectorDefTypes.clear(), A(e) } } onDestroy(e) { return this.assertNotDestroyed(), this._onDestroyHooks.push(e), () => this.removeOnDestroy(e) } runInContext(e) { this.assertNotDestroyed(); let n = ut(this), r = ue(void 0), o; try { return e() } finally { ut(n), ue(r) } } get(e, n = Zn, r = O.Default) { if (this.assertNotDestroyed(), e.hasOwnProperty(wc)) return e[wc](this); r = Ho(r); let o, i = ut(this), s = ue(void 0); try { if (!(r & O.SkipSelf)) { let l = this.records.get(e); if (l === void 0) { let u = fy(e) && $o(e); u && this.injectableDefInScope(u) ? l = fn(bs(e), so) : l = null, this.records.set(e, l) } if (l != null) return this.hydrate(e, l) } let a = r & O.Self ? zo() : this.parent; return n = r & O.Optional && n === Zn ? null : n, a.get(e, n) } catch (a) { if (a.name === "NullInjectorError") { if ((a[po] = a[po] || []).unshift(ae(e)), i) throw a; return Og(a, e, "R3InjectorError", this.source) } else throw a } finally { ue(s), ut(i) } } resolveInjectorInitializers() { let e = A(null), n = ut(this), r = ue(void 0), o; try { let i = this.get(go, ce, O.Self); for (let s of i) s() } finally { ut(n), ue(r), A(e) } } toString() { let e = [], n = this.records; for (let r of n.keys()) e.push(ae(r)); return `R3Injector[${e.join(", ")}]` } assertNotDestroyed() { if (this._destroyed) throw new g(205, !1) } processProvider(e) { e = ee(e); let n = vn(e) ? e : ee(e && e.provide), r = uy(e); if (!vn(e) && e.multi === !0) { let o = this.records.get(n); o || (o = fn(void 0, so, !0), o.factory = () => ws(o.multi), this.records.set(n, o)), n = e, o.multi.push(e) } this.records.set(n, r) } hydrate(e, n) { let r = A(null); try { return n.value === so && (n.value = ay, n.value = n.factory()), typeof n.value == "object" && n.value && dy(n.value) && this._ngOnDestroyHooks.add(n.value), n.value } finally { A(r) } } injectableDefInScope(e) { if (!e.providedIn) return !1; let n = ee(e.providedIn); return typeof n == "string" ? n === "any" || this.scopes.has(n) : this.injectorDefTypes.has(n) } removeOnDestroy(e) { let n = this._onDestroyHooks.indexOf(e); n !== -1 && this._onDestroyHooks.splice(n, 1) } }; function bs(t) { let e = $o(t), n = e !== null ? e.factory : Vt(t); if (n !== null) return n; if (t instanceof V) throw new g(204, !1); if (t instanceof Function) return ly(t); throw new g(204, !1) } function ly(t) { if (t.length > 0) throw new g(204, !1); let n = yg(t); return n !== null ? () => n.factory(t) : () => new t } function uy(t) { if (Rd(t)) return fn(void 0, t.useValue); { let e = Ld(t); return fn(e, so) } } function Ld(t, e, n) { let r; if (vn(t)) { let o = ee(t); return Vt(o) || bs(o) } else if (Rd(t)) r = () => ee(t.useValue); else if (iy(t)) r = () => t.useFactory(...ws(t.deps || [])); else if (oy(t)) r = () => de(ee(t.useExisting)); else { let o = ee(t && (t.useClass || t.provide)); if (cy(t)) r = () => new o(...ws(t.deps)); else return Vt(o) || bs(o) } return r } function fn(t, e, n = !1) { return { factory: t, value: e, multi: n ? [] : void 0 } } function cy(t) { return !!t.deps } function dy(t) { return t !== null && typeof t == "object" && typeof t.ngOnDestroy == "function" } function fy(t) { return typeof t == "function" || typeof t == "object" && t instanceof V } function Cs(t, e) { for (let n of t) Array.isArray(n) ? Cs(n, e) : n && gd(n) ? Cs(n.\u0275providers, e) : e(n) } function YA(t, e) { t instanceof Jn && t.assertNotDestroyed(); let n, r = ut(t), o = ue(void 0); try { return e() } finally { ut(r), ue(o) } } function jd() { return yd() !== void 0 || Ng() != null } function Vd(t) { if (!jd()) throw new g(-203, !1) } var JA = Function; function hy(t) { return typeof t == "function" } var Ue = 0, T = 1, M = 2, se = 3, Pe = 4, he = 5, Dn = 6, vo = 7, te = 8, En = 9, $e = 10, z = 11, Xn = 12, Mc = 13, xn = 14, fe = 15, Bt = 16, hn = 17, Je = 18, qo = 19, Bd = 20, dt = 21, ss = 22, Ie = 23, Y = 25, $a = 1; var $t = 7, Do = 8, wn = 9, ie = 10, Eo = function (t) { return t[t.None = 0] = "None", t[t.HasTransplantedViews = 2] = "HasTransplantedViews", t }(Eo || {}); function ft(t) { return Array.isArray(t) && typeof t[$a] == "object" } function nt(t) { return Array.isArray(t) && t[$a] === !0 } function Ha(t) { return (t.flags & 4) !== 0 } function Go(t) { return t.componentOffset > -1 } function Wo(t) { return (t.flags & 1) === 1 } function Xe(t) { return !!t.template } function Ss(t) { return (t[M] & 512) !== 0 } var Ms = class { constructor(e, n, r) { this.previousValue = e, this.currentValue = n, this.firstChange = r } isFirstChange() { return this.firstChange } }; function $d(t, e, n, r) { e !== null ? e.applyValueToInputSignal(e, r) : t[n] = r } function Ua() { return Hd } function Hd(t) { return t.type.prototype.ngOnChanges && (t.setInput = my), py } Ua.ngInherit = !0; function py() { let t = zd(this), e = t?.current; if (e) { let n = t.previous; if (n === Ye) t.previous = e; else for (let r in e) n[r] = e[r]; t.current = null, this.ngOnChanges(e) } } function my(t, e, n, r, o) { let i = this.declaredInputs[r], s = zd(t) || gy(t, { previous: Ye, current: null }), a = s.current || (s.current = {}), l = s.previous, u = l[i]; a[i] = new Ms(u && u.currentValue, n, l === Ye), $d(t, e, o, n) } var Ud = "__ngSimpleChanges__"; function zd(t) { return t[Ud] || null } function gy(t, e) { return t[Ud] = e } var Tc = null; var Ve = function (t, e, n) { Tc?.(t, e, n) }, qd = "svg", yy = "math"; function He(t) { for (; Array.isArray(t);)t = t[Ue]; return t } function vy(t) { for (; Array.isArray(t);) { if (typeof t[$a] == "object") return t; t = t[Ue] } return null } function Gd(t, e) { return He(e[t]) } function be(t, e) { return He(e[t.index]) } function za(t, e) { return t.data[e] } function qa(t, e) { return t[e] } function Et(t, e) { let n = e[t]; return ft(n) ? n : n[Ue] } function Dy(t) { return (t[M] & 4) === 4 } function Ga(t) { return (t[M] & 128) === 128 } function Ey(t) { return nt(t[se]) } function gt(t, e) { return e == null ? null : t[e] } function Wd(t) { t[hn] = 0 } function Qd(t) { t[M] & 1024 || (t[M] |= 1024, Ga(t) && Zo(t)) } function wy(t, e) { for (; t > 0;)e = e[xn], t--; return e } function Qo(t) { return !!(t[M] & 9216 || t[Ie]?.dirty) } function Ts(t) { t[$e].changeDetectionScheduler?.notify(8), t[M] & 64 && (t[M] |= 1024), Qo(t) && Zo(t) } function Zo(t) { t[$e].changeDetectionScheduler?.notify(0); let e = Ht(t); for (; e !== null && !(e[M] & 8192 || (e[M] |= 8192, !Ga(e)));)e = Ht(e) } function Zd(t, e) { if ((t[M] & 256) === 256) throw new g(911, !1); t[dt] === null && (t[dt] = []), t[dt].push(e) } function _y(t, e) { if (t[dt] === null) return; let n = t[dt].indexOf(e); n !== -1 && t[dt].splice(n, 1) } function Ht(t) { let e = t[se]; return nt(e) ? e[se] : e } var x = { lFrame: of(null), bindingsEnabled: !0, skipHydrationRootTNode: null }; var Kd = !1; function Iy() { return x.lFrame.elementDepthCount } function by() { x.lFrame.elementDepthCount++ } function Cy() { x.lFrame.elementDepthCount-- } function Yd() { return x.bindingsEnabled } function Jd() { return x.skipHydrationRootTNode !== null } function Sy(t) { return x.skipHydrationRootTNode === t } function My() { x.skipHydrationRootTNode = null } function S() { return x.lFrame.lView } function H() { return x.lFrame.tView } function XA(t) { return x.lFrame.contextLView = t, t[te] } function eO(t) { return x.lFrame.contextLView = null, t } function J() { let t = Xd(); for (; t !== null && t.type === 64;)t = t.parent; return t } function Xd() { return x.lFrame.currentTNode } function Ty() { let t = x.lFrame, e = t.currentTNode; return t.isParent ? e : e.parent } function Qt(t, e) { let n = x.lFrame; n.currentTNode = t, n.isParent = e } function Wa() { return x.lFrame.isParent } function Qa() { x.lFrame.isParent = !1 } function Ny() { return x.lFrame.contextLView } function ef() { return Kd } function Nc(t) { Kd = t } function sr() { let t = x.lFrame, e = t.bindingRootIndex; return e === -1 && (e = t.bindingRootIndex = t.tView.bindingStartIndex), e } function xy() { return x.lFrame.bindingIndex } function Ay(t) { return x.lFrame.bindingIndex = t } function wt() { return x.lFrame.bindingIndex++ } function Za(t) { let e = x.lFrame, n = e.bindingIndex; return e.bindingIndex = e.bindingIndex + t, n } function Oy() { return x.lFrame.inI18n } function Py(t, e) { let n = x.lFrame; n.bindingIndex = n.bindingRootIndex = t, Ns(e) } function Fy() { return x.lFrame.currentDirectiveIndex } function Ns(t) { x.lFrame.currentDirectiveIndex = t } function Ka(t) { let e = x.lFrame.currentDirectiveIndex; return e === -1 ? null : t[e] } function tf() { return x.lFrame.currentQueryIndex } function Ya(t) { x.lFrame.currentQueryIndex = t } function Ry(t) { let e = t[T]; return e.type === 2 ? e.declTNode : e.type === 1 ? t[he] : null } function nf(t, e, n) { if (n & O.SkipSelf) { let o = e, i = t; for (; o = o.parent, o === null && !(n & O.Host);)if (o = Ry(i), o === null || (i = i[xn], o.type & 10)) break; if (o === null) return !1; e = o, t = i } let r = x.lFrame = rf(); return r.currentTNode = e, r.lView = t, !0 } function Ja(t) { let e = rf(), n = t[T]; x.lFrame = e, e.currentTNode = n.firstChild, e.lView = t, e.tView = n, e.contextLView = t, e.bindingIndex = n.bindingStartIndex, e.inI18n = !1 } function rf() { let t = x.lFrame, e = t === null ? null : t.child; return e === null ? of(t) : e } function of(t) { let e = { currentTNode: null, isParent: !0, lView: null, tView: null, selectedIndex: -1, contextLView: null, elementDepthCount: 0, currentNamespace: null, currentDirectiveIndex: -1, bindingRootIndex: -1, bindingIndex: -1, currentQueryIndex: 0, parent: t, child: null, inI18n: !1 }; return t !== null && (t.child = e), e } function sf() { let t = x.lFrame; return x.lFrame = t.parent, t.currentTNode = null, t.lView = null, t } var af = sf; function Xa() { let t = sf(); t.isParent = !0, t.tView = null, t.selectedIndex = -1, t.contextLView = null, t.elementDepthCount = 0, t.currentDirectiveIndex = -1, t.currentNamespace = null, t.bindingRootIndex = -1, t.bindingIndex = -1, t.currentQueryIndex = 0 } function ky(t) { return (x.lFrame.contextLView = wy(t, x.lFrame.contextLView))[te] } function rt() { return x.lFrame.selectedIndex } function Ut(t) { x.lFrame.selectedIndex = t } function ar() { let t = x.lFrame; return za(t.tView, t.selectedIndex) } function tO() { x.lFrame.currentNamespace = qd } function Ly() { return x.lFrame.currentNamespace } var lf = !0; function Ko() { return lf } function Yo(t) { lf = t } function jy(t, e, n) { let { ngOnChanges: r, ngOnInit: o, ngDoCheck: i } = e.type.prototype; if (r) { let s = Hd(e); (n.preOrderHooks ??= []).push(t, s), (n.preOrderCheckHooks ??= []).push(t, s) } o && (n.preOrderHooks ??= []).push(0 - t, o), i && ((n.preOrderHooks ??= []).push(t, i), (n.preOrderCheckHooks ??= []).push(t, i)) } function Jo(t, e) { for (let n = e.directiveStart, r = e.directiveEnd; n < r; n++) { let i = t.data[n].type.prototype, { ngAfterContentInit: s, ngAfterContentChecked: a, ngAfterViewInit: l, ngAfterViewChecked: u, ngOnDestroy: c } = i; s && (t.contentHooks ??= []).push(-n, s), a && ((t.contentHooks ??= []).push(n, a), (t.contentCheckHooks ??= []).push(n, a)), l && (t.viewHooks ??= []).push(-n, l), u && ((t.viewHooks ??= []).push(n, u), (t.viewCheckHooks ??= []).push(n, u)), c != null && (t.destroyHooks ??= []).push(n, c) } } function ao(t, e, n) { uf(t, e, 3, n) } function lo(t, e, n, r) { (t[M] & 3) === n && uf(t, e, n, r) } function as(t, e) { let n = t[M]; (n & 3) === e && (n &= 16383, n += 1, t[M] = n) } function uf(t, e, n, r) { let o = r !== void 0 ? t[hn] & 65535 : 0, i = r ?? -1, s = e.length - 1, a = 0; for (let l = o; l < s; l++)if (typeof e[l + 1] == "number") { if (a = e[l], r != null && a >= r) break } else e[l] < 0 && (t[hn] += 65536), (a < i || i == -1) && (Vy(t, n, e, l), t[hn] = (t[hn] & 4294901760) + l + 2), l++ } function xc(t, e) { Ve(4, t, e); let n = A(null); try { e.call(t) } finally { A(n), Ve(5, t, e) } } function Vy(t, e, n, r) { let o = n[r] < 0, i = n[r + 1], s = o ? -n[r] : n[r], a = t[s]; o ? t[M] >> 14 < t[hn] >> 16 && (t[M] & 3) === e && (t[M] += 16384, xc(a, i)) : xc(a, i) } var yn = -1, zt = class { constructor(e, n, r) { this.factory = e, this.resolving = !1, this.canSeeViewProviders = n, this.injectImpl = r } }; function By(t) { return t instanceof zt } function $y(t) { return (t.flags & 8) !== 0 } function Hy(t) { return (t.flags & 16) !== 0 } var ls = {}, xs = class { constructor(e, n) { this.injector = e, this.parentInjector = n } get(e, n, r) { r = Ho(r); let o = this.injector.get(e, ls, r); return o !== ls || n === ls ? o : this.parentInjector.get(e, n, r) } }; function cf(t) { return t !== yn } function wo(t) { return t & 32767 } function Uy(t) { return t >> 16 } function _o(t, e) { let n = Uy(t), r = e; for (; n > 0;)r = r[xn], n--; return r } var As = !0; function Io(t) { let e = As; return As = t, e } var zy = 256, df = zy - 1, ff = 5, qy = 0, Be = {}; function Gy(t, e, n) { let r; typeof n == "string" ? r = n.charCodeAt(0) || 0 : n.hasOwnProperty(Wn) && (r = n[Wn]), r == null && (r = n[Wn] = qy++); let o = r & df, i = 1 << o; e.data[t + (o >> ff)] |= i } function bo(t, e) { let n = hf(t, e); if (n !== -1) return n; let r = e[T]; r.firstCreatePass && (t.injectorIndex = e.length, us(r.data, t), us(e, null), us(r.blueprint, null)); let o = el(t, e), i = t.injectorIndex; if (cf(o)) { let s = wo(o), a = _o(o, e), l = a[T].data; for (let u = 0; u < 8; u++)e[i + u] = a[s + u] | l[s + u] } return e[i + 8] = o, i } function us(t, e) { t.push(0, 0, 0, 0, 0, 0, 0, 0, e) } function hf(t, e) { return t.injectorIndex === -1 || t.parent && t.parent.injectorIndex === t.injectorIndex || e[t.injectorIndex + 8] === null ? -1 : t.injectorIndex } function el(t, e) { if (t.parent && t.parent.injectorIndex !== -1) return t.parent.injectorIndex; let n = 0, r = null, o = e; for (; o !== null;) { if (r = vf(o), r === null) return yn; if (n++, o = o[xn], r.injectorIndex !== -1) return r.injectorIndex | n << 16 } return yn } function Os(t, e, n) { Gy(t, e, n) } function Wy(t, e) { if (e === "class") return t.classes; if (e === "style") return t.styles; let n = t.attrs; if (n) { let r = n.length, o = 0; for (; o < r;) { let i = n[o]; if (Cd(i)) break; if (i === 0) o = o + 2; else if (typeof i == "number") for (o++; o < r && typeof n[o] == "string";)o++; else { if (i === e) return n[o + 1]; o = o + 2 } } } return null } function pf(t, e, n) { if (n & O.Optional || t !== void 0) return t; Fa(e, "NodeInjector") } function mf(t, e, n, r) { if (n & O.Optional && r === void 0 && (r = null), !(n & (O.Self | O.Host))) { let o = t[En], i = ue(void 0); try { return o ? o.get(e, r, n & O.Optional) : vd(e, r, n & O.Optional) } finally { ue(i) } } return pf(r, e, n) } function gf(t, e, n, r = O.Default, o) { if (t !== null) { if (e[M] & 2048 && !(r & O.Self)) { let s = Yy(t, e, n, r, Be); if (s !== Be) return s } let i = yf(t, e, n, r, Be); if (i !== Be) return i } return mf(e, n, r, o) } function yf(t, e, n, r, o) { let i = Zy(n); if (typeof i == "function") { if (!nf(e, t, r)) return r & O.Host ? pf(o, n, r) : mf(e, n, r, o); try { let s; if (s = i(r), s == null && !(r & O.Optional)) Fa(n); else return s } finally { af() } } else if (typeof i == "number") { let s = null, a = hf(t, e), l = yn, u = r & O.Host ? e[fe][he] : null; for ((a === -1 || r & O.SkipSelf) && (l = a === -1 ? el(t, e) : e[a + 8], l === yn || !Oc(r, !1) ? a = -1 : (s = e[T], a = wo(l), e = _o(l, e))); a !== -1;) { let c = e[T]; if (Ac(i, a, c.data)) { let d = Qy(a, e, n, s, r, u); if (d !== Be) return d } l = e[a + 8], l !== yn && Oc(r, e[T].data[a + 8] === u) && Ac(i, a, e) ? (s = c, a = wo(l), e = _o(l, e)) : a = -1 } } return o } function Qy(t, e, n, r, o, i) { let s = e[T], a = s.data[t + 8], l = r == null ? Go(a) && As : r != s && (a.type & 3) !== 0, u = o & O.Host && i === a, c = uo(a, s, n, l, u); return c !== null ? qt(e, s, c, a) : Be } function uo(t, e, n, r, o) { let i = t.providerIndexes, s = e.data, a = i & 1048575, l = t.directiveStart, u = t.directiveEnd, c = i >> 20, d = r ? a : a + c, h = o ? a + c : u; for (let f = d; f < h; f++) { let p = s[f]; if (f < l && n === p || f >= l && p.type === n) return f } if (o) { let f = s[l]; if (f && Xe(f) && f.type === n) return l } return null } function qt(t, e, n, r) { let o = t[n], i = e.data; if (By(o)) { let s = o; s.resolving && bg(Ig(i[n])); let a = Io(s.canSeeViewProviders); s.resolving = !0; let l, u = s.injectImpl ? ue(s.injectImpl) : null, c = nf(t, r, O.Default); try { o = t[n] = s.factory(void 0, i, t, r), e.firstCreatePass && n >= r.directiveStart && jy(n, i[n], e) } finally { u !== null && ue(u), Io(a), s.resolving = !1, af() } } return o } function Zy(t) { if (typeof t == "string") return t.charCodeAt(0) || 0; let e = t.hasOwnProperty(Wn) ? t[Wn] : void 0; return typeof e == "number" ? e >= 0 ? e & df : Ky : e } function Ac(t, e, n) { let r = 1 << t; return !!(n[e + (t >> ff)] & r) } function Oc(t, e) { return !(t & O.Self) && !(t & O.Host && e) } var Lt = class { constructor(e, n) { this._tNode = e, this._lView = n } get(e, n, r) { return gf(this._tNode, this._lView, e, Ho(r), n) } }; function Ky() { return new Lt(J(), S()) } function nO(t) { return rr(() => { let e = t.prototype.constructor, n = e[ho] || Ps(e), r = Object.prototype, o = Object.getPrototypeOf(t.prototype).constructor; for (; o && o !== r;) { let i = o[ho] || Ps(o); if (i && i !== n) return i; o = Object.getPrototypeOf(o) } return i => new i }) } function Ps(t) { return fd(t) ? () => { let e = Ps(ee(t)); return e && e() } : Vt(t) } function Yy(t, e, n, r, o) { let i = t, s = e; for (; i !== null && s !== null && s[M] & 2048 && !(s[M] & 512);) { let a = yf(i, s, n, r | O.Self, Be); if (a !== Be) return a; let l = i.parent; if (!l) { let u = s[Bd]; if (u) { let c = u.get(n, Be, r); if (c !== Be) return c } l = vf(s), s = s[xn] } i = l } return o } function vf(t) { let e = t[T], n = e.type; return n === 2 ? e.declTNode : n === 1 ? t[he] : null } function Jy(t) { return Wy(J(), t) } function Pc(t, e = null, n = null, r) { let o = Df(t, e, n, r); return o.resolveInjectorInitializers(), o } function Df(t, e = null, n = null, r, o = new Set) { let i = [n || ce, ny(t)]; return r = r || (typeof t == "object" ? void 0 : ae(t)), new Jn(i, e || zo(), r || null, o) } var yt = class t { static { this.THROW_IF_NOT_FOUND = Zn } static { this.NULL = new yo } static create(e, n) { if (Array.isArray(e)) return Pc({ name: "" }, n, e, ""); { let r = e.name ?? ""; return Pc({ name: r }, e.parent, e.providers, r) } } static { this.\u0275prov = $({ token: t, providedIn: "any", factory: () => de(_d) }) } static { this.__NG_ELEMENT_ID__ = -1 } }; var Xy = new V(""); Xy.__NG_ELEMENT_ID__ = t => { let e = J(); if (e === null) throw new g(204, !1); if (e.type & 2) return e.value; if (t & O.Optional) return null; throw new g(204, !1) }; var ev = "ngOriginalError"; function cs(t) { return t[ev] } var Ef = !0, tl = (() => { class t { static { this.__NG_ELEMENT_ID__ = tv } static { this.__NG_ENV_ID__ = n => n } } return t })(), Fs = class extends tl { constructor(e) { super(), this._lView = e } onDestroy(e) { return Zd(this._lView, e), () => _y(this._lView, e) } }; function tv() { return new Fs(S()) } var Xo = (() => { class t { constructor() { this.taskId = 0, this.pendingTasks = new Set, this.hasPendingTasks = new Bn(!1) } get _hasPendingTasks() { return this.hasPendingTasks.value } add() { this._hasPendingTasks || this.hasPendingTasks.next(!0); let n = this.taskId++; return this.pendingTasks.add(n), n } remove(n) { this.pendingTasks.delete(n), this.pendingTasks.size === 0 && this._hasPendingTasks && this.hasPendingTasks.next(!1) } ngOnDestroy() { this.pendingTasks.clear(), this._hasPendingTasks && this.hasPendingTasks.next(!1) } static { this.\u0275prov = $({ token: t, providedIn: "root", factory: () => new t }) } } return t })(); var Rs = class extends _e { constructor(e = !1) { super(), this.destroyRef = void 0, this.pendingTasks = void 0, this.__isAsync = e, jd() && (this.destroyRef = R(tl, { optional: !0 }) ?? void 0, this.pendingTasks = R(Xo, { optional: !0 }) ?? void 0) } emit(e) { let n = A(null); try { super.next(e) } finally { A(n) } } subscribe(e, n, r) { let o = e, i = n || (() => null), s = r; if (e && typeof e == "object") { let l = e; o = l.next?.bind(l), i = l.error?.bind(l), s = l.complete?.bind(l) } this.__isAsync && (i = this.wrapInTimeout(i), o && (o = this.wrapInTimeout(o)), s && (s = this.wrapInTimeout(s))); let a = super.subscribe({ next: o, error: i, complete: s }); return e instanceof W && e.add(a), a } wrapInTimeout(e) { return n => { let r = this.pendingTasks?.add(); setTimeout(() => { e(n), r !== void 0 && this.pendingTasks?.remove(r) }) } } }, Oe = Rs; function Co(...t) { } function wf(t) { let e, n; function r() { t = Co; try { n !== void 0 && typeof cancelAnimationFrame == "function" && cancelAnimationFrame(n), e !== void 0 && clearTimeout(e) } catch { } } return e = setTimeout(() => { t(), r() }), typeof requestAnimationFrame == "function" && (n = requestAnimationFrame(() => { t(), r() })), () => r() } function Fc(t) { return queueMicrotask(() => t()), () => { t = Co } } var nl = "isAngularZone", So = nl + "_ID", nv = 0, ge = class t { constructor(e) { this.hasPendingMacrotasks = !1, this.hasPendingMicrotasks = !1, this.isStable = !0, this.onUnstable = new Oe(!1), this.onMicrotaskEmpty = new Oe(!1), this.onStable = new Oe(!1), this.onError = new Oe(!1); let { enableLongStackTrace: n = !1, shouldCoalesceEventChangeDetection: r = !1, shouldCoalesceRunChangeDetection: o = !1, scheduleInRootZone: i = Ef } = e; if (typeof Zone > "u") throw new g(908, !1); Zone.assertZonePatched(); let s = this; s._nesting = 0, s._outer = s._inner = Zone.current, Zone.TaskTrackingZoneSpec && (s._inner = s._inner.fork(new Zone.TaskTrackingZoneSpec)), n && Zone.longStackTraceZoneSpec && (s._inner = s._inner.fork(Zone.longStackTraceZoneSpec)), s.shouldCoalesceEventChangeDetection = !o && r, s.shouldCoalesceRunChangeDetection = o, s.callbackScheduled = !1, s.scheduleInRootZone = i, iv(s) } static isInAngularZone() { return typeof Zone < "u" && Zone.current.get(nl) === !0 } static assertInAngularZone() { if (!t.isInAngularZone()) throw new g(909, !1) } static assertNotInAngularZone() { if (t.isInAngularZone()) throw new g(909, !1) } run(e, n, r) { return this._inner.run(e, n, r) } runTask(e, n, r, o) { let i = this._inner, s = i.scheduleEventTask("NgZoneEvent: " + o, e, rv, Co, Co); try { return i.runTask(s, n, r) } finally { i.cancelTask(s) } } runGuarded(e, n, r) { return this._inner.runGuarded(e, n, r) } runOutsideAngular(e) { return this._outer.run(e) } }, rv = {}; function rl(t) { if (t._nesting == 0 && !t.hasPendingMicrotasks && !t.isStable) try { t._nesting++, t.onMicrotaskEmpty.emit(null) } finally { if (t._nesting--, !t.hasPendingMicrotasks) try { t.runOutsideAngular(() => t.onStable.emit(null)) } finally { t.isStable = !0 } } } function ov(t) { if (t.isCheckStableRunning || t.callbackScheduled) return; t.callbackScheduled = !0; function e() { wf(() => { t.callbackScheduled = !1, ks(t), t.isCheckStableRunning = !0, rl(t), t.isCheckStableRunning = !1 }) } t.scheduleInRootZone ? Zone.root.run(() => { e() }) : t._outer.run(() => { e() }), ks(t) } function iv(t) { let e = () => { ov(t) }, n = nv++; t._inner = t._inner.fork({ name: "angular", properties: { [nl]: !0, [So]: n, [So + n]: !0 }, onInvokeTask: (r, o, i, s, a, l) => { if (sv(l)) return r.invokeTask(i, s, a, l); try { return Rc(t), r.invokeTask(i, s, a, l) } finally { (t.shouldCoalesceEventChangeDetection && s.type === "eventTask" || t.shouldCoalesceRunChangeDetection) && e(), kc(t) } }, onInvoke: (r, o, i, s, a, l, u) => { try { return Rc(t), r.invoke(i, s, a, l, u) } finally { t.shouldCoalesceRunChangeDetection && !t.callbackScheduled && !av(l) && e(), kc(t) } }, onHasTask: (r, o, i, s) => { r.hasTask(i, s), o === i && (s.change == "microTask" ? (t._hasPendingMicrotasks = s.microTask, ks(t), rl(t)) : s.change == "macroTask" && (t.hasPendingMacrotasks = s.macroTask)) }, onHandleError: (r, o, i, s) => (r.handleError(i, s), t.runOutsideAngular(() => t.onError.emit(s)), !1) }) } function ks(t) { t._hasPendingMicrotasks || (t.shouldCoalesceEventChangeDetection || t.shouldCoalesceRunChangeDetection) && t.callbackScheduled === !0 ? t.hasPendingMicrotasks = !0 : t.hasPendingMicrotasks = !1 } function Rc(t) { t._nesting++, t.isStable && (t.isStable = !1, t.onUnstable.emit(null)) } function kc(t) { t._nesting--, rl(t) } var Ls = class { constructor() { this.hasPendingMicrotasks = !1, this.hasPendingMacrotasks = !1, this.isStable = !0, this.onUnstable = new Oe, this.onMicrotaskEmpty = new Oe, this.onStable = new Oe, this.onError = new Oe } run(e, n, r) { return e.apply(n, r) } runGuarded(e, n, r) { return e.apply(n, r) } runOutsideAngular(e) { return e() } runTask(e, n, r, o) { return e.apply(n, r) } }; function sv(t) { return _f(t, "__ignore_ng_zone__") } function av(t) { return _f(t, "__scheduler_tick__") } function _f(t, e) { return !Array.isArray(t) || t.length !== 1 ? !1 : t[0]?.data?.[e] === !0 } var _n = class { constructor() { this._console = console } handleError(e) { let n = this._findOriginalError(e); this._console.error("ERROR", e), n && this._console.error("ORIGINAL ERROR", n) } _findOriginalError(e) { let n = e && cs(e); for (; n && cs(n);)n = cs(n); return n || null } }, lv = new V("", { providedIn: "root", factory: () => { let t = R(ge), e = R(_n); return n => t.runOutsideAngular(() => e.handleError(n)) } }); function uv() { return An(J(), S()) } function An(t, e) { return new _t(be(t, e)) } var _t = (() => { class t { constructor(n) { this.nativeElement = n } static { this.__NG_ELEMENT_ID__ = uv } } return t })(); function cv(t) { return t instanceof _t ? t.nativeElement : t } function dv() { return this._results[Symbol.iterator]() } var js = class t { get changes() { return this._changes ??= new Oe } constructor(e = !1) { this._emitDistinctChangesOnly = e, this.dirty = !0, this._onDirty = void 0, this._results = [], this._changesDetected = !1, this._changes = void 0, this.length = 0, this.first = void 0, this.last = void 0; let n = t.prototype; n[Symbol.iterator] || (n[Symbol.iterator] = dv) } get(e) { return this._results[e] } map(e) { return this._results.map(e) } filter(e) { return this._results.filter(e) } find(e) { return this._results.find(e) } reduce(e, n) { return this._results.reduce(e, n) } forEach(e) { this._results.forEach(e) } some(e) { return this._results.some(e) } toArray() { return this._results.slice() } toString() { return this._results.toString() } reset(e, n) { this.dirty = !1; let r = Rg(e); (this._changesDetected = !Fg(this._results, r, n)) && (this._results = r, this.length = r.length, this.last = r[this.length - 1], this.first = r[0]) } notifyOnChanges() { this._changes !== void 0 && (this._changesDetected || !this._emitDistinctChangesOnly) && this._changes.emit(this) } onDirty(e) { this._onDirty = e } setDirty() { this.dirty = !0, this._onDirty?.() } destroy() { this._changes !== void 0 && (this._changes.complete(), this._changes.unsubscribe()) } }; function If(t) { return (t.flags & 128) === 128 } var bf = new Map, fv = 0; function hv() { return fv++ } function pv(t) { bf.set(t[qo], t) } function Vs(t) { bf.delete(t[qo]) } var Lc = "__ngContext__"; function vt(t, e) { ft(e) ? (t[Lc] = e[qo], pv(e)) : t[Lc] = e } function Cf(t) { return Mf(t[Xn]) } function Sf(t) { return Mf(t[Pe]) } function Mf(t) { for (; t !== null && !nt(t);)t = t[Pe]; return t } var Bs; function rO(t) { Bs = t } function Tf() { if (Bs !== void 0) return Bs; if (typeof document < "u") return document; throw new g(210, !1) } var oO = new V("", { providedIn: "root", factory: () => mv }), mv = "ng", gv = new V(""), Nf = new V("", { providedIn: "platform", factory: () => "unknown" }); var iO = new V(""), sO = new V("", { providedIn: "root", factory: () => Tf().body?.querySelector("[ngCspNonce]")?.getAttribute("ngCspNonce") || null }); var yv = "h", vv = "b"; var Dv = () => null; function ol(t, e, n = !1) { return Dv(t, e, n) } var xf = !1, Ev = new V("", { providedIn: "root", factory: () => xf }); var eo; function wv() { if (eo === void 0 && (eo = null, ct.trustedTypes)) try { eo = ct.trustedTypes.createPolicy("angular", { createHTML: t => t, createScript: t => t, createScriptURL: t => t }) } catch { } return eo } function ei(t) { return wv()?.createHTML(t) || t } var to; function Af() { if (to === void 0 && (to = null, ct.trustedTypes)) try { to = ct.trustedTypes.createPolicy("angular#unsafe-bypass", { createHTML: t => t, createScript: t => t, createScriptURL: t => t }) } catch { } return to } function jc(t) { return Af()?.createHTML(t) || t } function Vc(t) { return Af()?.createScriptURL(t) || t } var et = class { constructor(e) { this.changingThisBreaksApplicationSecurity = e } toString() { return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see ${ud})` } }, $s = class extends et { getTypeName() { return "HTML" } }, Hs = class extends et { getTypeName() { return "Style" } }, Us = class extends et { getTypeName() { return "Script" } }, zs = class extends et { getTypeName() { return "URL" } }, qs = class extends et { getTypeName() { return "ResourceURL" } }; function On(t) { return t instanceof et ? t.changingThisBreaksApplicationSecurity : t } function il(t, e) { let n = _v(t); if (n != null && n !== e) { if (n === "ResourceURL" && e === "URL") return !0; throw new Error(`Required a safe ${e}, got a ${n} (see ${ud})`) } return n === e } function _v(t) { return t instanceof et && t.getTypeName() || null } function aO(t) { return new $s(t) } function lO(t) { return new Hs(t) } function uO(t) { return new Us(t) } function cO(t) { return new zs(t) } function dO(t) { return new qs(t) } function Iv(t) { let e = new Ws(t); return bv() ? new Gs(e) : e } var Gs = class { constructor(e) { this.inertDocumentHelper = e } getInertBodyElement(e) { e = "<body><remove></remove>" + e; try { let n = new window.DOMParser().parseFromString(ei(e), "text/html").body; return n === null ? this.inertDocumentHelper.getInertBodyElement(e) : (n.firstChild?.remove(), n) } catch { return null } } }, Ws = class { constructor(e) { this.defaultDoc = e, this.inertDocument = this.defaultDoc.implementation.createHTMLDocument("sanitization-inert") } getInertBodyElement(e) { let n = this.inertDocument.createElement("template"); return n.innerHTML = ei(e), n } }; function bv() { try { return !!new window.DOMParser().parseFromString(ei(""), "text/html") } catch { return !1 } } var Cv = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:\/?#]*(?:[\/?#]|$))/i; function Of(t) { return t = String(t), t.match(Cv) ? t : "unsafe:" + t } function ot(t) { let e = {}; for (let n of t.split(",")) e[n] = !0; return e } function lr(...t) { let e = {}; for (let n of t) for (let r in n) n.hasOwnProperty(r) && (e[r] = !0); return e } var Pf = ot("area,br,col,hr,img,wbr"), Ff = ot("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"), Rf = ot("rp,rt"), Sv = lr(Rf, Ff), Mv = lr(Ff, ot("address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul")), Tv = lr(Rf, ot("a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video")), Bc = lr(Pf, Mv, Tv, Sv), kf = ot("background,cite,href,itemtype,longdesc,poster,src,xlink:href"), Nv = ot("abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,srcset,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width"), xv = ot("aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext"), Av = lr(kf, Nv, xv), Ov = ot("script,style,template"), Qs = class { constructor() { this.sanitizedSomething = !1, this.buf = [] } sanitizeChildren(e) { let n = e.firstChild, r = !0, o = []; for (; n;) { if (n.nodeType === Node.ELEMENT_NODE ? r = this.startElement(n) : n.nodeType === Node.TEXT_NODE ? this.chars(n.nodeValue) : this.sanitizedSomething = !0, r && n.firstChild) { o.push(n), n = Rv(n); continue } for (; n;) { n.nodeType === Node.ELEMENT_NODE && this.endElement(n); let i = Fv(n); if (i) { n = i; break } n = o.pop() } } return this.buf.join("") } startElement(e) { let n = $c(e).toLowerCase(); if (!Bc.hasOwnProperty(n)) return this.sanitizedSomething = !0, !Ov.hasOwnProperty(n); this.buf.push("<"), this.buf.push(n); let r = e.attributes; for (let o = 0; o < r.length; o++) { let i = r.item(o), s = i.name, a = s.toLowerCase(); if (!Av.hasOwnProperty(a)) { this.sanitizedSomething = !0; continue } let l = i.value; kf[a] && (l = Of(l)), this.buf.push(" ", s, '="', Hc(l), '"') } return this.buf.push(">"), !0 } endElement(e) { let n = $c(e).toLowerCase(); Bc.hasOwnProperty(n) && !Pf.hasOwnProperty(n) && (this.buf.push("</"), this.buf.push(n), this.buf.push(">")) } chars(e) { this.buf.push(Hc(e)) } }; function Pv(t, e) { return (t.compareDocumentPosition(e) & Node.DOCUMENT_POSITION_CONTAINED_BY) !== Node.DOCUMENT_POSITION_CONTAINED_BY } function Fv(t) { let e = t.nextSibling; if (e && t !== e.previousSibling) throw Lf(e); return e } function Rv(t) { let e = t.firstChild; if (e && Pv(t, e)) throw Lf(e); return e } function $c(t) { let e = t.nodeName; return typeof e == "string" ? e : "FORM" } function Lf(t) { return new Error(`Failed to sanitize html because the element is clobbered: ${t.outerHTML}`) } var kv = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, Lv = /([^\#-~ |!])/g; function Hc(t) { return t.replace(/&/g, "&amp;").replace(kv, function (e) { let n = e.charCodeAt(0), r = e.charCodeAt(1); return "&#" + ((n - 55296) * 1024 + (r - 56320) + 65536) + ";" }).replace(Lv, function (e) { return "&#" + e.charCodeAt(0) + ";" }).replace(/</g, "&lt;").replace(/>/g, "&gt;") } var no; function jv(t, e) { let n = null; try { no = no || Iv(t); let r = e ? String(e) : ""; n = no.getInertBodyElement(r); let o = 5, i = r; do { if (o === 0) throw new Error("Failed to sanitize html because the input is unstable"); o--, r = i, i = n.innerHTML, n = no.getInertBodyElement(r) } while (r !== i); let a = new Qs().sanitizeChildren(Uc(n) || n); return ei(a) } finally { if (n) { let r = Uc(n) || n; for (; r.firstChild;)r.firstChild.remove() } } } function Uc(t) { return "content" in t && Vv(t) ? t.content : null } function Vv(t) { return t.nodeType === Node.ELEMENT_NODE && t.nodeName === "TEMPLATE" } var ti = function (t) { return t[t.NONE = 0] = "NONE", t[t.HTML = 1] = "HTML", t[t.STYLE = 2] = "STYLE", t[t.SCRIPT = 3] = "SCRIPT", t[t.URL = 4] = "URL", t[t.RESOURCE_URL = 5] = "RESOURCE_URL", t }(ti || {}); function fO(t) { let e = sl(); return e ? jc(e.sanitize(ti.HTML, t) || "") : il(t, "HTML") ? jc(On(t)) : jv(Tf(), jt(t)) } function Bv(t) { let e = sl(); return e ? e.sanitize(ti.URL, t) || "" : il(t, "URL") ? On(t) : Of(jt(t)) } function $v(t) { let e = sl(); if (e) return Vc(e.sanitize(ti.RESOURCE_URL, t) || ""); if (il(t, "ResourceURL")) return Vc(On(t)); throw new g(904, !1) } function Hv(t, e) { return e === "src" && (t === "embed" || t === "frame" || t === "iframe" || t === "media" || t === "script") || e === "href" && (t === "base" || t === "link") ? $v : Bv } function hO(t, e, n) { return Hv(e, n)(t) } function sl() { let t = S(); return t && t[$e].sanitizer } var Uv = /^>|^->|<!--|-->|--!>|<!-$/g, zv = /(<|>)/g, qv = "\u200B$1\u200B"; function Gv(t) { return t.replace(Uv, e => e.replace(zv, qv)) } function jf(t) { return t instanceof Function ? t() : t } function Vf(t) { return (t ?? R(yt)).get(Nf) === "browser" } var er = function (t) { return t[t.Important = 1] = "Important", t[t.DashCase = 2] = "DashCase", t }(er || {}), Wv; function al(t, e) { return Wv(t, e) } function pn(t, e, n, r, o) { if (r != null) { let i, s = !1; nt(r) ? i = r : ft(r) && (s = !0, r = r[Ue]); let a = He(r); t === 0 && n !== null ? o == null ? zf(e, n, a) : Mo(e, n, a, o || null, !0) : t === 1 && n !== null ? Mo(e, n, a, o || null, !0) : t === 2 ? aD(e, a, s) : t === 3 && e.destroyNode(a), i != null && uD(e, t, i, n, o) } } function Qv(t, e) { return t.createText(e) } function Zv(t, e, n) { t.setValue(e, n) } function Kv(t, e) { return t.createComment(Gv(e)) } function Bf(t, e, n) { return t.createElement(e, n) } function Yv(t, e) { $f(t, e), e[Ue] = null, e[he] = null } function Jv(t, e, n, r, o, i) { r[Ue] = o, r[he] = e, oi(t, r, n, 1, o, i) } function $f(t, e) { e[$e].changeDetectionScheduler?.notify(9), oi(t, e, e[z], 2, null, null) } function Xv(t) { let e = t[Xn]; if (!e) return ds(t[T], t); for (; e;) { let n = null; if (ft(e)) n = e[Xn]; else { let r = e[ie]; r && (n = r) } if (!n) { for (; e && !e[Pe] && e !== t;)ft(e) && ds(e[T], e), e = e[se]; e === null && (e = t), ft(e) && ds(e[T], e), n = e && e[Pe] } e = n } } function eD(t, e, n, r) { let o = ie + r, i = n.length; r > 0 && (n[o - 1][Pe] = e), r < i - ie ? (e[Pe] = n[o], wd(n, ie + r, e)) : (n.push(e), e[Pe] = null), e[se] = n; let s = e[Bt]; s !== null && n !== s && Hf(s, e); let a = e[Je]; a !== null && a.insertView(t), Ts(e), e[M] |= 128 } function Hf(t, e) { let n = t[wn], r = e[se]; if (ft(r)) t[M] |= Eo.HasTransplantedViews; else { let o = r[se][fe]; e[fe] !== o && (t[M] |= Eo.HasTransplantedViews) } n === null ? t[wn] = [e] : n.push(e) } function ll(t, e) { let n = t[wn], r = n.indexOf(e); n.splice(r, 1) } function tr(t, e) { if (t.length <= ie) return; let n = ie + e, r = t[n]; if (r) { let o = r[Bt]; o !== null && o !== t && ll(o, r), e > 0 && (t[n - 1][Pe] = r[Pe]); let i = mo(t, ie + e); Yv(r[T], r); let s = i[Je]; s !== null && s.detachView(i[T]), r[se] = null, r[Pe] = null, r[M] &= -129 } return r } function ni(t, e) { if (!(e[M] & 256)) { let n = e[z]; n.destroyNode && oi(t, e, n, 3, null, null), Xv(e) } } function ds(t, e) { if (e[M] & 256) return; let n = A(null); try { e[M] &= -129, e[M] |= 256, e[Ie] && Li(e[Ie]), nD(t, e), tD(t, e), e[T].type === 1 && e[z].destroy(); let r = e[Bt]; if (r !== null && nt(e[se])) { r !== e[se] && ll(r, e); let o = e[Je]; o !== null && o.detachView(t) } Vs(e) } finally { A(n) } } function tD(t, e) { let n = t.cleanup, r = e[vo]; if (n !== null) for (let i = 0; i < n.length - 1; i += 2)if (typeof n[i] == "string") { let s = n[i + 3]; s >= 0 ? r[s]() : r[-s].unsubscribe(), i += 2 } else { let s = r[n[i + 1]]; n[i].call(s) } r !== null && (e[vo] = null); let o = e[dt]; if (o !== null) { e[dt] = null; for (let i = 0; i < o.length; i++) { let s = o[i]; s() } } } function nD(t, e) { let n; if (t != null && (n = t.destroyHooks) != null) for (let r = 0; r < n.length; r += 2) { let o = e[n[r]]; if (!(o instanceof zt)) { let i = n[r + 1]; if (Array.isArray(i)) for (let s = 0; s < i.length; s += 2) { let a = o[i[s]], l = i[s + 1]; Ve(4, a, l); try { l.call(a) } finally { Ve(5, a, l) } } else { Ve(4, o, i); try { i.call(o) } finally { Ve(5, o, i) } } } } } function Uf(t, e, n) { return rD(t, e.parent, n) } function rD(t, e, n) { let r = e; for (; r !== null && r.type & 168;)e = r, r = e.parent; if (r === null) return n[Ue]; { let { componentOffset: o } = r; if (o > -1) { let { encapsulation: i } = t.data[r.directiveStart + o]; if (i === Kn.None || i === Kn.Emulated) return null } return be(r, n) } } function Mo(t, e, n, r, o) { t.insertBefore(e, n, r, o) } function zf(t, e, n) { t.appendChild(e, n) } function zc(t, e, n, r, o) { r !== null ? Mo(t, e, n, r, o) : zf(t, e, n) } function qf(t, e) { return t.parentNode(e) } function oD(t, e) { return t.nextSibling(e) } function Gf(t, e, n) { return sD(t, e, n) } function iD(t, e, n) { return t.type & 40 ? be(t, n) : null } var sD = iD, qc; function ri(t, e, n, r) { let o = Uf(t, r, e), i = e[z], s = r.parent || e[he], a = Gf(s, r, e); if (o != null) if (Array.isArray(n)) for (let l = 0; l < n.length; l++)zc(i, o, n[l], a, !1); else zc(i, o, n, a, !1); qc !== void 0 && qc(i, r, e, n, o) } function Gn(t, e) { if (e !== null) { let n = e.type; if (n & 3) return be(e, t); if (n & 4) return Zs(-1, t[e.index]); if (n & 8) { let r = e.child; if (r !== null) return Gn(t, r); { let o = t[e.index]; return nt(o) ? Zs(-1, o) : He(o) } } else { if (n & 128) return Gn(t, e.next); if (n & 32) return al(e, t)() || He(t[e.index]); { let r = Wf(t, e); if (r !== null) { if (Array.isArray(r)) return r[0]; let o = Ht(t[fe]); return Gn(o, r) } else return Gn(t, e.next) } } } return null } function Wf(t, e) { if (e !== null) { let r = t[fe][he], o = e.projection; return r.projection[o] } return null } function Zs(t, e) { let n = ie + t + 1; if (n < e.length) { let r = e[n], o = r[T].firstChild; if (o !== null) return Gn(r, o) } return e[$t] } function aD(t, e, n) { t.removeChild(null, e, n) } function ul(t, e, n, r, o, i, s) { for (; n != null;) { if (n.type === 128) { n = n.next; continue } let a = r[n.index], l = n.type; if (s && e === 0 && (a && vt(He(a), r), n.flags |= 2), (n.flags & 32) !== 32) if (l & 8) ul(t, e, n.child, r, o, i, !1), pn(e, t, o, a, i); else if (l & 32) { let u = al(n, r), c; for (; c = u();)pn(e, t, o, c, i); pn(e, t, o, a, i) } else l & 16 ? Qf(t, e, r, n, o, i) : pn(e, t, o, a, i); n = s ? n.projectionNext : n.next } } function oi(t, e, n, r, o, i) { ul(n, r, t.firstChild, e, o, i, !1) } function lD(t, e, n) { let r = e[z], o = Uf(t, n, e), i = n.parent || e[he], s = Gf(i, n, e); Qf(r, 0, e, n, o, s) } function Qf(t, e, n, r, o, i) { let s = n[fe], l = s[he].projection[r.projection]; if (Array.isArray(l)) for (let u = 0; u < l.length; u++) { let c = l[u]; pn(e, t, o, c, i) } else { let u = l, c = s[se]; If(r) && (u.flags |= 128), ul(t, e, u, c, o, i, !0) } } function uD(t, e, n, r, o) { let i = n[$t], s = He(n); i !== s && pn(e, t, r, i, o); for (let a = ie; a < n.length; a++) { let l = n[a]; oi(l[T], l, t, e, r, i) } } function cD(t, e, n, r, o) { if (e) o ? t.addClass(n, r) : t.removeClass(n, r); else { let i = r.indexOf("-") === -1 ? void 0 : er.DashCase; o == null ? t.removeStyle(n, r, i) : (typeof o == "string" && o.endsWith("!important") && (o = o.slice(0, -10), i |= er.Important), t.setStyle(n, r, o, i)) } } function dD(t, e, n) { t.setAttribute(e, "style", n) } function Zf(t, e, n) { n === "" ? t.removeAttribute(e, "class") : t.setAttribute(e, "class", n) } function Kf(t, e, n) { let { mergedAttrs: r, classes: o, styles: i } = n; r !== null && _s(t, e, r), o !== null && Zf(t, e, o), i !== null && dD(t, e, i) } var ve = {}; function pO(t = 1) { Yf(H(), S(), rt() + t, !1) } function Yf(t, e, n, r) { if (!r) if ((e[M] & 3) === 3) { let i = t.preOrderCheckHooks; i !== null && ao(e, i, n) } else { let i = t.preOrderHooks; i !== null && lo(e, i, 0, n) } Ut(n) } function ne(t, e = O.Default) { let n = S(); if (n === null) return de(t, e); let r = J(); return gf(r, n, ee(t), e) } function mO() { let t = "invalid"; throw new Error(t) } function Jf(t, e, n, r, o, i) { let s = A(null); try { let a = null; o & ht.SignalBased && (a = e[r][Qe]), a !== null && a.transformFn !== void 0 && (i = a.transformFn(i)), o & ht.HasDecoratorInputTransform && (i = t.inputTransforms[r].call(e, i)), t.setInput !== null ? t.setInput(e, a, i, n, r) : $d(e, a, r, i) } finally { A(s) } } function fD(t, e) { let n = t.hostBindingOpCodes; if (n !== null) try { for (let r = 0; r < n.length; r++) { let o = n[r]; if (o < 0) Ut(~o); else { let i = o, s = n[++r], a = n[++r]; Py(s, i); let l = e[i]; a(2, l) } } } finally { Ut(-1) } } function ii(t, e, n, r, o, i, s, a, l, u, c) { let d = e.blueprint.slice(); return d[Ue] = o, d[M] = r | 4 | 128 | 8 | 64, (u !== null || t && t[M] & 2048) && (d[M] |= 2048), Wd(d), d[se] = d[xn] = t, d[te] = n, d[$e] = s || t && t[$e], d[z] = a || t && t[z], d[En] = l || t && t[En] || null, d[he] = i, d[qo] = hv(), d[Dn] = c, d[Bd] = u, d[fe] = e.type == 2 ? t[fe] : d, d } function Pn(t, e, n, r, o) { let i = t.data[e]; if (i === null) i = hD(t, e, n, r, o), Oy() && (i.flags |= 32); else if (i.type & 64) { i.type = n, i.value = r, i.attrs = o; let s = Ty(); i.injectorIndex = s === null ? -1 : s.injectorIndex } return Qt(i, !0), i } function hD(t, e, n, r, o) { let i = Xd(), s = Wa(), a = s ? i : i && i.parent, l = t.data[e] = DD(t, a, n, e, r, o); return t.firstChild === null && (t.firstChild = l), i !== null && (s ? i.child == null && l.parent !== null && (i.child = l) : i.next === null && (i.next = l, l.prev = i)), l } function Xf(t, e, n, r) { if (n === 0) return -1; let o = e.length; for (let i = 0; i < n; i++)e.push(r), t.blueprint.push(r), t.data.push(null); return o } function eh(t, e, n, r, o) { let i = rt(), s = r & 2; try { Ut(-1), s && e.length > Y && Yf(t, e, Y, !1), Ve(s ? 2 : 0, o), n(r, o) } finally { Ut(i), Ve(s ? 3 : 1, o) } } function cl(t, e, n) { if (Ha(e)) { let r = A(null); try { let o = e.directiveStart, i = e.directiveEnd; for (let s = o; s < i; s++) { let a = t.data[s]; if (a.contentQueries) { let l = n[s]; a.contentQueries(1, l, s) } } } finally { A(r) } } } function dl(t, e, n) { Yd() && (CD(t, e, n, be(n, e)), (n.flags & 64) === 64 && rh(t, e, n)) } function fl(t, e, n = be) { let r = e.localNames; if (r !== null) { let o = e.index + 1; for (let i = 0; i < r.length; i += 2) { let s = r[i + 1], a = s === -1 ? n(e, t) : t[s]; t[o++] = a } } } function th(t) { let e = t.tView; return e === null || e.incompleteFirstPass ? t.tView = hl(1, null, t.template, t.decls, t.vars, t.directiveDefs, t.pipeDefs, t.viewQuery, t.schemas, t.consts, t.id) : e } function hl(t, e, n, r, o, i, s, a, l, u, c) { let d = Y + r, h = d + o, f = pD(d, h), p = typeof u == "function" ? u() : u; return f[T] = { type: t, blueprint: f, template: n, queries: null, viewQuery: a, declTNode: e, data: f.slice().fill(null, d), bindingStartIndex: d, expandoStartIndex: h, hostBindingOpCodes: null, firstCreatePass: !0, firstUpdatePass: !0, staticViewQueries: !1, staticContentQueries: !1, preOrderHooks: null, preOrderCheckHooks: null, contentHooks: null, contentCheckHooks: null, viewHooks: null, viewCheckHooks: null, destroyHooks: null, cleanup: null, contentQueries: null, components: null, directiveRegistry: typeof i == "function" ? i() : i, pipeRegistry: typeof s == "function" ? s() : s, firstChild: null, schemas: l, consts: p, incompleteFirstPass: !1, ssrId: c } } function pD(t, e) { let n = []; for (let r = 0; r < e; r++)n.push(r < t ? null : ve); return n } function mD(t, e, n, r) { let i = r.get(Ev, xf) || n === Kn.ShadowDom, s = t.selectRootElement(e, i); return gD(s), s } function gD(t) { yD(t) } var yD = () => null; function vD(t, e, n, r) { let o = sh(e); o.push(n), t.firstCreatePass && ah(t).push(r, o.length - 1) } function DD(t, e, n, r, o, i) { let s = e ? e.injectorIndex : -1, a = 0; return Jd() && (a |= 128), { type: n, index: r, insertBeforeIndex: null, injectorIndex: s, directiveStart: -1, directiveEnd: -1, directiveStylingLast: -1, componentOffset: -1, propertyBindings: null, flags: a, providerIndexes: 0, value: o, attrs: i, mergedAttrs: null, localNames: null, initialInputs: void 0, inputs: null, outputs: null, tView: null, next: null, prev: null, projectionNext: null, child: null, parent: e, projection: null, styles: null, stylesWithoutHost: null, residualStyles: void 0, classes: null, classesWithoutHost: null, residualClasses: void 0, classBindings: 0, styleBindings: 0 } } function Gc(t, e, n, r, o) { for (let i in e) { if (!e.hasOwnProperty(i)) continue; let s = e[i]; if (s === void 0) continue; r ??= {}; let a, l = ht.None; Array.isArray(s) ? (a = s[0], l = s[1]) : a = s; let u = i; if (o !== null) { if (!o.hasOwnProperty(i)) continue; u = o[i] } t === 0 ? Wc(r, n, u, a, l) : Wc(r, n, u, a) } return r } function Wc(t, e, n, r, o) { let i; t.hasOwnProperty(n) ? (i = t[n]).push(e, r) : i = t[n] = [e, r], o !== void 0 && i.push(o) } function ED(t, e, n) { let r = e.directiveStart, o = e.directiveEnd, i = t.data, s = e.attrs, a = [], l = null, u = null; for (let c = r; c < o; c++) { let d = i[c], h = n ? n.get(d) : null, f = h ? h.inputs : null, p = h ? h.outputs : null; l = Gc(0, d.inputs, c, l, f), u = Gc(1, d.outputs, c, u, p); let m = l !== null && s !== null && !ja(e) ? kD(l, c, s) : null; a.push(m) } l !== null && (l.hasOwnProperty("class") && (e.flags |= 8), l.hasOwnProperty("style") && (e.flags |= 16)), e.initialInputs = a, e.inputs = l, e.outputs = u } function wD(t) { return t === "class" ? "className" : t === "for" ? "htmlFor" : t === "formaction" ? "formAction" : t === "innerHtml" ? "innerHTML" : t === "readonly" ? "readOnly" : t === "tabindex" ? "tabIndex" : t } function si(t, e, n, r, o, i, s, a) { let l = be(e, n), u = e.inputs, c; !a && u != null && (c = u[r]) ? (ml(t, n, c, r, o), Go(e) && _D(n, e.index)) : e.type & 3 ? (r = wD(r), o = s != null ? s(o, e.value || "", r) : o, i.setProperty(l, r, o)) : e.type & 12 } function _D(t, e) { let n = Et(e, t); n[M] & 16 || (n[M] |= 64) } function pl(t, e, n, r) { if (Yd()) { let o = r === null ? null : { "": -1 }, i = MD(t, n), s, a; i === null ? s = a = null : [s, a] = i, s !== null && nh(t, e, n, s, o, a), o && TD(n, r, o) } n.mergedAttrs = Yn(n.mergedAttrs, n.attrs) } function nh(t, e, n, r, o, i) { for (let u = 0; u < r.length; u++)Os(bo(n, e), t, r[u].type); xD(n, t.data.length, r.length); for (let u = 0; u < r.length; u++) { let c = r[u]; c.providersResolver && c.providersResolver(c) } let s = !1, a = !1, l = Xf(t, e, r.length, null); for (let u = 0; u < r.length; u++) { let c = r[u]; n.mergedAttrs = Yn(n.mergedAttrs, c.hostAttrs), AD(t, n, e, l, c), ND(l, c, o), c.contentQueries !== null && (n.flags |= 4), (c.hostBindings !== null || c.hostAttrs !== null || c.hostVars !== 0) && (n.flags |= 64); let d = c.type.prototype; !s && (d.ngOnChanges || d.ngOnInit || d.ngDoCheck) && ((t.preOrderHooks ??= []).push(n.index), s = !0), !a && (d.ngOnChanges || d.ngDoCheck) && ((t.preOrderCheckHooks ??= []).push(n.index), a = !0), l++ } ED(t, n, i) } function ID(t, e, n, r, o) { let i = o.hostBindings; if (i) { let s = t.hostBindingOpCodes; s === null && (s = t.hostBindingOpCodes = []); let a = ~e.index; bD(s) != a && s.push(a), s.push(n, r, i) } } function bD(t) { let e = t.length; for (; e > 0;) { let n = t[--e]; if (typeof n == "number" && n < 0) return n } return 0 } function CD(t, e, n, r) { let o = n.directiveStart, i = n.directiveEnd; Go(n) && OD(e, n, t.data[o + n.componentOffset]), t.firstCreatePass || bo(n, e), vt(r, e); let s = n.initialInputs; for (let a = o; a < i; a++) { let l = t.data[a], u = qt(e, t, a, n); if (vt(u, e), s !== null && RD(e, a - o, u, l, n, s), Xe(l)) { let c = Et(n.index, e); c[te] = qt(e, t, a, n) } } } function rh(t, e, n) { let r = n.directiveStart, o = n.directiveEnd, i = n.index, s = Fy(); try { Ut(i); for (let a = r; a < o; a++) { let l = t.data[a], u = e[a]; Ns(a), (l.hostBindings !== null || l.hostVars !== 0 || l.hostAttrs !== null) && SD(l, u) } } finally { Ut(-1), Ns(s) } } function SD(t, e) { t.hostBindings !== null && t.hostBindings(1, e) } function MD(t, e) { let n = t.directiveRegistry, r = null, o = null; if (n) for (let i = 0; i < n.length; i++) { let s = n[i]; if (Md(e, s.selectors, !1)) if (r || (r = []), Xe(s)) if (s.findHostDirectiveDefs !== null) { let a = []; o = o || new Map, s.findHostDirectiveDefs(s, a, o), r.unshift(...a, s); let l = a.length; Ks(t, e, l) } else r.unshift(s), Ks(t, e, 0); else o = o || new Map, s.findHostDirectiveDefs?.(s, r, o), r.push(s) } return r === null ? null : [r, o] } function Ks(t, e, n) { e.componentOffset = n, (t.components ??= []).push(e.index) } function TD(t, e, n) { if (e) { let r = t.localNames = []; for (let o = 0; o < e.length; o += 2) { let i = n[e[o + 1]]; if (i == null) throw new g(-301, !1); r.push(e[o], i) } } } function ND(t, e, n) { if (n) { if (e.exportAs) for (let r = 0; r < e.exportAs.length; r++)n[e.exportAs[r]] = t; Xe(e) && (n[""] = t) } } function xD(t, e, n) { t.flags |= 1, t.directiveStart = e, t.directiveEnd = e + n, t.providerIndexes = e } function AD(t, e, n, r, o) { t.data[r] = o; let i = o.factory || (o.factory = Vt(o.type, !0)), s = new zt(i, Xe(o), ne); t.blueprint[r] = s, n[r] = s, ID(t, e, r, Xf(t, n, o.hostVars, ve), o) } function OD(t, e, n) { let r = be(e, t), o = th(n), i = t[$e].rendererFactory, s = 16; n.signals ? s = 4096 : n.onPush && (s = 64); let a = ai(t, ii(t, o, null, s, r, e, null, i.createRenderer(r, n), null, null, null)); t[e.index] = a } function PD(t, e, n, r, o, i) { let s = be(t, e); FD(e[z], s, i, t.value, n, r, o) } function FD(t, e, n, r, o, i, s) { if (i == null) t.removeAttribute(e, o, n); else { let a = s == null ? jt(i) : s(i, r || "", o); t.setAttribute(e, o, a, n) } } function RD(t, e, n, r, o, i) { let s = i[e]; if (s !== null) for (let a = 0; a < s.length;) { let l = s[a++], u = s[a++], c = s[a++], d = s[a++]; Jf(r, n, l, u, c, d) } } function kD(t, e, n) { let r = null, o = 0; for (; o < n.length;) { let i = n[o]; if (i === 0) { o += 4; continue } else if (i === 5) { o += 2; continue } if (typeof i == "number") break; if (t.hasOwnProperty(i)) { r === null && (r = []); let s = t[i]; for (let a = 0; a < s.length; a += 3)if (s[a] === e) { r.push(i, s[a + 1], s[a + 2], n[o + 1]); break } } o += 2 } return r } function oh(t, e, n, r) { return [t, !0, 0, e, null, r, null, n, null, null] } function ih(t, e) { let n = t.contentQueries; if (n !== null) { let r = A(null); try { for (let o = 0; o < n.length; o += 2) { let i = n[o], s = n[o + 1]; if (s !== -1) { let a = t.data[s]; Ya(i), a.contentQueries(2, e[s], s) } } } finally { A(r) } } } function ai(t, e) { return t[Xn] ? t[Mc][Pe] = e : t[Xn] = e, t[Mc] = e, e } function Ys(t, e, n) { Ya(0); let r = A(null); try { e(t, n) } finally { A(r) } } function sh(t) { return t[vo] ??= [] } function ah(t) { return t.cleanup ??= [] } function lh(t, e, n) { return (t === null || Xe(t)) && (n = vy(n[e.index])), n[z] } function uh(t, e) { let n = t[En], r = n ? n.get(_n, null) : null; r && r.handleError(e) } function ml(t, e, n, r, o) { for (let i = 0; i < n.length;) { let s = n[i++], a = n[i++], l = n[i++], u = e[s], c = t.data[s]; Jf(c, u, r, a, l, o) } } function ch(t, e, n) { let r = Gd(e, t); Zv(t[z], r, n) } function LD(t, e) { let n = Et(e, t), r = n[T]; jD(r, n); let o = n[Ue]; o !== null && n[Dn] === null && (n[Dn] = ol(o, n[En])), gl(r, n, n[te]) } function jD(t, e) { for (let n = e.length; n < t.blueprint.length; n++)e.push(t.blueprint[n]) } function gl(t, e, n) { Ja(e); try { let r = t.viewQuery; r !== null && Ys(1, r, n); let o = t.template; o !== null && eh(t, e, o, 1, n), t.firstCreatePass && (t.firstCreatePass = !1), e[Je]?.finishViewCreation(t), t.staticContentQueries && ih(t, e), t.staticViewQueries && Ys(2, t.viewQuery, n); let i = t.components; i !== null && VD(e, i) } catch (r) { throw t.firstCreatePass && (t.incompleteFirstPass = !0, t.firstCreatePass = !1), r } finally { e[M] &= -5, Xa() } } function VD(t, e) { for (let n = 0; n < e.length; n++)LD(t, e[n]) } function ur(t, e, n, r) { let o = A(null); try { let i = e.tView, a = t[M] & 4096 ? 4096 : 16, l = ii(t, i, n, a, null, e, null, null, r?.injector ?? null, r?.embeddedViewInjector ?? null, r?.dehydratedView ?? null), u = t[e.index]; l[Bt] = u; let c = t[Je]; return c !== null && (l[Je] = c.createEmbeddedView(i)), gl(i, l, n), l } finally { A(o) } } function dh(t, e) { let n = ie + e; if (n < t.length) return t[n] } function In(t, e) { return !e || e.firstChild === null || If(t) } function cr(t, e, n, r = !0) { let o = e[T]; if (eD(o, e, t, n), r) { let s = Zs(n, t), a = e[z], l = qf(a, t[$t]); l !== null && Jv(o, t[he], a, e, l, s) } let i = e[Dn]; i !== null && i.firstChild !== null && (i.firstChild = null) } function fh(t, e) { let n = tr(t, e); return n !== void 0 && ni(n[T], n), n } function To(t, e, n, r, o = !1) { for (; n !== null;) { if (n.type === 128) { n = o ? n.projectionNext : n.next; continue } let i = e[n.index]; i !== null && r.push(He(i)), nt(i) && BD(i, r); let s = n.type; if (s & 8) To(t, e, n.child, r); else if (s & 32) { let a = al(n, e), l; for (; l = a();)r.push(l) } else if (s & 16) { let a = Wf(e, n); if (Array.isArray(a)) r.push(...a); else { let l = Ht(e[fe]); To(l[T], l, a, r, !0) } } n = o ? n.projectionNext : n.next } return r } function BD(t, e) { for (let n = ie; n < t.length; n++) { let r = t[n], o = r[T].firstChild; o !== null && To(r[T], r, o, e) } t[$t] !== t[Ue] && e.push(t[$t]) } var hh = []; function $D(t) { return t[Ie] ?? HD(t) } function HD(t) { let e = hh.pop() ?? Object.create(zD); return e.lView = t, e } function UD(t) { t.lView[Ie] !== t && (t.lView = null, hh.push(t)) } var zD = We(me({}, Vn), { consumerIsAlwaysLive: !0, consumerMarkedDirty: t => { Zo(t.lView) }, consumerOnSignalRead() { this.lView[Ie] = this } }); function qD(t) { let e = t[Ie] ?? Object.create(GD); return e.lView = t, e } var GD = We(me({}, Vn), { consumerIsAlwaysLive: !0, consumerMarkedDirty: t => { let e = Ht(t.lView); for (; e && !ph(e[T]);)e = Ht(e); e && Qd(e) }, consumerOnSignalRead() { this.lView[Ie] = this } }); function ph(t) { return t.type !== 2 } var WD = 100; function mh(t, e = !0, n = 0) { let r = t[$e], o = r.rendererFactory, i = !1; i || o.begin?.(); try { QD(t, n) } catch (s) { throw e && uh(t, s), s } finally { i || (o.end?.(), r.inlineEffectRunner?.flush()) } } function QD(t, e) { let n = ef(); try { Nc(!0), Js(t, e); let r = 0; for (; Qo(t);) { if (r === WD) throw new g(103, !1); r++, Js(t, 1) } } finally { Nc(n) } } function ZD(t, e, n, r) { let o = e[M]; if ((o & 256) === 256) return; let i = !1, s = !1; !i && e[$e].inlineEffectRunner?.flush(), Ja(e); let a = !0, l = null, u = null; i || (ph(t) ? (u = $D(e), l = br(u)) : Su() === null ? (a = !1, u = qD(e), l = br(u)) : e[Ie] && (Li(e[Ie]), e[Ie] = null)); try { Wd(e), Ay(t.bindingStartIndex), n !== null && eh(t, e, n, 2, r); let c = (o & 3) === 3; if (!i) if (c) { let f = t.preOrderCheckHooks; f !== null && ao(e, f, null) } else { let f = t.preOrderHooks; f !== null && lo(e, f, 0, null), as(e, 0) } if (s || KD(e), gh(e, 0), t.contentQueries !== null && ih(t, e), !i) if (c) { let f = t.contentCheckHooks; f !== null && ao(e, f) } else { let f = t.contentHooks; f !== null && lo(e, f, 1), as(e, 1) } fD(t, e); let d = t.components; d !== null && vh(e, d, 0); let h = t.viewQuery; if (h !== null && Ys(2, h, r), !i) if (c) { let f = t.viewCheckHooks; f !== null && ao(e, f) } else { let f = t.viewHooks; f !== null && lo(e, f, 2), as(e, 2) } if (t.firstUpdatePass === !0 && (t.firstUpdatePass = !1), e[ss]) { for (let f of e[ss]) f(); e[ss] = null } i || (e[M] &= -73) } catch (c) { throw i || Zo(e), c } finally { u !== null && (Ri(u, l), a && UD(u)), Xa() } } function gh(t, e) { for (let n = Cf(t); n !== null; n = Sf(n))for (let r = ie; r < n.length; r++) { let o = n[r]; yh(o, e) } } function KD(t) { for (let e = Cf(t); e !== null; e = Sf(e)) { if (!(e[M] & Eo.HasTransplantedViews)) continue; let n = e[wn]; for (let r = 0; r < n.length; r++) { let o = n[r]; Qd(o) } } } function YD(t, e, n) { let r = Et(e, t); yh(r, n) } function yh(t, e) { Ga(t) && Js(t, e) } function Js(t, e) { let r = t[T], o = t[M], i = t[Ie], s = !!(e === 0 && o & 16); if (s ||= !!(o & 64 && e === 0), s ||= !!(o & 1024), s ||= !!(i?.dirty && ki(i)), s ||= !1, i && (i.dirty = !1), t[M] &= -9217, s) ZD(r, t, r.template, t[te]); else if (o & 8192) { gh(t, 1); let a = r.components; a !== null && vh(t, a, 1) } } function vh(t, e, n) { for (let r = 0; r < e.length; r++)YD(t, e[r], n) } function yl(t, e) { let n = ef() ? 64 : 1088; for (t[$e].changeDetectionScheduler?.notify(e); t;) { t[M] |= n; let r = Ht(t); if (Ss(t) && !r) return t; t = r } return null } var Gt = class { get rootNodes() { let e = this._lView, n = e[T]; return To(n, e, n.firstChild, []) } constructor(e, n, r = !0) { this._lView = e, this._cdRefInjectingView = n, this.notifyErrorHandler = r, this._appRef = null, this._attachedToViewContainer = !1 } get context() { return this._lView[te] } set context(e) { this._lView[te] = e } get destroyed() { return (this._lView[M] & 256) === 256 } destroy() { if (this._appRef) this._appRef.detachView(this); else if (this._attachedToViewContainer) { let e = this._lView[se]; if (nt(e)) { let n = e[Do], r = n ? n.indexOf(this) : -1; r > -1 && (tr(e, r), mo(n, r)) } this._attachedToViewContainer = !1 } ni(this._lView[T], this._lView) } onDestroy(e) { Zd(this._lView, e) } markForCheck() { yl(this._cdRefInjectingView || this._lView, 4) } detach() { this._lView[M] &= -129 } reattach() { Ts(this._lView), this._lView[M] |= 128 } detectChanges() { this._lView[M] |= 1024, mh(this._lView, this.notifyErrorHandler) } checkNoChanges() { } attachToViewContainerRef() { if (this._appRef) throw new g(902, !1); this._attachedToViewContainer = !0 } detachFromAppRef() { this._appRef = null; let e = Ss(this._lView), n = this._lView[Bt]; n !== null && !e && ll(n, this._lView), $f(this._lView[T], this._lView) } attachToAppRef(e) { if (this._attachedToViewContainer) throw new g(902, !1); this._appRef = e; let n = Ss(this._lView), r = this._lView[Bt]; r !== null && !n && Hf(r, this._lView), Ts(this._lView) } }, bn = (() => { class t { static { this.__NG_ELEMENT_ID__ = eE } } return t })(), JD = bn, XD = class extends JD { constructor(e, n, r) { super(), this._declarationLView = e, this._declarationTContainer = n, this.elementRef = r } get ssrId() { return this._declarationTContainer.tView?.ssrId || null } createEmbeddedView(e, n) { return this.createEmbeddedViewImpl(e, n) } createEmbeddedViewImpl(e, n, r) { let o = ur(this._declarationLView, this._declarationTContainer, e, { embeddedViewInjector: n, dehydratedView: r }); return new Gt(o) } }; function eE() { return li(J(), S()) } function li(t, e) { return t.type & 4 ? new XD(e, t, An(t, e)) : null } var yO = new RegExp(`^(\\d+)*(${vv}|${yv})*(.*)`); var tE = () => null; function Cn(t, e) { return tE(t, e) } var Sn = class { }, Dh = new V("", { providedIn: "root", factory: () => !1 }); var Eh = new V(""), wh = new V(""), Xs = class { }, No = class { }; function nE(t) { let e = Error(`No component factory found for ${ae(t)}.`); return e[rE] = t, e } var rE = "ngComponent"; var ea = class { resolveComponentFactory(e) { throw nE(e) } }, Mn = class { static { this.NULL = new ea } }, xo = class { }, ui = (() => { class t { constructor() { this.destroyNode = null } static { this.__NG_ELEMENT_ID__ = () => oE() } } return t })(); function oE() { let t = S(), e = J(), n = Et(e.index, t); return (ft(n) ? n : t)[z] } var iE = (() => { class t { static { this.\u0275prov = $({ token: t, providedIn: "root", factory: () => null }) } } return t })(); function Ao(t, e, n) { let r = n ? t.styles : null, o = n ? t.classes : null, i = 0; if (e !== null) for (let s = 0; s < e.length; s++) { let a = e[s]; if (typeof a == "number") i = a; else if (i == 1) o = vs(o, a); else if (i == 2) { let l = a, u = e[++s]; r = vs(r, l + ": " + u + ";") } } n ? t.styles = r : t.stylesWithoutHost = r, n ? t.classes = o : t.classesWithoutHost = o } var Oo = class extends Mn { constructor(e) { super(), this.ngModule = e } resolveComponentFactory(e) { let n = pt(e); return new Tn(n, this.ngModule) } }; function Qc(t, e) { let n = []; for (let r in t) { if (!t.hasOwnProperty(r)) continue; let o = t[r]; if (o === void 0) continue; let i = Array.isArray(o), s = i ? o[0] : o, a = i ? o[1] : ht.None; e ? n.push({ propName: s, templateName: r, isSignal: (a & ht.SignalBased) !== 0 }) : n.push({ propName: s, templateName: r }) } return n } function sE(t) { let e = t.toLowerCase(); return e === "svg" ? qd : e === "math" ? yy : null } var Tn = class extends No { get inputs() { let e = this.componentDef, n = e.inputTransforms, r = Qc(e.inputs, !0); if (n !== null) for (let o of r) n.hasOwnProperty(o.propName) && (o.transform = n[o.propName]); return r } get outputs() { return Qc(this.componentDef.outputs, !1) } constructor(e, n) { super(), this.componentDef = e, this.ngModule = n, this.componentType = e.type, this.selector = Kg(e.selectors), this.ngContentSelectors = e.ngContentSelectors ? e.ngContentSelectors : [], this.isBoundToModule = !!n } create(e, n, r, o) { let i = A(null); try { o = o || this.ngModule; let s = o instanceof mt ? o : o?.injector; s && this.componentDef.getStandaloneInjector !== null && (s = this.componentDef.getStandaloneInjector(s) || s); let a = s ? new xs(e, s) : e, l = a.get(xo, null); if (l === null) throw new g(407, !1); let u = a.get(iE, null), c = a.get(Sn, null), d = { rendererFactory: l, sanitizer: u, inlineEffectRunner: null, changeDetectionScheduler: c }, h = l.createRenderer(null, this.componentDef), f = this.componentDef.selectors[0][0] || "div", p = r ? mD(h, r, this.componentDef.encapsulation, a) : Bf(h, f, sE(f)), m = 512; this.componentDef.signals ? m |= 4096 : this.componentDef.onPush || (m |= 16); let D = null; p !== null && (D = ol(p, a, !0)); let v = hl(0, null, null, 1, 0, null, null, null, null, null, null), b = ii(null, v, null, m, null, null, d, h, a, null, D); Ja(b); let j, k, re = null; try { let U = this.componentDef, G, Z = null; U.findHostDirectiveDefs ? (G = [], Z = new Map, U.findHostDirectiveDefs(U, G, Z), G.push(U)) : G = [U]; let Ge = aE(b, p); re = lE(Ge, p, U, G, b, d, h), k = za(v, Y), p && dE(h, U, p, r), n !== void 0 && fE(k, this.ngContentSelectors, n), j = cE(re, U, G, Z, b, [hE]), gl(v, b, null) } catch (U) { throw re !== null && Vs(re), Vs(b), U } finally { Xa() } return new ta(this.componentType, j, An(k, b), b, k) } finally { A(i) } } }, ta = class extends Xs { constructor(e, n, r, o, i) { super(), this.location = r, this._rootLView = o, this._tNode = i, this.previousInputValues = null, this.instance = n, this.hostView = this.changeDetectorRef = new Gt(o, void 0, !1), this.componentType = e } setInput(e, n) { let r = this._tNode.inputs, o; if (r !== null && (o = r[e])) { if (this.previousInputValues ??= new Map, this.previousInputValues.has(e) && Object.is(this.previousInputValues.get(e), n)) return; let i = this._rootLView; ml(i[T], i, o, e, n), this.previousInputValues.set(e, n); let s = Et(this._tNode.index, i); yl(s, 1) } } get injector() { return new Lt(this._tNode, this._rootLView) } destroy() { this.hostView.destroy() } onDestroy(e) { this.hostView.onDestroy(e) } }; function aE(t, e) { let n = t[T], r = Y; return t[r] = e, Pn(n, r, 2, "#host", null) } function lE(t, e, n, r, o, i, s) { let a = o[T]; uE(r, t, e, s); let l = null; e !== null && (l = ol(e, o[En])); let u = i.rendererFactory.createRenderer(e, n), c = 16; n.signals ? c = 4096 : n.onPush && (c = 64); let d = ii(o, th(n), null, c, o[t.index], t, i, u, null, null, l); return a.firstCreatePass && Ks(a, t, r.length - 1), ai(o, d), o[t.index] = d } function uE(t, e, n, r) { for (let o of t) e.mergedAttrs = Yn(e.mergedAttrs, o.hostAttrs); e.mergedAttrs !== null && (Ao(e, e.mergedAttrs, !0), n !== null && Kf(r, n, e)) } function cE(t, e, n, r, o, i) { let s = J(), a = o[T], l = be(s, o); nh(a, o, s, n, null, r); for (let c = 0; c < n.length; c++) { let d = s.directiveStart + c, h = qt(o, a, d, s); vt(h, o) } rh(a, o, s), l && vt(l, o); let u = qt(o, a, s.directiveStart + s.componentOffset, s); if (t[te] = o[te] = u, i !== null) for (let c of i) c(u, e); return cl(a, s, o), u } function dE(t, e, n, r) { if (r) _s(t, n, ["ng-version", "18.2.13"]); else { let { attrs: o, classes: i } = Yg(e.selectors[0]); o && _s(t, n, o), i && i.length > 0 && Zf(t, n, i.join(" ")) } } function fE(t, e, n) { let r = t.projection = []; for (let o = 0; o < e.length; o++) { let i = n[o]; r.push(i != null ? Array.from(i) : null) } } function hE() { let t = J(); Jo(S()[T], t) } var Fn = (() => { class t { static { this.__NG_ELEMENT_ID__ = pE } } return t })(); function pE() { let t = J(); return Ih(t, S()) } var mE = Fn, _h = class extends mE { constructor(e, n, r) { super(), this._lContainer = e, this._hostTNode = n, this._hostLView = r } get element() { return An(this._hostTNode, this._hostLView) } get injector() { return new Lt(this._hostTNode, this._hostLView) } get parentInjector() { let e = el(this._hostTNode, this._hostLView); if (cf(e)) { let n = _o(e, this._hostLView), r = wo(e), o = n[T].data[r + 8]; return new Lt(o, n) } else return new Lt(null, this._hostLView) } clear() { for (; this.length > 0;)this.remove(this.length - 1) } get(e) { let n = Zc(this._lContainer); return n !== null && n[e] || null } get length() { return this._lContainer.length - ie } createEmbeddedView(e, n, r) { let o, i; typeof r == "number" ? o = r : r != null && (o = r.index, i = r.injector); let s = Cn(this._lContainer, e.ssrId), a = e.createEmbeddedViewImpl(n || {}, i, s); return this.insertImpl(a, o, In(this._hostTNode, s)), a } createComponent(e, n, r, o, i) { let s = e && !hy(e), a; if (s) a = n; else { let p = n || {}; a = p.index, r = p.injector, o = p.projectableNodes, i = p.environmentInjector || p.ngModuleRef } let l = s ? e : new Tn(pt(e)), u = r || this.parentInjector; if (!i && l.ngModule == null) { let m = (s ? u : this.parentInjector).get(mt, null); m && (i = m) } let c = pt(l.componentType ?? {}), d = Cn(this._lContainer, c?.id ?? null), h = d?.firstChild ?? null, f = l.create(u, o, h, i); return this.insertImpl(f.hostView, a, In(this._hostTNode, d)), f } insert(e, n) { return this.insertImpl(e, n, !0) } insertImpl(e, n, r) { let o = e._lView; if (Ey(o)) { let a = this.indexOf(e); if (a !== -1) this.detach(a); else { let l = o[se], u = new _h(l, l[he], l[se]); u.detach(u.indexOf(e)) } } let i = this._adjustIndex(n), s = this._lContainer; return cr(s, o, i, r), e.attachToViewContainerRef(), wd(fs(s), i, e), e } move(e, n) { return this.insert(e, n) } indexOf(e) { let n = Zc(this._lContainer); return n !== null ? n.indexOf(e) : -1 } remove(e) { let n = this._adjustIndex(e, -1), r = tr(this._lContainer, n); r && (mo(fs(this._lContainer), n), ni(r[T], r)) } detach(e) { let n = this._adjustIndex(e, -1), r = tr(this._lContainer, n); return r && mo(fs(this._lContainer), n) != null ? new Gt(r) : null } _adjustIndex(e, n = 0) { return e ?? this.length + n } }; function Zc(t) { return t[Do] } function fs(t) { return t[Do] || (t[Do] = []) } function Ih(t, e) { let n, r = e[t.index]; return nt(r) ? n = r : (n = oh(r, e, null, t), e[t.index] = n, ai(e, n)), yE(n, e, t, r), new _h(n, t, e) } function gE(t, e) { let n = t[z], r = n.createComment(""), o = be(e, t), i = qf(n, o); return Mo(n, i, r, oD(n, o), !1), r } var yE = EE, vE = () => !1; function DE(t, e, n) { return vE(t, e, n) } function EE(t, e, n, r) { if (t[$t]) return; let o; n.type & 8 ? o = He(r) : o = gE(e, n), t[$t] = o } var na = class t { constructor(e) { this.queryList = e, this.matches = null } clone() { return new t(this.queryList) } setDirty() { this.queryList.setDirty() } }, ra = class t { constructor(e = []) { this.queries = e } createEmbeddedView(e) { let n = e.queries; if (n !== null) { let r = e.contentQueries !== null ? e.contentQueries[0] : n.length, o = []; for (let i = 0; i < r; i++) { let s = n.getByIndex(i), a = this.queries[s.indexInDeclarationView]; o.push(a.clone()) } return new t(o) } return null } insertView(e) { this.dirtyQueriesWithMatches(e) } detachView(e) { this.dirtyQueriesWithMatches(e) } finishViewCreation(e) { this.dirtyQueriesWithMatches(e) } dirtyQueriesWithMatches(e) { for (let n = 0; n < this.queries.length; n++)vl(e, n).matches !== null && this.queries[n].setDirty() } }, Po = class { constructor(e, n, r = null) { this.flags = n, this.read = r, typeof e == "string" ? this.predicate = TE(e) : this.predicate = e } }, oa = class t { constructor(e = []) { this.queries = e } elementStart(e, n) { for (let r = 0; r < this.queries.length; r++)this.queries[r].elementStart(e, n) } elementEnd(e) { for (let n = 0; n < this.queries.length; n++)this.queries[n].elementEnd(e) } embeddedTView(e) { let n = null; for (let r = 0; r < this.length; r++) { let o = n !== null ? n.length : 0, i = this.getByIndex(r).embeddedTView(e, o); i && (i.indexInDeclarationView = r, n !== null ? n.push(i) : n = [i]) } return n !== null ? new t(n) : null } template(e, n) { for (let r = 0; r < this.queries.length; r++)this.queries[r].template(e, n) } getByIndex(e) { return this.queries[e] } get length() { return this.queries.length } track(e) { this.queries.push(e) } }, ia = class t { constructor(e, n = -1) { this.metadata = e, this.matches = null, this.indexInDeclarationView = -1, this.crossesNgTemplate = !1, this._appliesToNextNode = !0, this._declarationNodeIndex = n } elementStart(e, n) { this.isApplyingToNode(n) && this.matchTNode(e, n) } elementEnd(e) { this._declarationNodeIndex === e.index && (this._appliesToNextNode = !1) } template(e, n) { this.elementStart(e, n) } embeddedTView(e, n) { return this.isApplyingToNode(e) ? (this.crossesNgTemplate = !0, this.addMatch(-e.index, n), new t(this.metadata)) : null } isApplyingToNode(e) { if (this._appliesToNextNode && (this.metadata.flags & 1) !== 1) { let n = this._declarationNodeIndex, r = e.parent; for (; r !== null && r.type & 8 && r.index !== n;)r = r.parent; return n === (r !== null ? r.index : -1) } return this._appliesToNextNode } matchTNode(e, n) { let r = this.metadata.predicate; if (Array.isArray(r)) for (let o = 0; o < r.length; o++) { let i = r[o]; this.matchTNodeWithReadOption(e, n, wE(n, i)), this.matchTNodeWithReadOption(e, n, uo(n, e, i, !1, !1)) } else r === bn ? n.type & 4 && this.matchTNodeWithReadOption(e, n, -1) : this.matchTNodeWithReadOption(e, n, uo(n, e, r, !1, !1)) } matchTNodeWithReadOption(e, n, r) { if (r !== null) { let o = this.metadata.read; if (o !== null) if (o === _t || o === Fn || o === bn && n.type & 4) this.addMatch(n.index, -2); else { let i = uo(n, e, o, !1, !1); i !== null && this.addMatch(n.index, i) } else this.addMatch(n.index, r) } } addMatch(e, n) { this.matches === null ? this.matches = [e, n] : this.matches.push(e, n) } }; function wE(t, e) { let n = t.localNames; if (n !== null) { for (let r = 0; r < n.length; r += 2)if (n[r] === e) return n[r + 1] } return null } function _E(t, e) { return t.type & 11 ? An(t, e) : t.type & 4 ? li(t, e) : null } function IE(t, e, n, r) { return n === -1 ? _E(e, t) : n === -2 ? bE(t, e, r) : qt(t, t[T], n, e) } function bE(t, e, n) { if (n === _t) return An(e, t); if (n === bn) return li(e, t); if (n === Fn) return Ih(e, t) } function bh(t, e, n, r) { let o = e[Je].queries[r]; if (o.matches === null) { let i = t.data, s = n.matches, a = []; for (let l = 0; s !== null && l < s.length; l += 2) { let u = s[l]; if (u < 0) a.push(null); else { let c = i[u]; a.push(IE(e, c, s[l + 1], n.metadata.read)) } } o.matches = a } return o.matches } function sa(t, e, n, r) { let o = t.queries.getByIndex(n), i = o.matches; if (i !== null) { let s = bh(t, e, o, n); for (let a = 0; a < i.length; a += 2) { let l = i[a]; if (l > 0) r.push(s[a / 2]); else { let u = i[a + 1], c = e[-l]; for (let d = ie; d < c.length; d++) { let h = c[d]; h[Bt] === h[se] && sa(h[T], h, u, r) } if (c[wn] !== null) { let d = c[wn]; for (let h = 0; h < d.length; h++) { let f = d[h]; sa(f[T], f, u, r) } } } } } return r } function CE(t, e) { return t[Je].queries[e].queryList } function Ch(t, e, n) { let r = new js((n & 4) === 4); return vD(t, e, r, r.destroy), (e[Je] ??= new ra).queries.push(new na(r)) - 1 } function SE(t, e, n) { let r = H(); return r.firstCreatePass && (Sh(r, new Po(t, e, n), -1), (e & 2) === 2 && (r.staticViewQueries = !0)), Ch(r, S(), e) } function ME(t, e, n, r) { let o = H(); if (o.firstCreatePass) { let i = J(); Sh(o, new Po(e, n, r), i.index), NE(o, t), (n & 2) === 2 && (o.staticContentQueries = !0) } return Ch(o, S(), n) } function TE(t) { return t.split(",").map(e => e.trim()) } function Sh(t, e, n) { t.queries === null && (t.queries = new oa), t.queries.track(new ia(e, n)) } function NE(t, e) { let n = t.contentQueries || (t.contentQueries = []), r = n.length ? n[n.length - 1] : -1; e !== r && n.push(t.queries.length - 1, e) } function vl(t, e) { return t.queries.getByIndex(e) } function xE(t, e) { let n = t[T], r = vl(n, e); return r.crossesNgTemplate ? sa(n, t, e, []) : bh(n, t, r, e) } var Kc = new Set; function It(t) { Kc.has(t) || (Kc.add(t), performance?.mark?.("mark_feature_usage", { detail: { feature: t } })) } function AE(t) { return typeof t == "function" && t[Qe] !== void 0 } function DO(t, e) { It("NgSignals"); let n = Lu(t), r = n[Qe]; return e?.equal && (r.equal = e.equal), n.set = o => ji(r, o), n.update = o => ju(r, o), n.asReadonly = OE.bind(n), n } function OE() { let t = this[Qe]; if (t.readonlyFn === void 0) { let e = () => this(); e[Qe] = t, t.readonlyFn = e } return t.readonlyFn } function Mh(t) { return AE(t) && typeof t.set == "function" } function PE(t) { return Object.getPrototypeOf(t.prototype).constructor } function FE(t) { let e = PE(t.type), n = !0, r = [t]; for (; e;) { let o; if (Xe(t)) o = e.\u0275cmp || e.\u0275dir; else { if (e.\u0275cmp) throw new g(903, !1); o = e.\u0275dir } if (o) { if (n) { r.push(o); let s = t; s.inputs = ro(t.inputs), s.inputTransforms = ro(t.inputTransforms), s.declaredInputs = ro(t.declaredInputs), s.outputs = ro(t.outputs); let a = o.hostBindings; a && VE(t, a); let l = o.viewQuery, u = o.contentQueries; if (l && LE(t, l), u && jE(t, u), RE(t, o), mg(t.outputs, o.outputs), Xe(o) && o.data.animation) { let c = t.data; c.animation = (c.animation || []).concat(o.data.animation) } } let i = o.features; if (i) for (let s = 0; s < i.length; s++) { let a = i[s]; a && a.ngInherit && a(t), a === FE && (n = !1) } } e = Object.getPrototypeOf(e) } kE(r) } function RE(t, e) { for (let n in e.inputs) { if (!e.inputs.hasOwnProperty(n) || t.inputs.hasOwnProperty(n)) continue; let r = e.inputs[n]; if (r !== void 0 && (t.inputs[n] = r, t.declaredInputs[n] = e.declaredInputs[n], e.inputTransforms !== null)) { let o = Array.isArray(r) ? r[0] : r; if (!e.inputTransforms.hasOwnProperty(o)) continue; t.inputTransforms ??= {}, t.inputTransforms[o] = e.inputTransforms[o] } } } function kE(t) { let e = 0, n = null; for (let r = t.length - 1; r >= 0; r--) { let o = t[r]; o.hostVars = e += o.hostVars, o.hostAttrs = Yn(o.hostAttrs, n = Yn(n, o.hostAttrs)) } } function ro(t) { return t === Ye ? {} : t === ce ? [] : t } function LE(t, e) { let n = t.viewQuery; n ? t.viewQuery = (r, o) => { e(r, o), n(r, o) } : t.viewQuery = e } function jE(t, e) { let n = t.contentQueries; n ? t.contentQueries = (r, o, i) => { e(r, o, i), n(r, o, i) } : t.contentQueries = e } function VE(t, e) { let n = t.hostBindings; n ? t.hostBindings = (r, o) => { e(r, o), n(r, o) } : t.hostBindings = e } function EO(t) { let e = n => { let r = Array.isArray(t); n.hostDirectives === null ? (n.findHostDirectiveDefs = Th, n.hostDirectives = r ? t.map(aa) : [t]) : r ? n.hostDirectives.unshift(...t.map(aa)) : n.hostDirectives.unshift(t) }; return e.ngInherit = !0, e } function Th(t, e, n) { if (t.hostDirectives !== null) for (let r of t.hostDirectives) if (typeof r == "function") { let o = r(); for (let i of o) Yc(aa(i), e, n) } else Yc(r, e, n) } function Yc(t, e, n) { let r = Va(t.directive); BE(r.declaredInputs, t.inputs), Th(r, e, n), n.set(r, t), e.push(r) } function aa(t) { return typeof t == "function" ? { directive: ee(t), inputs: Ye, outputs: Ye } : { directive: ee(t.directive), inputs: Jc(t.inputs), outputs: Jc(t.outputs) } } function Jc(t) { if (t === void 0 || t.length === 0) return Ye; let e = {}; for (let n = 0; n < t.length; n += 2)e[t[n]] = t[n + 1]; return e } function BE(t, e) { for (let n in e) if (e.hasOwnProperty(n)) { let r = e[n], o = t[n]; t[r] = o } } function $E(t) { let e = t.inputConfig, n = {}; for (let r in e) if (e.hasOwnProperty(r)) { let o = e[r]; Array.isArray(o) && o[3] && (n[r] = o[3]) } t.inputTransforms = n } var Dt = class { }, la = class { }; var ua = class extends Dt { constructor(e, n, r, o = !0) { super(), this.ngModuleType = e, this._parent = n, this._bootstrapComponents = [], this.destroyCbs = [], this.componentFactoryResolver = new Oo(this); let i = xd(e); this._bootstrapComponents = jf(i.bootstrap), this._r3Injector = Df(e, n, [{ provide: Dt, useValue: this }, { provide: Mn, useValue: this.componentFactoryResolver }, ...r], ae(e), new Set(["environment"])), o && this.resolveInjectorInitializers() } resolveInjectorInitializers() { this._r3Injector.resolveInjectorInitializers(), this.instance = this._r3Injector.get(this.ngModuleType) } get injector() { return this._r3Injector } destroy() { let e = this._r3Injector; !e.destroyed && e.destroy(), this.destroyCbs.forEach(n => n()), this.destroyCbs = null } onDestroy(e) { this.destroyCbs.push(e) } }, ca = class extends la { constructor(e) { super(), this.moduleType = e } create(e) { return new ua(this.moduleType, e, []) } }; var Fo = class extends Dt { constructor(e) { super(), this.componentFactoryResolver = new Oo(this), this.instance = null; let n = new Jn([...e.providers, { provide: Dt, useValue: this }, { provide: Mn, useValue: this.componentFactoryResolver }], e.parent || zo(), e.debugName, new Set(["environment"])); this.injector = n, e.runEnvironmentInitializers && n.resolveInjectorInitializers() } destroy() { this.injector.destroy() } onDestroy(e) { this.injector.onDestroy(e) } }; function HE(t, e, n = null) { return new Fo({ providers: t, parent: e, debugName: n, runEnvironmentInitializers: !0 }).injector } function Nh(t) { return Dl(t) ? Array.isArray(t) || !(t instanceof Map) && Symbol.iterator in t : !1 } function UE(t, e) { if (Array.isArray(t)) for (let n = 0; n < t.length; n++)e(t[n]); else { let n = t[Symbol.iterator](), r; for (; !(r = n.next()).done;)e(r.value) } } function Dl(t) { return t !== null && (typeof t == "function" || typeof t == "object") } function El(t, e, n) { return t[e] = n } function zE(t, e) { return t[e] } function ye(t, e, n) { let r = t[e]; return Object.is(r, n) ? !1 : (t[e] = n, !0) } function xh(t, e, n, r) { let o = ye(t, e, n); return ye(t, e + 1, r) || o } function qE(t) { return (t.flags & 32) === 32 } function GE(t, e, n, r, o, i, s, a, l) { let u = e.consts, c = Pn(e, t, 4, s || null, a || null); pl(e, n, c, gt(u, l)), Jo(e, c); let d = c.tView = hl(2, c, r, o, i, e.directiveRegistry, e.pipeRegistry, null, e.schemas, u, null); return e.queries !== null && (e.queries.template(e, c), d.queries = e.queries.embeddedTView(c)), c } function Ro(t, e, n, r, o, i, s, a, l, u) { let c = n + Y, d = e.firstCreatePass ? GE(c, e, t, r, o, i, s, a, l) : e.data[c]; Qt(d, !1); let h = QE(e, t, d, n); Ko() && ri(e, t, h, d), vt(h, t); let f = oh(h, t, h, d); return t[c] = f, ai(t, f), DE(f, d, t), Wo(d) && dl(e, t, d), l != null && fl(t, d, u), d } function WE(t, e, n, r, o, i, s, a) { let l = S(), u = H(), c = gt(u.consts, i); return Ro(l, u, t, e, n, r, o, c, s, a), WE } var QE = ZE; function ZE(t, e, n, r) { return Yo(!0), e[z].createComment("") } var mn = function (t) { return t[t.EarlyRead = 0] = "EarlyRead", t[t.Write = 1] = "Write", t[t.MixedReadWrite = 2] = "MixedReadWrite", t[t.Read = 3] = "Read", t }(mn || {}), Ah = (() => { class t { constructor() { this.impl = null } execute() { this.impl?.execute() } static { this.\u0275prov = $({ token: t, providedIn: "root", factory: () => new t }) } } return t })(), da = class t { constructor() { this.ngZone = R(ge), this.scheduler = R(Sn), this.errorHandler = R(_n, { optional: !0 }), this.sequences = new Set, this.deferredRegistrations = new Set, this.executing = !1 } static { this.PHASES = [mn.EarlyRead, mn.Write, mn.MixedReadWrite, mn.Read] } execute() { this.executing = !0; for (let e of t.PHASES) for (let n of this.sequences) if (!(n.erroredOrDestroyed || !n.hooks[e])) try { n.pipelinedValue = this.ngZone.runOutsideAngular(() => n.hooks[e](n.pipelinedValue)) } catch (r) { n.erroredOrDestroyed = !0, this.errorHandler?.handleError(r) } this.executing = !1; for (let e of this.sequences) e.afterRun(), e.once && (this.sequences.delete(e), e.destroy()); for (let e of this.deferredRegistrations) this.sequences.add(e); this.deferredRegistrations.size > 0 && this.scheduler.notify(7), this.deferredRegistrations.clear() } register(e) { this.executing ? this.deferredRegistrations.add(e) : (this.sequences.add(e), this.scheduler.notify(6)) } unregister(e) { this.executing && this.sequences.has(e) ? (e.erroredOrDestroyed = !0, e.pipelinedValue = void 0, e.once = !0) : (this.sequences.delete(e), this.deferredRegistrations.delete(e)) } static { this.\u0275prov = $({ token: t, providedIn: "root", factory: () => new t }) } }, fa = class { constructor(e, n, r, o) { this.impl = e, this.hooks = n, this.once = r, this.erroredOrDestroyed = !1, this.pipelinedValue = void 0, this.unregisterOnDestroy = o?.onDestroy(() => this.destroy()) } afterRun() { this.erroredOrDestroyed = !1, this.pipelinedValue = void 0 } destroy() { this.impl.unregister(this), this.unregisterOnDestroy?.() } }; function KE(t, e) { !e?.injector && Vd(KE); let n = e?.injector ?? R(yt); return Vf(n) ? (It("NgAfterRender"), Oh(t, n, e, !1)) : Ph } function YE(t, e) { !e?.injector && Vd(YE); let n = e?.injector ?? R(yt); return Vf(n) ? (It("NgAfterNextRender"), Oh(t, n, e, !0)) : Ph } function JE(t, e) { if (t instanceof Function) { let n = [void 0, void 0, void 0, void 0]; return n[e] = t, n } else return [t.earlyRead, t.write, t.mixedReadWrite, t.read] } function Oh(t, e, n, r) { let o = e.get(Ah); o.impl ??= e.get(da); let i = n?.phase ?? mn.MixedReadWrite, s = n?.manualCleanup !== !0 ? e.get(tl) : null, a = new fa(o.impl, JE(t, i), r, s); return o.impl.register(a), a } var Ph = { destroy() { } }; function XE(t, e, n, r) { let o = S(), i = wt(); if (ye(o, i, e)) { let s = H(), a = ar(); PD(a, o, t, e, n, r) } return XE } function ew(t, e, n, r) { return ye(t, wt(), n) ? e + jt(n) + r : ve } function tw(t, e, n, r, o, i) { let s = xy(), a = xh(t, s, n, o); return Za(2), a ? e + jt(n) + r + jt(o) + i : ve } function oo(t, e) { return t << 17 | e << 2 } function Wt(t) { return t >> 17 & 32767 } function nw(t) { return (t & 2) == 2 } function rw(t, e) { return t & 131071 | e << 17 } function ha(t) { return t | 2 } function Nn(t) { return (t & 131068) >> 2 } function hs(t, e) { return t & -131069 | e << 2 } function ow(t) { return (t & 1) === 1 } function pa(t) { return t | 1 } function iw(t, e, n, r, o, i) { let s = i ? e.classBindings : e.styleBindings, a = Wt(s), l = Nn(s); t[r] = n; let u = !1, c; if (Array.isArray(n)) { let d = n; c = d[1], (c === null || or(d, c) > 0) && (u = !0) } else c = n; if (o) if (l !== 0) { let h = Wt(t[a + 1]); t[r + 1] = oo(h, a), h !== 0 && (t[h + 1] = hs(t[h + 1], r)), t[a + 1] = rw(t[a + 1], r) } else t[r + 1] = oo(a, 0), a !== 0 && (t[a + 1] = hs(t[a + 1], r)), a = r; else t[r + 1] = oo(l, 0), a === 0 ? a = r : t[l + 1] = hs(t[l + 1], r), l = r; u && (t[r + 1] = ha(t[r + 1])), Xc(t, c, r, !0), Xc(t, c, r, !1), sw(e, c, t, r, i), s = oo(a, l), i ? e.classBindings = s : e.styleBindings = s } function sw(t, e, n, r, o) { let i = o ? t.residualClasses : t.residualStyles; i != null && typeof e == "string" && or(i, e) >= 0 && (n[r + 1] = pa(n[r + 1])) } function Xc(t, e, n, r) { let o = t[n + 1], i = e === null, s = r ? Wt(o) : Nn(o), a = !1; for (; s !== 0 && (a === !1 || i);) { let l = t[s], u = t[s + 1]; aw(l, e) && (a = !0, t[s + 1] = r ? pa(u) : ha(u)), s = r ? Wt(u) : Nn(u) } a && (t[n + 1] = r ? ha(o) : pa(o)) } function aw(t, e) { return t === null || e == null || (Array.isArray(t) ? t[1] : t) === e ? !0 : Array.isArray(t) && typeof e == "string" ? or(t, e) >= 0 : !1 } var Ae = { textEnd: 0, key: 0, keyEnd: 0, value: 0, valueEnd: 0 }; function lw(t) { return t.substring(Ae.key, Ae.keyEnd) } function uw(t) { return cw(t), Fh(t, Rh(t, 0, Ae.textEnd)) } function Fh(t, e) { let n = Ae.textEnd; return n === e ? -1 : (e = Ae.keyEnd = dw(t, Ae.key = e, n), Rh(t, e, n)) } function cw(t) { Ae.key = 0, Ae.keyEnd = 0, Ae.value = 0, Ae.valueEnd = 0, Ae.textEnd = t.length } function Rh(t, e, n) { for (; e < n && t.charCodeAt(e) <= 32;)e++; return e } function dw(t, e, n) { for (; e < n && t.charCodeAt(e) > 32;)e++; return e } function fw(t, e, n) { let r = S(), o = wt(); if (ye(r, o, e)) { let i = H(), s = ar(); si(i, s, r, t, e, r[z], n, !1) } return fw } function ma(t, e, n, r, o) { let i = e.inputs, s = o ? "class" : "style"; ml(t, n, i[s], s, r) } function kh(t, e, n) { return Lh(t, e, n, !1), kh } function hw(t, e) { return Lh(t, e, null, !0), hw } function wO(t) { mw(ww, pw, t, !0) } function pw(t, e) { for (let n = uw(e); n >= 0; n = Fh(e, n))La(t, lw(e), !0) } function Lh(t, e, n, r) { let o = S(), i = H(), s = Za(2); if (i.firstUpdatePass && Vh(i, t, s, r), e !== ve && ye(o, s, e)) { let a = i.data[rt()]; Bh(i, a, o, o[z], t, o[s + 1] = Iw(e, n), r, s) } } function mw(t, e, n, r) { let o = H(), i = Za(2); o.firstUpdatePass && Vh(o, null, i, r); let s = S(); if (n !== ve && ye(s, i, n)) { let a = o.data[rt()]; if ($h(a, r) && !jh(o, i)) { let l = r ? a.classesWithoutHost : a.stylesWithoutHost; l !== null && (n = vs(l, n || "")), ma(o, a, s, n, r) } else _w(o, a, s, s[z], s[i + 1], s[i + 1] = Ew(t, e, n), r, i) } } function jh(t, e) { return e >= t.expandoStartIndex } function Vh(t, e, n, r) { let o = t.data; if (o[n + 1] === null) { let i = o[rt()], s = jh(t, n); $h(i, r) && e === null && !s && (e = !1), e = gw(o, i, e, r), iw(o, i, e, n, s, r) } } function gw(t, e, n, r) { let o = Ka(t), i = r ? e.residualClasses : e.residualStyles; if (o === null) (r ? e.classBindings : e.styleBindings) === 0 && (n = ps(null, t, e, n, r), n = nr(n, e.attrs, r), i = null); else { let s = e.directiveStylingLast; if (s === -1 || t[s] !== o) if (n = ps(o, t, e, n, r), i === null) { let l = yw(t, e, r); l !== void 0 && Array.isArray(l) && (l = ps(null, t, e, l[1], r), l = nr(l, e.attrs, r), vw(t, e, r, l)) } else i = Dw(t, e, r) } return i !== void 0 && (r ? e.residualClasses = i : e.residualStyles = i), n } function yw(t, e, n) { let r = n ? e.classBindings : e.styleBindings; if (Nn(r) !== 0) return t[Wt(r)] } function vw(t, e, n, r) { let o = n ? e.classBindings : e.styleBindings; t[Wt(o)] = r } function Dw(t, e, n) { let r, o = e.directiveEnd; for (let i = 1 + e.directiveStylingLast; i < o; i++) { let s = t[i].hostAttrs; r = nr(r, s, n) } return nr(r, e.attrs, n) } function ps(t, e, n, r, o) { let i = null, s = n.directiveEnd, a = n.directiveStylingLast; for (a === -1 ? a = n.directiveStart : a++; a < s && (i = e[a], r = nr(r, i.hostAttrs, o), i !== t);)a++; return t !== null && (n.directiveStylingLast = a), r } function nr(t, e, n) { let r = n ? 1 : 2, o = -1; if (e !== null) for (let i = 0; i < e.length; i++) { let s = e[i]; typeof s == "number" ? o = s : o === r && (Array.isArray(t) || (t = t === void 0 ? [] : ["", t]), La(t, s, n ? !0 : e[++i])) } return t === void 0 ? null : t } function Ew(t, e, n) { if (n == null || n === "") return ce; let r = [], o = On(n); if (Array.isArray(o)) for (let i = 0; i < o.length; i++)t(r, o[i], !0); else if (typeof o == "object") for (let i in o) o.hasOwnProperty(i) && t(r, i, o[i]); else typeof o == "string" && e(r, o); return r } function ww(t, e, n) { let r = String(e); r !== "" && !r.includes(" ") && La(t, r, n) } function _w(t, e, n, r, o, i, s, a) { o === ve && (o = ce); let l = 0, u = 0, c = 0 < o.length ? o[0] : null, d = 0 < i.length ? i[0] : null; for (; c !== null || d !== null;) { let h = l < o.length ? o[l + 1] : void 0, f = u < i.length ? i[u + 1] : void 0, p = null, m; c === d ? (l += 2, u += 2, h !== f && (p = d, m = f)) : d === null || c !== null && c < d ? (l += 2, p = c) : (u += 2, p = d, m = f), p !== null && Bh(t, e, n, r, p, m, s, a), c = l < o.length ? o[l] : null, d = u < i.length ? i[u] : null } } function Bh(t, e, n, r, o, i, s, a) { if (!(e.type & 3)) return; let l = t.data, u = l[a + 1], c = ow(u) ? ed(l, e, n, o, Nn(u), s) : void 0; if (!ko(c)) { ko(i) || nw(u) && (i = ed(l, null, n, o, a, s)); let d = Gd(rt(), n); cD(r, s, d, o, i) } } function ed(t, e, n, r, o, i) { let s = e === null, a; for (; o > 0;) { let l = t[o], u = Array.isArray(l), c = u ? l[1] : l, d = c === null, h = n[o + 1]; h === ve && (h = d ? ce : void 0); let f = d ? os(h, r) : c === r ? h : void 0; if (u && !ko(f) && (f = os(l, r)), ko(f) && (a = f, s)) return a; let p = t[o + 1]; o = s ? Wt(p) : Nn(p) } if (e !== null) { let l = i ? e.residualClasses : e.residualStyles; l != null && (a = os(l, r)) } return a } function ko(t) { return t !== void 0 } function Iw(t, e) { return t == null || t === "" || (typeof e == "string" ? t = t + e : typeof t == "object" && (t = ae(On(t)))), t } function $h(t, e) { return (t.flags & (e ? 8 : 16)) !== 0 } function _O() { return S()[fe][te] } var ga = class { destroy(e) { } updateValue(e, n) { } swap(e, n) { let r = Math.min(e, n), o = Math.max(e, n), i = this.detach(o); if (o - r > 1) { let s = this.detach(r); this.attach(r, i), this.attach(o, s) } else this.attach(r, i) } move(e, n) { this.attach(n, this.detach(e)) } }; function ms(t, e, n, r, o) { return t === n && Object.is(e, r) ? 1 : Object.is(o(t, e), o(n, r)) ? -1 : 0 } function bw(t, e, n) { let r, o, i = 0, s = t.length - 1, a = void 0; if (Array.isArray(e)) { let l = e.length - 1; for (; i <= s && i <= l;) { let u = t.at(i), c = e[i], d = ms(i, u, i, c, n); if (d !== 0) { d < 0 && t.updateValue(i, c), i++; continue } let h = t.at(s), f = e[l], p = ms(s, h, l, f, n); if (p !== 0) { p < 0 && t.updateValue(s, f), s--, l--; continue } let m = n(i, u), D = n(s, h), v = n(i, c); if (Object.is(v, D)) { let b = n(l, f); Object.is(b, m) ? (t.swap(i, s), t.updateValue(s, f), l--, s--) : t.move(s, i), t.updateValue(i, c), i++; continue } if (r ??= new Lo, o ??= nd(t, i, s, n), ya(t, r, i, v)) t.updateValue(i, c), i++, s++; else if (o.has(v)) r.set(m, t.detach(i)), s--; else { let b = t.create(i, e[i]); t.attach(i, b), i++, s++ } } for (; i <= l;)td(t, r, n, i, e[i]), i++ } else if (e != null) { let l = e[Symbol.iterator](), u = l.next(); for (; !u.done && i <= s;) { let c = t.at(i), d = u.value, h = ms(i, c, i, d, n); if (h !== 0) h < 0 && t.updateValue(i, d), i++, u = l.next(); else { r ??= new Lo, o ??= nd(t, i, s, n); let f = n(i, d); if (ya(t, r, i, f)) t.updateValue(i, d), i++, s++, u = l.next(); else if (!o.has(f)) t.attach(i, t.create(i, d)), i++, s++, u = l.next(); else { let p = n(i, c); r.set(p, t.detach(i)), s-- } } } for (; !u.done;)td(t, r, n, t.length, u.value), u = l.next() } for (; i <= s;)t.destroy(t.detach(s--)); r?.forEach(l => { t.destroy(l) }) } function ya(t, e, n, r) { return e !== void 0 && e.has(r) ? (t.attach(n, e.get(r)), e.delete(r), !0) : !1 } function td(t, e, n, r, o) { if (ya(t, e, r, n(r, o))) t.updateValue(r, o); else { let i = t.create(r, o); t.attach(r, i) } } function nd(t, e, n, r) { let o = new Set; for (let i = e; i <= n; i++)o.add(r(i, t.at(i))); return o } var Lo = class { constructor() { this.kvMap = new Map, this._vMap = void 0 } has(e) { return this.kvMap.has(e) } delete(e) { if (!this.has(e)) return !1; let n = this.kvMap.get(e); return this._vMap !== void 0 && this._vMap.has(n) ? (this.kvMap.set(e, this._vMap.get(n)), this._vMap.delete(n)) : this.kvMap.delete(e), !0 } get(e) { return this.kvMap.get(e) } set(e, n) { if (this.kvMap.has(e)) { let r = this.kvMap.get(e); this._vMap === void 0 && (this._vMap = new Map); let o = this._vMap; for (; o.has(r);)r = o.get(r); o.set(r, n) } else this.kvMap.set(e, n) } forEach(e) { for (let [n, r] of this.kvMap) if (e(r, n), this._vMap !== void 0) { let o = this._vMap; for (; o.has(r);)r = o.get(r), e(r, n) } } }; function IO(t, e) { It("NgControlFlow"); let n = S(), r = wt(), o = n[r] !== ve ? n[r] : -1, i = o !== -1 ? jo(n, Y + o) : void 0, s = 0; if (ye(n, r, t)) { let a = A(null); try { if (i !== void 0 && fh(i, s), t !== -1) { let l = Y + t, u = jo(n, l), c = wa(n[T], l), d = Cn(u, c.tView.ssrId), h = ur(n, c, e, { dehydratedView: d }); cr(u, h, s, In(c, d)) } } finally { A(a) } } else if (i !== void 0) { let a = dh(i, s); a !== void 0 && (a[te] = e) } } var va = class { constructor(e, n, r) { this.lContainer = e, this.$implicit = n, this.$index = r } get $count() { return this.lContainer.length - ie } }; function bO(t) { return t } function CO(t, e) { return e } var Da = class { constructor(e, n, r) { this.hasEmptyBlock = e, this.trackByFn = n, this.liveCollection = r } }; function SO(t, e, n, r, o, i, s, a, l, u, c, d, h) { It("NgControlFlow"); let f = S(), p = H(), m = l !== void 0, D = S(), v = a ? s.bind(D[fe][te]) : s, b = new Da(m, v); D[Y + t] = b, Ro(f, p, t + 1, e, n, r, o, gt(p.consts, i)), m && Ro(f, p, t + 2, l, u, c, d, gt(p.consts, h)) } var Ea = class extends ga { constructor(e, n, r) { super(), this.lContainer = e, this.hostLView = n, this.templateTNode = r, this.operationsCounter = void 0, this.needsIndexUpdate = !1 } get length() { return this.lContainer.length - ie } at(e) { return this.getLView(e)[te].$implicit } attach(e, n) { let r = n[Dn]; this.needsIndexUpdate ||= e !== this.length, cr(this.lContainer, n, e, In(this.templateTNode, r)) } detach(e) { return this.needsIndexUpdate ||= e !== this.length - 1, Cw(this.lContainer, e) } create(e, n) { let r = Cn(this.lContainer, this.templateTNode.tView.ssrId), o = ur(this.hostLView, this.templateTNode, new va(this.lContainer, n, e), { dehydratedView: r }); return this.operationsCounter?.recordCreate(), o } destroy(e) { ni(e[T], e), this.operationsCounter?.recordDestroy() } updateValue(e, n) { this.getLView(e)[te].$implicit = n } reset() { this.needsIndexUpdate = !1, this.operationsCounter?.reset() } updateIndexes() { if (this.needsIndexUpdate) for (let e = 0; e < this.length; e++)this.getLView(e)[te].$index = e } getLView(e) { return Sw(this.lContainer, e) } }; function MO(t) { let e = A(null), n = rt(); try { let r = S(), o = r[T], i = r[n], s = n + 1, a = jo(r, s); if (i.liveCollection === void 0) { let u = wa(o, s); i.liveCollection = new Ea(a, r, u) } else i.liveCollection.reset(); let l = i.liveCollection; if (bw(l, t, i.trackByFn), l.updateIndexes(), i.hasEmptyBlock) { let u = wt(), c = l.length === 0; if (ye(r, u, c)) { let d = n + 2, h = jo(r, d); if (c) { let f = wa(o, d), p = Cn(h, f.tView.ssrId), m = ur(r, f, void 0, { dehydratedView: p }); cr(h, m, 0, In(f, p)) } else fh(h, 0) } } } finally { A(e) } } function jo(t, e) { return t[e] } function Cw(t, e) { return tr(t, e) } function Sw(t, e) { return dh(t, e) } function wa(t, e) { return za(t, e) } function Mw(t, e, n, r, o, i) { let s = e.consts, a = gt(s, o), l = Pn(e, t, 2, r, a); return pl(e, n, l, gt(s, i)), l.attrs !== null && Ao(l, l.attrs, !1), l.mergedAttrs !== null && Ao(l, l.mergedAttrs, !0), e.queries !== null && e.queries.elementStart(e, l), l } function Hh(t, e, n, r) { let o = S(), i = H(), s = Y + t, a = o[z], l = i.firstCreatePass ? Mw(s, i, o, e, n, r) : i.data[s], u = Nw(i, o, l, a, e, t); o[s] = u; let c = Wo(l); return Qt(l, !0), Kf(a, u, l), !qE(l) && Ko() && ri(i, o, u, l), Iy() === 0 && vt(u, o), by(), c && (dl(i, o, l), cl(i, l, o)), r !== null && fl(o, l), Hh } function Uh() { let t = J(); Wa() ? Qa() : (t = t.parent, Qt(t, !1)); let e = t; Sy(e) && My(), Cy(); let n = H(); return n.firstCreatePass && (Jo(n, t), Ha(t) && n.queries.elementEnd(t)), e.classesWithoutHost != null && $y(e) && ma(n, e, S(), e.classesWithoutHost, !0), e.stylesWithoutHost != null && Hy(e) && ma(n, e, S(), e.stylesWithoutHost, !1), Uh } function Tw(t, e, n, r) { return Hh(t, e, n, r), Uh(), Tw } var Nw = (t, e, n, r, o, i) => (Yo(!0), Bf(r, o, Ly())); function xw(t, e, n, r, o) { let i = e.consts, s = gt(i, r), a = Pn(e, t, 8, "ng-container", s); s !== null && Ao(a, s, !0); let l = gt(i, o); return pl(e, n, a, l), e.queries !== null && e.queries.elementStart(e, a), a } function zh(t, e, n) { let r = S(), o = H(), i = t + Y, s = o.firstCreatePass ? xw(i, o, r, e, n) : o.data[i]; Qt(s, !0); let a = Ow(o, r, s, t); return r[i] = a, Ko() && ri(o, r, a, s), vt(a, r), Wo(s) && (dl(o, r, s), cl(o, s, r)), n != null && fl(r, s), zh } function qh() { let t = J(), e = H(); return Wa() ? Qa() : (t = t.parent, Qt(t, !1)), e.firstCreatePass && (Jo(e, t), Ha(t) && e.queries.elementEnd(t)), qh } function Aw(t, e, n) { return zh(t, e, n), qh(), Aw } var Ow = (t, e, n, r) => (Yo(!0), Kv(e[z], "")); function TO() { return S() } function Pw(t, e, n) { let r = S(), o = wt(); if (ye(r, o, e)) { let i = H(), s = ar(); si(i, s, r, t, e, r[z], n, !0) } return Pw } function Fw(t, e, n) { let r = S(), o = wt(); if (ye(r, o, e)) { let i = H(), s = ar(), a = Ka(i.data), l = lh(a, s, r); si(i, s, r, t, e, l, n, !0) } return Fw } var kt = void 0; function Rw(t) { let e = t, n = Math.floor(Math.abs(t)), r = t.toString().replace(/^[^.]*\.?/, "").length; return n === 1 && r === 0 ? 1 : 5 } var kw = ["en", [["a", "p"], ["AM", "PM"], kt], [["AM", "PM"], kt, kt], [["S", "M", "T", "W", "T", "F", "S"], ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]], kt, [["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"], ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]], kt, [["B", "A"], ["BC", "AD"], ["Before Christ", "Anno Domini"]], 0, [6, 0], ["M/d/yy", "MMM d, y", "MMMM d, y", "EEEE, MMMM d, y"], ["h:mm a", "h:mm:ss a", "h:mm:ss a z", "h:mm:ss a zzzz"], ["{1}, {0}", kt, "{1} 'at' {0}", kt], [".", ",", ";", "%", "+", "-", "E", "\xD7", "\u2030", "\u221E", "NaN", ":"], ["#,##0.###", "#,##0%", "\xA4#,##0.00", "#E0"], "USD", "$", "US Dollar", {}, "ltr", Rw], Qn = {}; function Gh(t, e, n) { typeof e != "string" && (n = e, e = t[tt.LocaleId]), e = e.toLowerCase().replace(/_/g, "-"), Qn[e] = t, n && (Qn[e][tt.ExtraData] = n) } function ci(t) { let e = Lw(t), n = rd(e); if (n) return n; let r = e.split("-")[0]; if (n = rd(r), n) return n; if (r === "en") return kw; throw new g(701, !1) } function rd(t) { return t in Qn || (Qn[t] = ct.ng && ct.ng.common && ct.ng.common.locales && ct.ng.common.locales[t]), Qn[t] } var tt = function (t) { return t[t.LocaleId = 0] = "LocaleId", t[t.DayPeriodsFormat = 1] = "DayPeriodsFormat", t[t.DayPeriodsStandalone = 2] = "DayPeriodsStandalone", t[t.DaysFormat = 3] = "DaysFormat", t[t.DaysStandalone = 4] = "DaysStandalone", t[t.MonthsFormat = 5] = "MonthsFormat", t[t.MonthsStandalone = 6] = "MonthsStandalone", t[t.Eras = 7] = "Eras", t[t.FirstDayOfWeek = 8] = "FirstDayOfWeek", t[t.WeekendRange = 9] = "WeekendRange", t[t.DateFormat = 10] = "DateFormat", t[t.TimeFormat = 11] = "TimeFormat", t[t.DateTimeFormat = 12] = "DateTimeFormat", t[t.NumberSymbols = 13] = "NumberSymbols", t[t.NumberFormats = 14] = "NumberFormats", t[t.CurrencyCode = 15] = "CurrencyCode", t[t.CurrencySymbol = 16] = "CurrencySymbol", t[t.CurrencyName = 17] = "CurrencyName", t[t.Currencies = 18] = "Currencies", t[t.Directionality = 19] = "Directionality", t[t.PluralCase = 20] = "PluralCase", t[t.ExtraData = 21] = "ExtraData", t }(tt || {}); function Lw(t) { return t.toLowerCase().replace(/_/g, "-") } var Vo = "en-US", jw = "USD"; var Vw = Vo; function Bw(t) { typeof t == "string" && (Vw = t.toLowerCase().replace(/_/g, "-")) } var $w = (t, e, n) => { }; function Hw(t, e, n, r) { let o = S(), i = H(), s = J(); return wl(i, o, o[z], s, t, e, r), Hw } function Uw(t, e) { let n = J(), r = S(), o = H(), i = Ka(o.data), s = lh(i, n, r); return wl(o, r, s, n, t, e), Uw } function zw(t, e, n, r) { let o = t.cleanup; if (o != null) for (let i = 0; i < o.length - 1; i += 2) { let s = o[i]; if (s === n && o[i + 1] === r) { let a = e[vo], l = o[i + 2]; return a.length > l ? a[l] : null } typeof s == "string" && (i += 2) } return null } function wl(t, e, n, r, o, i, s) { let a = Wo(r), u = t.firstCreatePass && ah(t), c = e[te], d = sh(e), h = !0; if (r.type & 3 || s) { let m = be(r, e), D = s ? s(m) : m, v = d.length, b = s ? k => s(He(k[r.index])) : r.index, j = null; if (!s && a && (j = zw(t, e, o, r.index)), j !== null) { let k = j.__ngLastListenerFn__ || j; k.__ngNextListenerFn__ = i, j.__ngLastListenerFn__ = i, h = !1 } else { i = id(r, e, c, i), $w(m, o, i); let k = n.listen(D, o, i); d.push(i, k), u && u.push(o, b, v, v + 1) } } else i = id(r, e, c, i); let f = r.outputs, p; if (h && f !== null && (p = f[o])) { let m = p.length; if (m) for (let D = 0; D < m; D += 2) { let v = p[D], b = p[D + 1], re = e[v][b].subscribe(i), U = d.length; d.push(i, re), u && u.push(o, r.index, U, -(U + 1)) } } } function od(t, e, n, r) { let o = A(null); try { return Ve(6, e, n), n(r) !== !1 } catch (i) { return uh(t, i), !1 } finally { Ve(7, e, n), A(o) } } function id(t, e, n, r) { return function o(i) { if (i === Function) return r; let s = t.componentOffset > -1 ? Et(t.index, e) : e; yl(s, 5); let a = od(e, n, r, i), l = o.__ngNextListenerFn__; for (; l;)a = od(e, n, l, i) && a, l = l.__ngNextListenerFn__; return a } } function NO(t = 1) { return ky(t) } function qw(t, e) { let n = null, r = qg(t); for (let o = 0; o < e.length; o++) { let i = e[o]; if (i === "*") { n = o; continue } if (r === null ? Md(t, i, !0) : Qg(r, i)) return o } return n } function xO(t) { let e = S()[fe][he]; if (!e.projection) { let n = t ? t.length : 1, r = e.projection = kg(n, null), o = r.slice(), i = e.child; for (; i !== null;) { if (i.type !== 128) { let s = t ? qw(i, t) : 0; s !== null && (o[s] ? o[s].projectionNext = i : r[s] = i, o[s] = i) } i = i.next } } } function AO(t, e = 0, n, r, o, i) { let s = S(), a = H(), l = r ? t + 1 : null; l !== null && Ro(s, a, l, r, o, i, null, n); let u = Pn(a, Y + t, 16, null, n || null); u.projection === null && (u.projection = e), Qa(); let d = !s[Dn] || Jd(); s[fe][he].projection[u.projection] === null && l !== null ? Gw(s, a, l) : d && (u.flags & 32) !== 32 && lD(a, s, u) } function Gw(t, e, n) { let r = Y + n, o = e.data[r], i = t[r], s = Cn(i, o.tView.ssrId), a = ur(t, o, void 0, { dehydratedView: s }); cr(i, a, 0, In(o, s)) } function OO(t, e, n, r) { ME(t, e, n, r) } function PO(t, e, n) { SE(t, e, n) } function FO(t) { let e = S(), n = H(), r = tf(); Ya(r + 1); let o = vl(n, r); if (t.dirty && Dy(e) === ((o.metadata.flags & 2) === 2)) { if (o.matches === null) t.reset([]); else { let i = xE(e, r); t.reset(i, cv), t.notifyOnChanges() } return !0 } return !1 } function RO() { return CE(S(), tf()) } function Ww(t, e, n, r) { n >= t.data.length && (t.data[n] = null, t.blueprint[n] = null), e[n] = r } function kO(t) { let e = Ny(); return qa(e, Y + t) } function LO(t, e = "") { let n = S(), r = H(), o = t + Y, i = r.firstCreatePass ? Pn(r, o, 1, e, null) : r.data[o], s = Qw(r, n, i, e, t); n[o] = s, Ko() && ri(r, n, s, i), Qt(i, !1) } var Qw = (t, e, n, r, o) => (Yo(!0), Qv(e[z], r)); function Zw(t) { return Wh("", t, ""), Zw } function Wh(t, e, n) { let r = S(), o = ew(r, t, e, n); return o !== ve && ch(r, rt(), o), Wh } function Kw(t, e, n, r, o) { let i = S(), s = tw(i, t, e, n, r, o); return s !== ve && ch(i, rt(), s), Kw } function Yw(t, e, n) { Mh(e) && (e = e()); let r = S(), o = wt(); if (ye(r, o, e)) { let i = H(), s = ar(); si(i, s, r, t, e, r[z], n, !1) } return Yw } function jO(t, e) { let n = Mh(t); return n && t.set(e), n } function Jw(t, e) { let n = S(), r = H(), o = J(); return wl(r, n, n[z], o, t, e), Jw } function Xw(t, e, n) { let r = H(); if (r.firstCreatePass) { let o = Xe(t); _a(n, r.data, r.blueprint, o, !0), _a(e, r.data, r.blueprint, o, !1) } } function _a(t, e, n, r, o) { if (t = ee(t), Array.isArray(t)) for (let i = 0; i < t.length; i++)_a(t[i], e, n, r, o); else { let i = H(), s = S(), a = J(), l = vn(t) ? t : ee(t.provide), u = Ld(t), c = a.providerIndexes & 1048575, d = a.directiveStart, h = a.providerIndexes >> 20; if (vn(t) || !t.multi) { let f = new zt(u, o, ne), p = ys(l, e, o ? c : c + h, d); p === -1 ? (Os(bo(a, s), i, l), gs(i, t, e.length), e.push(l), a.directiveStart++, a.directiveEnd++, o && (a.providerIndexes += 1048576), n.push(f), s.push(f)) : (n[p] = f, s[p] = f) } else { let f = ys(l, e, c + h, d), p = ys(l, e, c, c + h), m = f >= 0 && n[f], D = p >= 0 && n[p]; if (o && !D || !o && !m) { Os(bo(a, s), i, l); let v = n_(o ? t_ : e_, n.length, o, r, u); !o && D && (n[p].providerFactory = v), gs(i, t, e.length, 0), e.push(l), a.directiveStart++, a.directiveEnd++, o && (a.providerIndexes += 1048576), n.push(v), s.push(v) } else { let v = Qh(n[o ? p : f], u, !o && r); gs(i, t, f > -1 ? f : p, v) } !o && r && D && n[p].componentProviders++ } } } function gs(t, e, n, r) { let o = vn(e), i = sy(e); if (o || i) { let l = (i ? ee(e.useClass) : e).prototype.ngOnDestroy; if (l) { let u = t.destroyHooks || (t.destroyHooks = []); if (!o && e.multi) { let c = u.indexOf(n); c === -1 ? u.push(n, [r, l]) : u[c + 1].push(r, l) } else u.push(n, l) } } } function Qh(t, e, n) { return n && t.componentProviders++, t.multi.push(e) - 1 } function ys(t, e, n, r) { for (let o = n; o < r; o++)if (e[o] === t) return o; return -1 } function e_(t, e, n, r) { return Ia(this.multi, []) } function t_(t, e, n, r) { let o = this.multi, i; if (this.providerFactory) { let s = this.providerFactory.componentProviders, a = qt(n, n[T], this.providerFactory.index, r); i = a.slice(0, s), Ia(o, i); for (let l = s; l < a.length; l++)i.push(a[l]) } else i = [], Ia(o, i); return i } function Ia(t, e) { for (let n = 0; n < t.length; n++) { let r = t[n]; e.push(r()) } return e } function n_(t, e, n, r, o) { let i = new zt(t, n, ne); return i.multi = [], i.index = e, i.componentProviders = 0, Qh(i, o, r && !n), i } function VO(t, e = []) { return n => { n.providersResolver = (r, o) => Xw(r, o ? o(t) : t, e) } } var r_ = (() => { class t { constructor(n) { this._injector = n, this.cachedInjectors = new Map } getOrCreateStandaloneInjector(n) { if (!n.standalone) return null; if (!this.cachedInjectors.has(n)) { let r = Pd(!1, n.type), o = r.length > 0 ? HE([r], this._injector, `Standalone[${n.type.name}]`) : null; this.cachedInjectors.set(n, o) } return this.cachedInjectors.get(n) } ngOnDestroy() { try { for (let n of this.cachedInjectors.values()) n !== null && n.destroy() } finally { this.cachedInjectors.clear() } } static { this.\u0275prov = $({ token: t, providedIn: "environment", factory: () => new t(de(mt)) }) } } return t })(); function BO(t) { It("NgStandalone"), t.getStandaloneInjector = e => e.get(r_).getOrCreateStandaloneInjector(t) } function $O(t, e, n) { let r = sr() + t, o = S(); return o[r] === ve ? El(o, r, n ? e.call(n) : e()) : zE(o, r) } function HO(t, e, n, r) { return Kh(S(), sr(), t, e, n, r) } function UO(t, e, n, r, o) { return Yh(S(), sr(), t, e, n, r, o) } function Zh(t, e) { let n = t[e]; return n === ve ? void 0 : n } function Kh(t, e, n, r, o, i) { let s = e + n; return ye(t, s, o) ? El(t, s + 1, i ? r.call(i, o) : r(o)) : Zh(t, s + 1) } function Yh(t, e, n, r, o, i, s) { let a = e + n; return xh(t, a, o, i) ? El(t, a + 2, s ? r.call(s, o, i) : r(o, i)) : Zh(t, a + 2) } function zO(t, e) { let n = H(), r, o = t + Y; n.firstCreatePass ? (r = o_(e, n.pipeRegistry), n.data[o] = r, r.onDestroy && (n.destroyHooks ??= []).push(o, r.onDestroy)) : r = n.data[o]; let i = r.factory || (r.factory = Vt(r.type, !0)), s, a = ue(ne); try { let l = Io(!1), u = i(); return Io(l), Ww(n, S(), o, u), u } finally { ue(a) } } function o_(t, e) { if (e) for (let n = e.length - 1; n >= 0; n--) { let r = e[n]; if (t === r.name) return r } } function qO(t, e, n) { let r = t + Y, o = S(), i = qa(o, r); return Jh(o, r) ? Kh(o, sr(), e, i.transform, n, i) : i.transform(n) } function GO(t, e, n, r) { let o = t + Y, i = S(), s = qa(i, o); return Jh(i, o) ? Yh(i, sr(), e, s.transform, n, r, s) : s.transform(n, r) } function Jh(t, e) { return t[T].data[e].pure } function WO(t, e) { return li(t, e) } var QO = (() => { class t { log(n) { console.log(n) } warn(n) { console.warn(n) } static { this.\u0275fac = function (r) { return new (r || t) } } static { this.\u0275prov = $({ token: t, factory: t.\u0275fac, providedIn: "platform" }) } } return t })(); var i_ = new V(""); function di(t) { return !!t && typeof t.then == "function" } function _l(t) { return !!t && typeof t.subscribe == "function" } var s_ = new V(""), Xh = (() => { class t { constructor() { this.initialized = !1, this.done = !1, this.donePromise = new Promise((n, r) => { this.resolve = n, this.reject = r }), this.appInits = R(s_, { optional: !0 }) ?? [] } runInitializers() { if (this.initialized) return; let n = []; for (let o of this.appInits) { let i = o(); if (di(i)) n.push(i); else if (_l(i)) { let s = new Promise((a, l) => { i.subscribe({ complete: a, error: l }) }); n.push(s) } } let r = () => { this.done = !0, this.resolve() }; Promise.all(n).then(() => { r() }).catch(o => { this.reject(o) }), n.length === 0 && r(), this.initialized = !0 } static { this.\u0275fac = function (r) { return new (r || t) } } static { this.\u0275prov = $({ token: t, factory: t.\u0275fac, providedIn: "root" }) } } return t })(), a_ = new V(""); function l_() { ku(() => { throw new g(600, !1) }) } function u_(t) { return t.isBoundToModule } var c_ = 10; function d_(t, e, n) { try { let r = n(); return di(r) ? r.catch(o => { throw e.runOutsideAngular(() => t.handleError(o)), o }) : r } catch (r) { throw e.runOutsideAngular(() => t.handleError(r)), r } } var fi = (() => { class t { constructor() { this._bootstrapListeners = [], this._runningTick = !1, this._destroyed = !1, this._destroyListeners = [], this._views = [], this.internalErrorHandler = R(lv), this.afterRenderManager = R(Ah), this.zonelessEnabled = R(Dh), this.dirtyFlags = 0, this.deferredDirtyFlags = 0, this.externalTestViews = new Set, this.beforeRender = new _e, this.afterTick = new _e, this.componentTypes = [], this.components = [], this.isStable = R(Xo).hasPendingTasks.pipe(je(n => !n)), this._injector = R(mt) } get allViews() { return [...this.externalTestViews.keys(), ...this._views] } get destroyed() { return this._destroyed } whenStable() { let n; return new Promise(r => { n = this.isStable.subscribe({ next: o => { o && r() } }) }).finally(() => { n.unsubscribe() }) } get injector() { return this._injector } bootstrap(n, r) { let o = n instanceof No; if (!this._injector.get(Xh).done) { let h = !o && ey(n), f = !1; throw new g(405, f) } let s; o ? s = n : s = this._injector.get(Mn).resolveComponentFactory(n), this.componentTypes.push(s.componentType); let a = u_(s) ? void 0 : this._injector.get(Dt), l = r || s.selector, u = s.create(yt.NULL, [], l, a), c = u.location.nativeElement, d = u.injector.get(i_, null); return d?.registerApplication(c), u.onDestroy(() => { this.detachView(u.hostView), co(this.components, u), d?.unregisterApplication(c) }), this._loadComponent(u), u } tick() { this.zonelessEnabled || (this.dirtyFlags |= 1), this._tick() } _tick() { if (this._runningTick) throw new g(101, !1); let n = A(null); try { this._runningTick = !0, this.synchronize() } catch (r) { this.internalErrorHandler(r) } finally { this._runningTick = !1, A(n), this.afterTick.next() } } synchronize() { let n = null; this._injector.destroyed || (n = this._injector.get(xo, null, { optional: !0 })), this.dirtyFlags |= this.deferredDirtyFlags, this.deferredDirtyFlags = 0; let r = 0; for (; this.dirtyFlags !== 0 && r++ < c_;)this.synchronizeOnce(n) } synchronizeOnce(n) { if (this.dirtyFlags |= this.deferredDirtyFlags, this.deferredDirtyFlags = 0, this.dirtyFlags & 7) { let r = !!(this.dirtyFlags & 1); this.dirtyFlags &= -8, this.dirtyFlags |= 8, this.beforeRender.next(r); for (let { _lView: o, notifyErrorHandler: i } of this._views) f_(o, i, r, this.zonelessEnabled); if (this.dirtyFlags &= -5, this.syncDirtyFlagsWithViews(), this.dirtyFlags & 7) return } else n?.begin?.(), n?.end?.(); this.dirtyFlags & 8 && (this.dirtyFlags &= -9, this.afterRenderManager.execute()), this.syncDirtyFlagsWithViews() } syncDirtyFlagsWithViews() { if (this.allViews.some(({ _lView: n }) => Qo(n))) { this.dirtyFlags |= 2; return } else this.dirtyFlags &= -8 } attachView(n) { let r = n; this._views.push(r), r.attachToAppRef(this) } detachView(n) { let r = n; co(this._views, r), r.detachFromAppRef() } _loadComponent(n) { this.attachView(n.hostView), this.tick(), this.components.push(n); let r = this._injector.get(a_, []);[...this._bootstrapListeners, ...r].forEach(o => o(n)) } ngOnDestroy() { if (!this._destroyed) try { this._destroyListeners.forEach(n => n()), this._views.slice().forEach(n => n.destroy()) } finally { this._destroyed = !0, this._views = [], this._bootstrapListeners = [], this._destroyListeners = [] } } onDestroy(n) { return this._destroyListeners.push(n), () => co(this._destroyListeners, n) } destroy() { if (this._destroyed) throw new g(406, !1); let n = this._injector; n.destroy && !n.destroyed && n.destroy() } get viewCount() { return this._views.length } warnIfDestroyed() { } static { this.\u0275fac = function (r) { return new (r || t) } } static { this.\u0275prov = $({ token: t, factory: t.\u0275fac, providedIn: "root" }) } } return t })(); function co(t, e) { let n = t.indexOf(e); n > -1 && t.splice(n, 1) } function f_(t, e, n, r) { if (!n && !Qo(t)) return; mh(t, e, n && !r ? 0 : 1) } var ba = class { constructor(e, n) { this.ngModuleFactory = e, this.componentFactories = n } }, ZO = (() => { class t { compileModuleSync(n) { return new ca(n) } compileModuleAsync(n) { return Promise.resolve(this.compileModuleSync(n)) } compileModuleAndAllComponentsSync(n) { let r = this.compileModuleSync(n), o = xd(n), i = jf(o.declarations).reduce((s, a) => { let l = pt(a); return l && s.push(new Tn(l)), s }, []); return new ba(r, i) } compileModuleAndAllComponentsAsync(n) { return Promise.resolve(this.compileModuleAndAllComponentsSync(n)) } clearCache() { } clearCacheFor(n) { } getModuleId(n) { } static { this.\u0275fac = function (r) { return new (r || t) } } static { this.\u0275prov = $({ token: t, factory: t.\u0275fac, providedIn: "root" }) } } return t })(); var h_ = (() => { class t { constructor() { this.zone = R(ge), this.changeDetectionScheduler = R(Sn), this.applicationRef = R(fi) } initialize() { this._onMicrotaskEmptySubscription || (this._onMicrotaskEmptySubscription = this.zone.onMicrotaskEmpty.subscribe({ next: () => { this.changeDetectionScheduler.runningTick || this.zone.run(() => { this.applicationRef.tick() }) } })) } ngOnDestroy() { this._onMicrotaskEmptySubscription?.unsubscribe() } static { this.\u0275fac = function (r) { return new (r || t) } } static { this.\u0275prov = $({ token: t, factory: t.\u0275fac, providedIn: "root" }) } } return t })(); function p_({ ngZoneFactory: t, ignoreChangesOutsideZone: e, scheduleInRootZone: n }) { return t ??= () => new ge(We(me({}, m_()), { scheduleInRootZone: n })), [{ provide: ge, useFactory: t }, { provide: go, multi: !0, useFactory: () => { let r = R(h_, { optional: !0 }); return () => r.initialize() } }, { provide: go, multi: !0, useFactory: () => { let r = R(g_); return () => { r.initialize() } } }, e === !0 ? { provide: Eh, useValue: !0 } : [], { provide: wh, useValue: n ?? Ef }] } function m_(t) { return { enableLongStackTrace: !1, shouldCoalesceEventChangeDetection: t?.eventCoalescing ?? !1, shouldCoalesceRunChangeDetection: t?.runCoalescing ?? !1 } } var g_ = (() => { class t { constructor() { this.subscription = new W, this.initialized = !1, this.zone = R(ge), this.pendingTasks = R(Xo) } initialize() { if (this.initialized) return; this.initialized = !0; let n = null; !this.zone.isStable && !this.zone.hasPendingMacrotasks && !this.zone.hasPendingMicrotasks && (n = this.pendingTasks.add()), this.zone.runOutsideAngular(() => { this.subscription.add(this.zone.onStable.subscribe(() => { ge.assertNotInAngularZone(), queueMicrotask(() => { n !== null && !this.zone.hasPendingMacrotasks && !this.zone.hasPendingMicrotasks && (this.pendingTasks.remove(n), n = null) }) })) }), this.subscription.add(this.zone.onUnstable.subscribe(() => { ge.assertInAngularZone(), n ??= this.pendingTasks.add() })) } ngOnDestroy() { this.subscription.unsubscribe() } static { this.\u0275fac = function (r) { return new (r || t) } } static { this.\u0275prov = $({ token: t, factory: t.\u0275fac, providedIn: "root" }) } } return t })(); var y_ = (() => { class t { constructor() { this.appRef = R(fi), this.taskService = R(Xo), this.ngZone = R(ge), this.zonelessEnabled = R(Dh), this.disableScheduling = R(Eh, { optional: !0 }) ?? !1, this.zoneIsDefined = typeof Zone < "u" && !!Zone.root.run, this.schedulerTickApplyArgs = [{ data: { __scheduler_tick__: !0 } }], this.subscriptions = new W, this.angularZoneId = this.zoneIsDefined ? this.ngZone._inner?.get(So) : null, this.scheduleInRootZone = !this.zonelessEnabled && this.zoneIsDefined && (R(wh, { optional: !0 }) ?? !1), this.cancelScheduledCallback = null, this.useMicrotaskScheduler = !1, this.runningTick = !1, this.pendingRenderTaskId = null, this.subscriptions.add(this.appRef.afterTick.subscribe(() => { this.runningTick || this.cleanup() })), this.subscriptions.add(this.ngZone.onUnstable.subscribe(() => { this.runningTick || this.cleanup() })), this.disableScheduling ||= !this.zonelessEnabled && (this.ngZone instanceof Ls || !this.zoneIsDefined) } notify(n) { if (!this.zonelessEnabled && n === 5) return; switch (n) { case 0: { this.appRef.dirtyFlags |= 2; break } case 3: case 2: case 4: case 5: case 1: { this.appRef.dirtyFlags |= 4; break } case 7: { this.appRef.deferredDirtyFlags |= 8; break } case 9: case 8: case 6: case 10: default: this.appRef.dirtyFlags |= 8 }if (!this.shouldScheduleTick()) return; let r = this.useMicrotaskScheduler ? Fc : wf; this.pendingRenderTaskId = this.taskService.add(), this.scheduleInRootZone ? this.cancelScheduledCallback = Zone.root.run(() => r(() => this.tick())) : this.cancelScheduledCallback = this.ngZone.runOutsideAngular(() => r(() => this.tick())) } shouldScheduleTick() { return !(this.disableScheduling || this.pendingRenderTaskId !== null || this.runningTick || this.appRef._runningTick || !this.zonelessEnabled && this.zoneIsDefined && Zone.current.get(So + this.angularZoneId)) } tick() { if (this.runningTick || this.appRef.destroyed) return; !this.zonelessEnabled && this.appRef.dirtyFlags & 7 && (this.appRef.dirtyFlags |= 1); let n = this.taskService.add(); try { this.ngZone.run(() => { this.runningTick = !0, this.appRef._tick() }, void 0, this.schedulerTickApplyArgs) } catch (r) { throw this.taskService.remove(n), r } finally { this.cleanup() } this.useMicrotaskScheduler = !0, Fc(() => { this.useMicrotaskScheduler = !1, this.taskService.remove(n) }) } ngOnDestroy() { this.subscriptions.unsubscribe(), this.cleanup() } cleanup() { if (this.runningTick = !1, this.cancelScheduledCallback?.(), this.cancelScheduledCallback = null, this.pendingRenderTaskId !== null) { let n = this.pendingRenderTaskId; this.pendingRenderTaskId = null, this.taskService.remove(n) } } static { this.\u0275fac = function (r) { return new (r || t) } } static { this.\u0275prov = $({ token: t, factory: t.\u0275fac, providedIn: "root" }) } } return t })(); function v_() { return typeof $localize < "u" && $localize.locale || Vo } var dr = new V("", { providedIn: "root", factory: () => R(dr, O.Optional | O.SkipSelf) || v_() }), ep = new V("", { providedIn: "root", factory: () => jw }); var Ca = new V(""); function io(t) { return !t.moduleRef } function D_(t) { let e = io(t) ? t.r3Injector : t.moduleRef.injector, n = e.get(ge); return n.run(() => { io(t) ? t.r3Injector.resolveInjectorInitializers() : t.moduleRef.resolveInjectorInitializers(); let r = e.get(_n, null), o; if (n.runOutsideAngular(() => { o = n.onError.subscribe({ next: i => { r.handleError(i) } }) }), io(t)) { let i = () => e.destroy(), s = t.platformInjector.get(Ca); s.add(i), e.onDestroy(() => { o.unsubscribe(), s.delete(i) }) } else { let i = () => t.moduleRef.destroy(), s = t.platformInjector.get(Ca); s.add(i), t.moduleRef.onDestroy(() => { co(t.allPlatformModules, t.moduleRef), o.unsubscribe(), s.delete(i) }) } return d_(r, n, () => { let i = e.get(Xh); return i.runInitializers(), i.donePromise.then(() => { let s = e.get(dr, Vo); if (Bw(s || Vo), io(t)) { let a = e.get(fi); return t.rootComponent !== void 0 && a.bootstrap(t.rootComponent), a } else return E_(t.moduleRef, t.allPlatformModules), t.moduleRef }) }) }) } function E_(t, e) { let n = t.injector.get(fi); if (t._bootstrapComponents.length > 0) t._bootstrapComponents.forEach(r => n.bootstrap(r)); else if (t.instance.ngDoBootstrap) t.instance.ngDoBootstrap(n); else throw new g(-403, !1); e.push(t) } var fo = null; function w_(t = [], e) { return yt.create({ name: e, providers: [{ provide: kd, useValue: "platform" }, { provide: Ca, useValue: new Set([() => fo = null]) }, ...t] }) } function __(t = []) { if (fo) return fo; let e = w_(t); return fo = e, l_(), I_(e), e } function I_(t) { t.get(gv, null)?.forEach(n => n()) } function KO() { return !1 } var Il = (() => { class t { static { this.__NG_ELEMENT_ID__ = b_ } } return t })(); function b_(t) { return C_(J(), S(), (t & 16) === 16) } function C_(t, e, n) { if (Go(t) && !n) { let r = Et(t.index, e); return new Gt(r, r) } else if (t.type & 175) { let r = e[fe]; return new Gt(r, e) } return null } var Sa = class { constructor() { } supports(e) { return Nh(e) } create(e) { return new Ma(e) } }, S_ = (t, e) => e, Ma = class { constructor(e) { this.length = 0, this._linkedRecords = null, this._unlinkedRecords = null, this._previousItHead = null, this._itHead = null, this._itTail = null, this._additionsHead = null, this._additionsTail = null, this._movesHead = null, this._movesTail = null, this._removalsHead = null, this._removalsTail = null, this._identityChangesHead = null, this._identityChangesTail = null, this._trackByFn = e || S_ } forEachItem(e) { let n; for (n = this._itHead; n !== null; n = n._next)e(n) } forEachOperation(e) { let n = this._itHead, r = this._removalsHead, o = 0, i = null; for (; n || r;) { let s = !r || n && n.currentIndex < sd(r, o, i) ? n : r, a = sd(s, o, i), l = s.currentIndex; if (s === r) o--, r = r._nextRemoved; else if (n = n._next, s.previousIndex == null) o++; else { i || (i = []); let u = a - o, c = l - o; if (u != c) { for (let h = 0; h < u; h++) { let f = h < i.length ? i[h] : i[h] = 0, p = f + h; c <= p && p < u && (i[h] = f + 1) } let d = s.previousIndex; i[d] = c - u } } a !== l && e(s, a, l) } } forEachPreviousItem(e) { let n; for (n = this._previousItHead; n !== null; n = n._nextPrevious)e(n) } forEachAddedItem(e) { let n; for (n = this._additionsHead; n !== null; n = n._nextAdded)e(n) } forEachMovedItem(e) { let n; for (n = this._movesHead; n !== null; n = n._nextMoved)e(n) } forEachRemovedItem(e) { let n; for (n = this._removalsHead; n !== null; n = n._nextRemoved)e(n) } forEachIdentityChange(e) { let n; for (n = this._identityChangesHead; n !== null; n = n._nextIdentityChange)e(n) } diff(e) { if (e == null && (e = []), !Nh(e)) throw new g(900, !1); return this.check(e) ? this : null } onDestroy() { } check(e) { this._reset(); let n = this._itHead, r = !1, o, i, s; if (Array.isArray(e)) { this.length = e.length; for (let a = 0; a < this.length; a++)i = e[a], s = this._trackByFn(a, i), n === null || !Object.is(n.trackById, s) ? (n = this._mismatch(n, i, s, a), r = !0) : (r && (n = this._verifyReinsertion(n, i, s, a)), Object.is(n.item, i) || this._addIdentityChange(n, i)), n = n._next } else o = 0, UE(e, a => { s = this._trackByFn(o, a), n === null || !Object.is(n.trackById, s) ? (n = this._mismatch(n, a, s, o), r = !0) : (r && (n = this._verifyReinsertion(n, a, s, o)), Object.is(n.item, a) || this._addIdentityChange(n, a)), n = n._next, o++ }), this.length = o; return this._truncate(n), this.collection = e, this.isDirty } get isDirty() { return this._additionsHead !== null || this._movesHead !== null || this._removalsHead !== null || this._identityChangesHead !== null } _reset() { if (this.isDirty) { let e; for (e = this._previousItHead = this._itHead; e !== null; e = e._next)e._nextPrevious = e._next; for (e = this._additionsHead; e !== null; e = e._nextAdded)e.previousIndex = e.currentIndex; for (this._additionsHead = this._additionsTail = null, e = this._movesHead; e !== null; e = e._nextMoved)e.previousIndex = e.currentIndex; this._movesHead = this._movesTail = null, this._removalsHead = this._removalsTail = null, this._identityChangesHead = this._identityChangesTail = null } } _mismatch(e, n, r, o) { let i; return e === null ? i = this._itTail : (i = e._prev, this._remove(e)), e = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(r, null), e !== null ? (Object.is(e.item, n) || this._addIdentityChange(e, n), this._reinsertAfter(e, i, o)) : (e = this._linkedRecords === null ? null : this._linkedRecords.get(r, o), e !== null ? (Object.is(e.item, n) || this._addIdentityChange(e, n), this._moveAfter(e, i, o)) : e = this._addAfter(new Ta(n, r), i, o)), e } _verifyReinsertion(e, n, r, o) { let i = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(r, null); return i !== null ? e = this._reinsertAfter(i, e._prev, o) : e.currentIndex != o && (e.currentIndex = o, this._addToMoves(e, o)), e } _truncate(e) { for (; e !== null;) { let n = e._next; this._addToRemovals(this._unlink(e)), e = n } this._unlinkedRecords !== null && this._unlinkedRecords.clear(), this._additionsTail !== null && (this._additionsTail._nextAdded = null), this._movesTail !== null && (this._movesTail._nextMoved = null), this._itTail !== null && (this._itTail._next = null), this._removalsTail !== null && (this._removalsTail._nextRemoved = null), this._identityChangesTail !== null && (this._identityChangesTail._nextIdentityChange = null) } _reinsertAfter(e, n, r) { this._unlinkedRecords !== null && this._unlinkedRecords.remove(e); let o = e._prevRemoved, i = e._nextRemoved; return o === null ? this._removalsHead = i : o._nextRemoved = i, i === null ? this._removalsTail = o : i._prevRemoved = o, this._insertAfter(e, n, r), this._addToMoves(e, r), e } _moveAfter(e, n, r) { return this._unlink(e), this._insertAfter(e, n, r), this._addToMoves(e, r), e } _addAfter(e, n, r) { return this._insertAfter(e, n, r), this._additionsTail === null ? this._additionsTail = this._additionsHead = e : this._additionsTail = this._additionsTail._nextAdded = e, e } _insertAfter(e, n, r) { let o = n === null ? this._itHead : n._next; return e._next = o, e._prev = n, o === null ? this._itTail = e : o._prev = e, n === null ? this._itHead = e : n._next = e, this._linkedRecords === null && (this._linkedRecords = new Bo), this._linkedRecords.put(e), e.currentIndex = r, e } _remove(e) { return this._addToRemovals(this._unlink(e)) } _unlink(e) { this._linkedRecords !== null && this._linkedRecords.remove(e); let n = e._prev, r = e._next; return n === null ? this._itHead = r : n._next = r, r === null ? this._itTail = n : r._prev = n, e } _addToMoves(e, n) { return e.previousIndex === n || (this._movesTail === null ? this._movesTail = this._movesHead = e : this._movesTail = this._movesTail._nextMoved = e), e } _addToRemovals(e) { return this._unlinkedRecords === null && (this._unlinkedRecords = new Bo), this._unlinkedRecords.put(e), e.currentIndex = null, e._nextRemoved = null, this._removalsTail === null ? (this._removalsTail = this._removalsHead = e, e._prevRemoved = null) : (e._prevRemoved = this._removalsTail, this._removalsTail = this._removalsTail._nextRemoved = e), e } _addIdentityChange(e, n) { return e.item = n, this._identityChangesTail === null ? this._identityChangesTail = this._identityChangesHead = e : this._identityChangesTail = this._identityChangesTail._nextIdentityChange = e, e } }, Ta = class { constructor(e, n) { this.item = e, this.trackById = n, this.currentIndex = null, this.previousIndex = null, this._nextPrevious = null, this._prev = null, this._next = null, this._prevDup = null, this._nextDup = null, this._prevRemoved = null, this._nextRemoved = null, this._nextAdded = null, this._nextMoved = null, this._nextIdentityChange = null } }, Na = class { constructor() { this._head = null, this._tail = null } add(e) { this._head === null ? (this._head = this._tail = e, e._nextDup = null, e._prevDup = null) : (this._tail._nextDup = e, e._prevDup = this._tail, e._nextDup = null, this._tail = e) } get(e, n) { let r; for (r = this._head; r !== null; r = r._nextDup)if ((n === null || n <= r.currentIndex) && Object.is(r.trackById, e)) return r; return null } remove(e) { let n = e._prevDup, r = e._nextDup; return n === null ? this._head = r : n._nextDup = r, r === null ? this._tail = n : r._prevDup = n, this._head === null } }, Bo = class { constructor() { this.map = new Map } put(e) { let n = e.trackById, r = this.map.get(n); r || (r = new Na, this.map.set(n, r)), r.add(e) } get(e, n) { let r = e, o = this.map.get(r); return o ? o.get(e, n) : null } remove(e) { let n = e.trackById; return this.map.get(n).remove(e) && this.map.delete(n), e } get isEmpty() { return this.map.size === 0 } clear() { this.map.clear() } }; function sd(t, e, n) { let r = t.previousIndex; if (r === null) return r; let o = 0; return n && r < n.length && (o = n[r]), r + e + o } var xa = class { constructor() { } supports(e) { return e instanceof Map || Dl(e) } create() { return new Aa } }, Aa = class { constructor() { this._records = new Map, this._mapHead = null, this._appendAfter = null, this._previousMapHead = null, this._changesHead = null, this._changesTail = null, this._additionsHead = null, this._additionsTail = null, this._removalsHead = null, this._removalsTail = null } get isDirty() { return this._additionsHead !== null || this._changesHead !== null || this._removalsHead !== null } forEachItem(e) { let n; for (n = this._mapHead; n !== null; n = n._next)e(n) } forEachPreviousItem(e) { let n; for (n = this._previousMapHead; n !== null; n = n._nextPrevious)e(n) } forEachChangedItem(e) { let n; for (n = this._changesHead; n !== null; n = n._nextChanged)e(n) } forEachAddedItem(e) { let n; for (n = this._additionsHead; n !== null; n = n._nextAdded)e(n) } forEachRemovedItem(e) { let n; for (n = this._removalsHead; n !== null; n = n._nextRemoved)e(n) } diff(e) { if (!e) e = new Map; else if (!(e instanceof Map || Dl(e))) throw new g(900, !1); return this.check(e) ? this : null } onDestroy() { } check(e) { this._reset(); let n = this._mapHead; if (this._appendAfter = null, this._forEach(e, (r, o) => { if (n && n.key === o) this._maybeAddToChanges(n, r), this._appendAfter = n, n = n._next; else { let i = this._getOrCreateRecordForKey(o, r); n = this._insertBeforeOrAppend(n, i) } }), n) { n._prev && (n._prev._next = null), this._removalsHead = n; for (let r = n; r !== null; r = r._nextRemoved)r === this._mapHead && (this._mapHead = null), this._records.delete(r.key), r._nextRemoved = r._next, r.previousValue = r.currentValue, r.currentValue = null, r._prev = null, r._next = null } return this._changesTail && (this._changesTail._nextChanged = null), this._additionsTail && (this._additionsTail._nextAdded = null), this.isDirty } _insertBeforeOrAppend(e, n) { if (e) { let r = e._prev; return n._next = e, n._prev = r, e._prev = n, r && (r._next = n), e === this._mapHead && (this._mapHead = n), this._appendAfter = e, e } return this._appendAfter ? (this._appendAfter._next = n, n._prev = this._appendAfter) : this._mapHead = n, this._appendAfter = n, null } _getOrCreateRecordForKey(e, n) { if (this._records.has(e)) { let o = this._records.get(e); this._maybeAddToChanges(o, n); let i = o._prev, s = o._next; return i && (i._next = s), s && (s._prev = i), o._next = null, o._prev = null, o } let r = new Oa(e); return this._records.set(e, r), r.currentValue = n, this._addToAdditions(r), r } _reset() { if (this.isDirty) { let e; for (this._previousMapHead = this._mapHead, e = this._previousMapHead; e !== null; e = e._next)e._nextPrevious = e._next; for (e = this._changesHead; e !== null; e = e._nextChanged)e.previousValue = e.currentValue; for (e = this._additionsHead; e != null; e = e._nextAdded)e.previousValue = e.currentValue; this._changesHead = this._changesTail = null, this._additionsHead = this._additionsTail = null, this._removalsHead = null } } _maybeAddToChanges(e, n) { Object.is(n, e.currentValue) || (e.previousValue = e.currentValue, e.currentValue = n, this._addToChanges(e)) } _addToAdditions(e) { this._additionsHead === null ? this._additionsHead = this._additionsTail = e : (this._additionsTail._nextAdded = e, this._additionsTail = e) } _addToChanges(e) { this._changesHead === null ? this._changesHead = this._changesTail = e : (this._changesTail._nextChanged = e, this._changesTail = e) } _forEach(e, n) { e instanceof Map ? e.forEach(n) : Object.keys(e).forEach(r => n(e[r], r)) } }, Oa = class { constructor(e) { this.key = e, this.previousValue = null, this.currentValue = null, this._nextPrevious = null, this._next = null, this._prev = null, this._nextAdded = null, this._nextRemoved = null, this._nextChanged = null } }; function ad() { return new tp([new Sa]) } var tp = (() => { class t { static { this.\u0275prov = $({ token: t, providedIn: "root", factory: ad }) } constructor(n) { this.factories = n } static create(n, r) { if (r != null) { let o = r.factories.slice(); n = n.concat(o) } return new t(n) } static extend(n) { return { provide: t, useFactory: r => t.create(n, r || ad()), deps: [[t, new Ed, new Dd]] } } find(n) { let r = this.factories.find(o => o.supports(n)); if (r != null) return r; throw new g(901, !1) } } return t })(); function ld() { return new bl([new xa]) } var bl = (() => { class t { static { this.\u0275prov = $({ token: t, providedIn: "root", factory: ld }) } constructor(n) { this.factories = n } static create(n, r) { if (r) { let o = r.factories.slice(); n = n.concat(o) } return new t(n) } static extend(n) { return { provide: t, useFactory: r => t.create(n, r || ld()), deps: [[t, new Ed, new Dd]] } } find(n) { let r = this.factories.find(o => o.supports(n)); if (r) return r; throw new g(901, !1) } } return t })(); function YO(t) { try { let { rootComponent: e, appProviders: n, platformProviders: r } = t, o = __(r), i = [p_({}), { provide: Sn, useExisting: y_ }, ...n || []], s = new Fo({ providers: i, parent: o, debugName: "", runEnvironmentInitializers: !1 }); return D_({ r3Injector: s.injector, platformInjector: o, rootComponent: e }) } catch (e) { return Promise.reject(e) } } function M_(t) { return typeof t == "boolean" ? t : t != null && t !== "false" } function T_(t, e = NaN) { return !isNaN(parseFloat(t)) && !isNaN(Number(t)) ? Number(t) : e } function JO(t, e) { It("NgSignals"); let n = Pu(t); return e?.equal && (n[Qe].equal = e.equal), n } function Cl(t) { let e = A(null); try { return t() } finally { A(e) } } function XO(t, e) { let n = pt(t), r = e.elementInjector || zo(); return new Tn(n).create(r, e.projectableNodes, e.hostElement, e.environmentInjector) } var dp = null; function Sl() { return dp } function DP(t) { dp ??= t } var rp = class { }; var fp = new V(""), hp = (() => { class t { historyGo(n) { throw new Error("") } static { this.\u0275fac = function (r) { return new (r || t) } } static { this.\u0275prov = $({ token: t, factory: () => R(N_), providedIn: "platform" }) } } return t })(); var N_ = (() => { class t extends hp { constructor() { super(), this._doc = R(fp), this._location = window.location, this._history = window.history } getBaseHrefFromDOM() { return Sl().getBaseHref(this._doc) } onPopState(n) { let r = Sl().getGlobalEventTarget(this._doc, "window"); return r.addEventListener("popstate", n, !1), () => r.removeEventListener("popstate", n) } onHashChange(n) { let r = Sl().getGlobalEventTarget(this._doc, "window"); return r.addEventListener("hashchange", n, !1), () => r.removeEventListener("hashchange", n) } get href() { return this._location.href } get protocol() { return this._location.protocol } get hostname() { return this._location.hostname } get port() { return this._location.port } get pathname() { return this._location.pathname } get search() { return this._location.search } get hash() { return this._location.hash } set pathname(n) { this._location.pathname = n } pushState(n, r, o) { this._history.pushState(n, r, o) } replaceState(n, r, o) { this._history.replaceState(n, r, o) } forward() { this._history.forward() } back() { this._history.back() } historyGo(n = 0) { this._history.go(n) } getState() { return this._history.state } static { this.\u0275fac = function (r) { return new (r || t) } } static { this.\u0275prov = $({ token: t, factory: () => new t, providedIn: "platform" }) } } return t })(); function pp(t, e) { if (t.length == 0) return e; if (e.length == 0) return t; let n = 0; return t.endsWith("/") && n++, e.startsWith("/") && n++, n == 2 ? t + e.substring(1) : n == 1 ? t + e : t + "/" + e } function op(t) { let e = t.match(/#|\?|$/), n = e && e.index || t.length, r = n - (t[n - 1] === "/" ? 1 : 0); return t.slice(0, r) + t.slice(n) } function Zt(t) { return t && t[0] !== "?" ? "?" + t : t } var Pl = (() => { class t { historyGo(n) { throw new Error("") } static { this.\u0275fac = function (r) { return new (r || t) } } static { this.\u0275prov = $({ token: t, factory: () => R(A_), providedIn: "root" }) } } return t })(), x_ = new V(""), A_ = (() => { class t extends Pl { constructor(n, r) { super(), this._platformLocation = n, this._removeListenerFns = [], this._baseHref = r ?? this._platformLocation.getBaseHrefFromDOM() ?? R(fp).location?.origin ?? "" } ngOnDestroy() { for (; this._removeListenerFns.length;)this._removeListenerFns.pop()() } onPopState(n) { this._removeListenerFns.push(this._platformLocation.onPopState(n), this._platformLocation.onHashChange(n)) } getBaseHref() { return this._baseHref } prepareExternalUrl(n) { return pp(this._baseHref, n) } path(n = !1) { let r = this._platformLocation.pathname + Zt(this._platformLocation.search), o = this._platformLocation.hash; return o && n ? `${r}${o}` : r } pushState(n, r, o, i) { let s = this.prepareExternalUrl(o + Zt(i)); this._platformLocation.pushState(n, r, s) } replaceState(n, r, o, i) { let s = this.prepareExternalUrl(o + Zt(i)); this._platformLocation.replaceState(n, r, s) } forward() { this._platformLocation.forward() } back() { this._platformLocation.back() } getState() { return this._platformLocation.getState() } historyGo(n = 0) { this._platformLocation.historyGo?.(n) } static { this.\u0275fac = function (r) { return new (r || t)(de(hp), de(x_, 8)) } } static { this.\u0275prov = $({ token: t, factory: t.\u0275fac, providedIn: "root" }) } } return t })(); var O_ = (() => { class t { constructor(n) { this._subject = new Oe, this._urlChangeListeners = [], this._urlChangeSubscription = null, this._locationStrategy = n; let r = this._locationStrategy.getBaseHref(); this._basePath = R_(op(ip(r))), this._locationStrategy.onPopState(o => { this._subject.emit({ url: this.path(!0), pop: !0, state: o.state, type: o.type }) }) } ngOnDestroy() { this._urlChangeSubscription?.unsubscribe(), this._urlChangeListeners = [] } path(n = !1) { return this.normalize(this._locationStrategy.path(n)) } getState() { return this._locationStrategy.getState() } isCurrentPathEqualTo(n, r = "") { return this.path() == this.normalize(n + Zt(r)) } normalize(n) { return t.stripTrailingSlash(F_(this._basePath, ip(n))) } prepareExternalUrl(n) { return n && n[0] !== "/" && (n = "/" + n), this._locationStrategy.prepareExternalUrl(n) } go(n, r = "", o = null) { this._locationStrategy.pushState(o, "", n, r), this._notifyUrlChangeListeners(this.prepareExternalUrl(n + Zt(r)), o) } replaceState(n, r = "", o = null) { this._locationStrategy.replaceState(o, "", n, r), this._notifyUrlChangeListeners(this.prepareExternalUrl(n + Zt(r)), o) } forward() { this._locationStrategy.forward() } back() { this._locationStrategy.back() } historyGo(n = 0) { this._locationStrategy.historyGo?.(n) } onUrlChange(n) { return this._urlChangeListeners.push(n), this._urlChangeSubscription ??= this.subscribe(r => { this._notifyUrlChangeListeners(r.url, r.state) }), () => { let r = this._urlChangeListeners.indexOf(n); this._urlChangeListeners.splice(r, 1), this._urlChangeListeners.length === 0 && (this._urlChangeSubscription?.unsubscribe(), this._urlChangeSubscription = null) } } _notifyUrlChangeListeners(n = "", r) { this._urlChangeListeners.forEach(o => o(n, r)) } subscribe(n, r, o) { return this._subject.subscribe({ next: n, error: r, complete: o }) } static { this.normalizeQueryParams = Zt } static { this.joinWithSlash = pp } static { this.stripTrailingSlash = op } static { this.\u0275fac = function (r) { return new (r || t)(de(Pl)) } } static { this.\u0275prov = $({ token: t, factory: () => P_(), providedIn: "root" }) } } return t })(); function P_() { return new O_(de(Pl)) } function F_(t, e) { if (!t || !e.startsWith(t)) return e; let n = e.substring(t.length); return n === "" || ["/", ";", "?", "#"].includes(n[0]) ? n : e } function ip(t) { return t.replace(/\/index.html$/, "") } function R_(t) { if (new RegExp("^(https?:)?//").test(t)) { let [, n] = t.split(/\/\/[^\/]+/); return n } return t } var mp = { ADP: [void 0, void 0, 0], AFN: [void 0, "\u060B", 0], ALL: [void 0, void 0, 0], AMD: [void 0, "\u058F", 2], AOA: [void 0, "Kz"], ARS: [void 0, "$"], AUD: ["A$", "$"], AZN: [void 0, "\u20BC"], BAM: [void 0, "KM"], BBD: [void 0, "$"], BDT: [void 0, "\u09F3"], BHD: [void 0, void 0, 3], BIF: [void 0, void 0, 0], BMD: [void 0, "$"], BND: [void 0, "$"], BOB: [void 0, "Bs"], BRL: ["R$"], BSD: [void 0, "$"], BWP: [void 0, "P"], BYN: [void 0, void 0, 2], BYR: [void 0, void 0, 0], BZD: [void 0, "$"], CAD: ["CA$", "$", 2], CHF: [void 0, void 0, 2], CLF: [void 0, void 0, 4], CLP: [void 0, "$", 0], CNY: ["CN\xA5", "\xA5"], COP: [void 0, "$", 2], CRC: [void 0, "\u20A1", 2], CUC: [void 0, "$"], CUP: [void 0, "$"], CZK: [void 0, "K\u010D", 2], DJF: [void 0, void 0, 0], DKK: [void 0, "kr", 2], DOP: [void 0, "$"], EGP: [void 0, "E\xA3"], ESP: [void 0, "\u20A7", 0], EUR: ["\u20AC"], FJD: [void 0, "$"], FKP: [void 0, "\xA3"], GBP: ["\xA3"], GEL: [void 0, "\u20BE"], GHS: [void 0, "GH\u20B5"], GIP: [void 0, "\xA3"], GNF: [void 0, "FG", 0], GTQ: [void 0, "Q"], GYD: [void 0, "$", 2], HKD: ["HK$", "$"], HNL: [void 0, "L"], HRK: [void 0, "kn"], HUF: [void 0, "Ft", 2], IDR: [void 0, "Rp", 2], ILS: ["\u20AA"], INR: ["\u20B9"], IQD: [void 0, void 0, 0], IRR: [void 0, void 0, 0], ISK: [void 0, "kr", 0], ITL: [void 0, void 0, 0], JMD: [void 0, "$"], JOD: [void 0, void 0, 3], JPY: ["\xA5", void 0, 0], KHR: [void 0, "\u17DB"], KMF: [void 0, "CF", 0], KPW: [void 0, "\u20A9", 0], KRW: ["\u20A9", void 0, 0], KWD: [void 0, void 0, 3], KYD: [void 0, "$"], KZT: [void 0, "\u20B8"], LAK: [void 0, "\u20AD", 0], LBP: [void 0, "L\xA3", 0], LKR: [void 0, "Rs"], LRD: [void 0, "$"], LTL: [void 0, "Lt"], LUF: [void 0, void 0, 0], LVL: [void 0, "Ls"], LYD: [void 0, void 0, 3], MGA: [void 0, "Ar", 0], MGF: [void 0, void 0, 0], MMK: [void 0, "K", 0], MNT: [void 0, "\u20AE", 2], MRO: [void 0, void 0, 0], MUR: [void 0, "Rs", 2], MXN: ["MX$", "$"], MYR: [void 0, "RM"], NAD: [void 0, "$"], NGN: [void 0, "\u20A6"], NIO: [void 0, "C$"], NOK: [void 0, "kr", 2], NPR: [void 0, "Rs"], NZD: ["NZ$", "$"], OMR: [void 0, void 0, 3], PHP: ["\u20B1"], PKR: [void 0, "Rs", 2], PLN: [void 0, "z\u0142"], PYG: [void 0, "\u20B2", 0], RON: [void 0, "lei"], RSD: [void 0, void 0, 0], RUB: [void 0, "\u20BD"], RWF: [void 0, "RF", 0], SBD: [void 0, "$"], SEK: [void 0, "kr", 2], SGD: [void 0, "$"], SHP: [void 0, "\xA3"], SLE: [void 0, void 0, 2], SLL: [void 0, void 0, 0], SOS: [void 0, void 0, 0], SRD: [void 0, "$"], SSP: [void 0, "\xA3"], STD: [void 0, void 0, 0], STN: [void 0, "Db"], SYP: [void 0, "\xA3", 0], THB: [void 0, "\u0E3F"], TMM: [void 0, void 0, 0], TND: [void 0, void 0, 3], TOP: [void 0, "T$"], TRL: [void 0, void 0, 0], TRY: [void 0, "\u20BA"], TTD: [void 0, "$"], TWD: ["NT$", "$", 2], TZS: [void 0, void 0, 2], UAH: [void 0, "\u20B4"], UGX: [void 0, void 0, 0], USD: ["$"], UYI: [void 0, void 0, 0], UYU: [void 0, "$"], UYW: [void 0, void 0, 4], UZS: [void 0, void 0, 2], VEF: [void 0, "Bs", 2], VND: ["\u20AB", void 0, 0], VUV: [void 0, void 0, 0], XAF: ["FCFA", void 0, 0], XCD: ["EC$", "$"], XOF: ["F\u202FCFA", void 0, 0], XPF: ["CFPF", void 0, 0], XXX: ["\xA4"], YER: [void 0, void 0, 0], ZAR: [void 0, "R"], ZMK: [void 0, void 0, 0], ZMW: [void 0, "ZK"], ZWD: [void 0, void 0, 0] }, Fl = function (t) { return t[t.Decimal = 0] = "Decimal", t[t.Percent = 1] = "Percent", t[t.Currency = 2] = "Currency", t[t.Scientific = 3] = "Scientific", t }(Fl || {}); var Ce = { Decimal: 0, Group: 1, List: 2, PercentSign: 3, PlusSign: 4, MinusSign: 5, Exponential: 6, SuperscriptingExponent: 7, PerMille: 8, Infinity: 9, NaN: 10, TimeSeparator: 11, CurrencyDecimal: 12, CurrencyGroup: 13 }; function Rn(t, e) { let n = ci(t), r = n[tt.NumberSymbols][e]; if (typeof r > "u") { if (e === Ce.CurrencyDecimal) return n[tt.NumberSymbols][Ce.Decimal]; if (e === Ce.CurrencyGroup) return n[tt.NumberSymbols][Ce.Group] } return r } function gp(t, e) { return ci(t)[tt.NumberFormats][e] } function k_(t) { return ci(t)[tt.Currencies] } function L_(t, e, n = "en") { let r = k_(n)[t] || mp[t] || [], o = r[1]; return e === "narrow" && typeof o == "string" ? o : r[0] || t } var j_ = 2; function V_(t) { let e, n = mp[t]; return n && (e = n[2]), typeof e == "number" ? e : j_ } var B_ = /^(\d+)?\.((\d+)(-(\d+))?)?$/, sp = 22, hi = ".", fr = "0", $_ = ";", H_ = ",", Ml = "#", ap = "\xA4"; function yp(t, e, n, r, o, i, s = !1) { let a = "", l = !1; if (!isFinite(t)) a = Rn(n, Ce.Infinity); else { let u = G_(t); s && (u = q_(u)); let c = e.minInt, d = e.minFrac, h = e.maxFrac; if (i) { let b = i.match(B_); if (b === null) throw new Error(`${i} is not a valid digit info`); let j = b[1], k = b[3], re = b[5]; j != null && (c = Tl(j)), k != null && (d = Tl(k)), re != null ? h = Tl(re) : k != null && d > h && (h = d) } W_(u, d, h); let f = u.digits, p = u.integerLen, m = u.exponent, D = []; for (l = f.every(b => !b); p < c; p++)f.unshift(0); for (; p < 0; p++)f.unshift(0); p > 0 ? D = f.splice(p, f.length) : (D = f, f = [0]); let v = []; for (f.length >= e.lgSize && v.unshift(f.splice(-e.lgSize, f.length).join("")); f.length > e.gSize;)v.unshift(f.splice(-e.gSize, f.length).join("")); f.length && v.unshift(f.join("")), a = v.join(Rn(n, r)), D.length && (a += Rn(n, o) + D.join("")), m && (a += Rn(n, Ce.Exponential) + "+" + m) } return t < 0 && !l ? a = e.negPre + a + e.negSuf : a = e.posPre + a + e.posSuf, a } function U_(t, e, n, r, o) { let i = gp(e, Fl.Currency), s = vp(i, Rn(e, Ce.MinusSign)); return s.minFrac = V_(r), s.maxFrac = s.minFrac, yp(t, s, e, Ce.CurrencyGroup, Ce.CurrencyDecimal, o).replace(ap, n).replace(ap, "").trim() } function z_(t, e, n) { let r = gp(e, Fl.Decimal), o = vp(r, Rn(e, Ce.MinusSign)); return yp(t, o, e, Ce.Group, Ce.Decimal, n) } function vp(t, e = "-") { let n = { minInt: 1, minFrac: 0, maxFrac: 0, posPre: "", posSuf: "", negPre: "", negSuf: "", gSize: 0, lgSize: 0 }, r = t.split($_), o = r[0], i = r[1], s = o.indexOf(hi) !== -1 ? o.split(hi) : [o.substring(0, o.lastIndexOf(fr) + 1), o.substring(o.lastIndexOf(fr) + 1)], a = s[0], l = s[1] || ""; n.posPre = a.substring(0, a.indexOf(Ml)); for (let c = 0; c < l.length; c++) { let d = l.charAt(c); d === fr ? n.minFrac = n.maxFrac = c + 1 : d === Ml ? n.maxFrac = c + 1 : n.posSuf += d } let u = a.split(H_); if (n.gSize = u[1] ? u[1].length : 0, n.lgSize = u[2] || u[1] ? (u[2] || u[1]).length : 0, i) { let c = o.length - n.posPre.length - n.posSuf.length, d = i.indexOf(Ml); n.negPre = i.substring(0, d).replace(/'/g, ""), n.negSuf = i.slice(d + c).replace(/'/g, "") } else n.negPre = e + n.posPre, n.negSuf = n.posSuf; return n } function q_(t) { if (t.digits[0] === 0) return t; let e = t.digits.length - t.integerLen; return t.exponent ? t.exponent += 2 : (e === 0 ? t.digits.push(0, 0) : e === 1 && t.digits.push(0), t.integerLen += 2), t } function G_(t) { let e = Math.abs(t) + "", n = 0, r, o, i, s, a; for ((o = e.indexOf(hi)) > -1 && (e = e.replace(hi, "")), (i = e.search(/e/i)) > 0 ? (o < 0 && (o = i), o += +e.slice(i + 1), e = e.substring(0, i)) : o < 0 && (o = e.length), i = 0; e.charAt(i) === fr; i++); if (i === (a = e.length)) r = [0], o = 1; else { for (a--; e.charAt(a) === fr;)a--; for (o -= i, r = [], s = 0; i <= a; i++, s++)r[s] = Number(e.charAt(i)) } return o > sp && (r = r.splice(0, sp - 1), n = o - 1, o = 1), { digits: r, exponent: n, integerLen: o } } function W_(t, e, n) { if (e > n) throw new Error(`The minimum number of digits after fraction (${e}) is higher than the maximum (${n}).`); let r = t.digits, o = r.length - t.integerLen, i = Math.min(Math.max(e, o), n), s = i + t.integerLen, a = r[s]; if (s > 0) { r.splice(Math.max(t.integerLen, s)); for (let d = s; d < r.length; d++)r[d] = 0 } else { o = Math.max(0, o), t.integerLen = 1, r.length = Math.max(1, s = i + 1), r[0] = 0; for (let d = 1; d < s; d++)r[d] = 0 } if (a >= 5) if (s - 1 < 0) { for (let d = 0; d > s; d--)r.unshift(0), t.integerLen++; r.unshift(1), t.integerLen++ } else r[s - 1]++; for (; o < Math.max(0, i); o++)r.push(0); let l = i !== 0, u = e + t.integerLen, c = r.reduceRight(function (d, h, f, p) { return h = h + d, p[f] = h < 10 ? h : h - 10, l && (p[f] === 0 && f >= u ? p.pop() : l = !1), h >= 10 ? 1 : 0 }, 0); c && (r.unshift(c), t.integerLen++) } function Tl(t) { let e = parseInt(t); if (isNaN(e)) throw new Error("Invalid integer literal when parsing " + t); return e } function EP(t, e, n) { return Gh(t, e, n) } function wP(t, e) { e = encodeURIComponent(e); for (let n of t.split(";")) { let r = n.indexOf("="), [o, i] = r == -1 ? [n, ""] : [n.slice(0, r), n.slice(r + 1)]; if (o.trim() === e) return decodeURIComponent(i) } return null } var Nl = /\s+/, lp = [], _P = (() => { class t { constructor(n, r) { this._ngEl = n, this._renderer = r, this.initialClasses = lp, this.stateMap = new Map } set klass(n) { this.initialClasses = n != null ? n.trim().split(Nl) : lp } set ngClass(n) { this.rawClass = typeof n == "string" ? n.trim().split(Nl) : n } ngDoCheck() { for (let r of this.initialClasses) this._updateState(r, !0); let n = this.rawClass; if (Array.isArray(n) || n instanceof Set) for (let r of n) this._updateState(r, !0); else if (n != null) for (let r of Object.keys(n)) this._updateState(r, !!n[r]); this._applyStateDiff() } _updateState(n, r) { let o = this.stateMap.get(n); o !== void 0 ? (o.enabled !== r && (o.changed = !0, o.enabled = r), o.touched = !0) : this.stateMap.set(n, { enabled: r, changed: !0, touched: !0 }) } _applyStateDiff() { for (let n of this.stateMap) { let r = n[0], o = n[1]; o.changed ? (this._toggleClass(r, o.enabled), o.changed = !1) : o.touched || (o.enabled && this._toggleClass(r, !1), this.stateMap.delete(r)), o.touched = !1 } } _toggleClass(n, r) { n = n.trim(), n.length > 0 && n.split(Nl).forEach(o => { r ? this._renderer.addClass(this._ngEl.nativeElement, o) : this._renderer.removeClass(this._ngEl.nativeElement, o) }) } static { this.\u0275fac = function (r) { return new (r || t)(ne(_t), ne(ui)) } } static { this.\u0275dir = ir({ type: t, selectors: [["", "ngClass", ""]], inputs: { klass: [0, "class", "klass"], ngClass: "ngClass" }, standalone: !0 }) } } return t })(); var IP = (() => { class t { constructor(n, r) { this._viewContainer = n, this._context = new xl, this._thenTemplateRef = null, this._elseTemplateRef = null, this._thenViewRef = null, this._elseViewRef = null, this._thenTemplateRef = r } set ngIf(n) { this._context.$implicit = this._context.ngIf = n, this._updateView() } set ngIfThen(n) { up("ngIfThen", n), this._thenTemplateRef = n, this._thenViewRef = null, this._updateView() } set ngIfElse(n) { up("ngIfElse", n), this._elseTemplateRef = n, this._elseViewRef = null, this._updateView() } _updateView() { this._context.$implicit ? this._thenViewRef || (this._viewContainer.clear(), this._elseViewRef = null, this._thenTemplateRef && (this._thenViewRef = this._viewContainer.createEmbeddedView(this._thenTemplateRef, this._context))) : this._elseViewRef || (this._viewContainer.clear(), this._thenViewRef = null, this._elseTemplateRef && (this._elseViewRef = this._viewContainer.createEmbeddedView(this._elseTemplateRef, this._context))) } static ngTemplateContextGuard(n, r) { return !0 } static { this.\u0275fac = function (r) { return new (r || t)(ne(Fn), ne(bn)) } } static { this.\u0275dir = ir({ type: t, selectors: [["", "ngIf", ""]], inputs: { ngIf: "ngIf", ngIfThen: "ngIfThen", ngIfElse: "ngIfElse" }, standalone: !0 }) } } return t })(), xl = class { constructor() { this.$implicit = null, this.ngIf = null } }; function up(t, e) { if (!!!(!e || e.createEmbeddedView)) throw new Error(`${t} must be a TemplateRef, but received '${ae(e)}'.`) } var bP = (() => { class t { constructor(n, r, o) { this._ngEl = n, this._differs = r, this._renderer = o, this._ngStyle = null, this._differ = null } set ngStyle(n) { this._ngStyle = n, !this._differ && n && (this._differ = this._differs.find(n).create()) } ngDoCheck() { if (this._differ) { let n = this._differ.diff(this._ngStyle); n && this._applyChanges(n) } } _setStyle(n, r) { let [o, i] = n.split("."), s = o.indexOf("-") === -1 ? void 0 : er.DashCase; r != null ? this._renderer.setStyle(this._ngEl.nativeElement, o, i ? `${r}${i}` : r, s) : this._renderer.removeStyle(this._ngEl.nativeElement, o, s) } _applyChanges(n) { n.forEachRemovedItem(r => this._setStyle(r.key, null)), n.forEachAddedItem(r => this._setStyle(r.key, r.currentValue)), n.forEachChangedItem(r => this._setStyle(r.key, r.currentValue)) } static { this.\u0275fac = function (r) { return new (r || t)(ne(_t), ne(bl), ne(ui)) } } static { this.\u0275dir = ir({ type: t, selectors: [["", "ngStyle", ""]], inputs: { ngStyle: "ngStyle" }, standalone: !0 }) } } return t })(), CP = (() => { class t { constructor(n) { this._viewContainerRef = n, this._viewRef = null, this.ngTemplateOutletContext = null, this.ngTemplateOutlet = null, this.ngTemplateOutletInjector = null } ngOnChanges(n) { if (this._shouldRecreateView(n)) { let r = this._viewContainerRef; if (this._viewRef && r.remove(r.indexOf(this._viewRef)), !this.ngTemplateOutlet) { this._viewRef = null; return } let o = this._createContextForwardProxy(); this._viewRef = r.createEmbeddedView(this.ngTemplateOutlet, o, { injector: this.ngTemplateOutletInjector ?? void 0 }) } } _shouldRecreateView(n) { return !!n.ngTemplateOutlet || !!n.ngTemplateOutletInjector } _createContextForwardProxy() { return new Proxy({}, { set: (n, r, o) => this.ngTemplateOutletContext ? Reflect.set(this.ngTemplateOutletContext, r, o) : !1, get: (n, r, o) => { if (this.ngTemplateOutletContext) return Reflect.get(this.ngTemplateOutletContext, r, o) } }) } static { this.\u0275fac = function (r) { return new (r || t)(ne(Fn)) } } static { this.\u0275dir = ir({ type: t, selectors: [["", "ngTemplateOutlet", ""]], inputs: { ngTemplateOutletContext: "ngTemplateOutletContext", ngTemplateOutlet: "ngTemplateOutlet", ngTemplateOutletInjector: "ngTemplateOutletInjector" }, standalone: !0, features: [Ua] }) } } return t })(); function Rl(t, e) { return new g(2100, !1) } var Al = class { createSubscription(e, n) { return Cl(() => e.subscribe({ next: n, error: r => { throw r } })) } dispose(e) { Cl(() => e.unsubscribe()) } }, Ol = class { createSubscription(e, n) { return e.then(n, r => { throw r }) } dispose(e) { } }, Q_ = new Ol, Z_ = new Al, SP = (() => { class t { constructor(n) { this._latestValue = null, this.markForCheckOnValueUpdate = !0, this._subscription = null, this._obj = null, this._strategy = null, this._ref = n } ngOnDestroy() { this._subscription && this._dispose(), this._ref = null } transform(n) { if (!this._obj) { if (n) try { this.markForCheckOnValueUpdate = !1, this._subscribe(n) } finally { this.markForCheckOnValueUpdate = !0 } return this._latestValue } return n !== this._obj ? (this._dispose(), this.transform(n)) : this._latestValue } _subscribe(n) { this._obj = n, this._strategy = this._selectStrategy(n), this._subscription = this._strategy.createSubscription(n, r => this._updateLatestValue(n, r)) } _selectStrategy(n) { if (di(n)) return Q_; if (_l(n)) return Z_; throw Rl(t, n) } _dispose() { this._strategy.dispose(this._subscription), this._latestValue = null, this._subscription = null, this._obj = null } _updateLatestValue(n, r) { n === this._obj && (this._latestValue = r, this.markForCheckOnValueUpdate && this._ref?.markForCheck()) } static { this.\u0275fac = function (r) { return new (r || t)(ne(Il, 16)) } } static { this.\u0275pipe = Uo({ name: "async", type: t, pure: !1, standalone: !0 }) } } return t })(); var MP = (() => { class t { constructor(n) { this._locale = n } transform(n, r, o) { if (!Dp(n)) return null; o ||= this._locale; try { let i = Ep(n); return z_(i, o, r) } catch (i) { throw Rl(t, i.message) } } static { this.\u0275fac = function (r) { return new (r || t)(ne(dr, 16)) } } static { this.\u0275pipe = Uo({ name: "number", type: t, pure: !0, standalone: !0 }) } } return t })(); var TP = (() => { class t { constructor(n, r = "USD") { this._locale = n, this._defaultCurrencyCode = r } transform(n, r = this._defaultCurrencyCode, o = "symbol", i, s) { if (!Dp(n)) return null; s ||= this._locale, typeof o == "boolean" && (o = o ? "symbol" : "code"); let a = r || this._defaultCurrencyCode; o !== "code" && (o === "symbol" || o === "symbol-narrow" ? a = L_(a, o === "symbol" ? "wide" : "narrow", s) : a = o); try { let l = Ep(n); return U_(l, s, a, r, i) } catch (l) { throw Rl(t, l.message) } } static { this.\u0275fac = function (r) { return new (r || t)(ne(dr, 16), ne(ep, 16)) } } static { this.\u0275pipe = Uo({ name: "currency", type: t, pure: !0, standalone: !0 }) } } return t })(); function Dp(t) { return !(t == null || t === "" || t !== t) } function Ep(t) { if (typeof t == "string" && !isNaN(Number(t) - parseFloat(t))) return Number(t); if (typeof t != "number") throw new Error(`${t} is not a number`); return t } var NP = (() => { class t { static { this.\u0275fac = function (r) { return new (r || t) } } static { this.\u0275mod = Td({ type: t }) } static { this.\u0275inj = hd({}) } } return t })(), K_ = "browser", Y_ = "server"; function xP(t) { return t === K_ } function AP(t) { return t === Y_ } var cp = class { }; var N = function (t) { return t[t.State = 0] = "State", t[t.Transition = 1] = "Transition", t[t.Sequence = 2] = "Sequence", t[t.Group = 3] = "Group", t[t.Animate = 4] = "Animate", t[t.Keyframes = 5] = "Keyframes", t[t.Style = 6] = "Style", t[t.Trigger = 7] = "Trigger", t[t.Reference = 8] = "Reference", t[t.AnimateChild = 9] = "AnimateChild", t[t.AnimateRef = 10] = "AnimateRef", t[t.Query = 11] = "Query", t[t.Stagger = 12] = "Stagger", t }(N || {}), ze = "*"; function FP(t, e) { return { type: N.Trigger, name: t, definitions: e, options: {} } } function RP(t, e = null) { return { type: N.Animate, styles: e, timings: t } } function wp(t, e = null) { return { type: N.Sequence, steps: t, options: e } } function kl(t) { return { type: N.Style, styles: t, offset: null } } function kP(t, e, n) { return { type: N.State, name: t, styles: e, options: n } } function LP(t, e, n = null) { return { type: N.Transition, expr: t, animation: e, options: n } } function jP(t, e, n = null) { return { type: N.Query, selector: t, animation: e, options: n } } function VP(t, e) { return { type: N.Stagger, timings: t, animation: e } } var bt = class { constructor(e = 0, n = 0) { this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this._originalOnDoneFns = [], this._originalOnStartFns = [], this._started = !1, this._destroyed = !1, this._finished = !1, this._position = 0, this.parentPlayer = null, this.totalTime = e + n } _onFinish() { this._finished || (this._finished = !0, this._onDoneFns.forEach(e => e()), this._onDoneFns = []) } onStart(e) { this._originalOnStartFns.push(e), this._onStartFns.push(e) } onDone(e) { this._originalOnDoneFns.push(e), this._onDoneFns.push(e) } onDestroy(e) { this._onDestroyFns.push(e) } hasStarted() { return this._started } init() { } play() { this.hasStarted() || (this._onStart(), this.triggerMicrotask()), this._started = !0 } triggerMicrotask() { queueMicrotask(() => this._onFinish()) } _onStart() { this._onStartFns.forEach(e => e()), this._onStartFns = [] } pause() { } restart() { } finish() { this._onFinish() } destroy() { this._destroyed || (this._destroyed = !0, this.hasStarted() || this._onStart(), this.finish(), this._onDestroyFns.forEach(e => e()), this._onDestroyFns = []) } reset() { this._started = !1, this._finished = !1, this._onStartFns = this._originalOnStartFns, this._onDoneFns = this._originalOnDoneFns } setPosition(e) { this._position = this.totalTime ? e * this.totalTime : 1 } getPosition() { return this.totalTime ? this._position / this.totalTime : 1 } triggerCallback(e) { let n = e == "start" ? this._onStartFns : this._onDoneFns; n.forEach(r => r()), n.length = 0 } }, hr = class { constructor(e) { this._onDoneFns = [], this._onStartFns = [], this._finished = !1, this._started = !1, this._destroyed = !1, this._onDestroyFns = [], this.parentPlayer = null, this.totalTime = 0, this.players = e; let n = 0, r = 0, o = 0, i = this.players.length; i == 0 ? queueMicrotask(() => this._onFinish()) : this.players.forEach(s => { s.onDone(() => { ++n == i && this._onFinish() }), s.onDestroy(() => { ++r == i && this._onDestroy() }), s.onStart(() => { ++o == i && this._onStart() }) }), this.totalTime = this.players.reduce((s, a) => Math.max(s, a.totalTime), 0) } _onFinish() { this._finished || (this._finished = !0, this._onDoneFns.forEach(e => e()), this._onDoneFns = []) } init() { this.players.forEach(e => e.init()) } onStart(e) { this._onStartFns.push(e) } _onStart() { this.hasStarted() || (this._started = !0, this._onStartFns.forEach(e => e()), this._onStartFns = []) } onDone(e) { this._onDoneFns.push(e) } onDestroy(e) { this._onDestroyFns.push(e) } hasStarted() { return this._started } play() { this.parentPlayer || this.init(), this._onStart(), this.players.forEach(e => e.play()) } pause() { this.players.forEach(e => e.pause()) } restart() { this.players.forEach(e => e.restart()) } finish() { this._onFinish(), this.players.forEach(e => e.finish()) } destroy() { this._onDestroy() } _onDestroy() { this._destroyed || (this._destroyed = !0, this._onFinish(), this.players.forEach(e => e.destroy()), this._onDestroyFns.forEach(e => e()), this._onDestroyFns = []) } reset() { this.players.forEach(e => e.reset()), this._destroyed = !1, this._finished = !1, this._started = !1 } setPosition(e) { let n = e * this.totalTime; this.players.forEach(r => { let o = r.totalTime ? Math.min(1, n / r.totalTime) : 1; r.setPosition(o) }) } getPosition() { let e = this.players.reduce((n, r) => n === null || r.totalTime > n.totalTime ? r : n, null); return e != null ? e.getPosition() : 0 } beforeDestroy() { this.players.forEach(e => { e.beforeDestroy && e.beforeDestroy() }) } triggerCallback(e) { let n = e == "start" ? this._onStartFns : this._onDoneFns; n.forEach(r => r()), n.length = 0 } }, pi = "!"; function _p(t) { return new g(3e3, !1) } function J_() { return new g(3100, !1) } function X_() { return new g(3101, !1) } function eI(t) { return new g(3001, !1) } function tI(t) { return new g(3003, !1) } function nI(t) { return new g(3004, !1) } function rI(t, e) { return new g(3005, !1) } function oI() { return new g(3006, !1) } function iI() { return new g(3007, !1) } function sI(t, e) { return new g(3008, !1) } function aI(t) { return new g(3002, !1) } function lI(t, e, n, r, o) { return new g(3010, !1) } function uI() { return new g(3011, !1) } function cI() { return new g(3012, !1) } function dI() { return new g(3200, !1) } function fI() { return new g(3202, !1) } function hI() { return new g(3013, !1) } function pI(t) { return new g(3014, !1) } function mI(t) { return new g(3015, !1) } function gI(t) { return new g(3016, !1) } function yI(t) { return new g(3500, !1) } function vI(t) { return new g(3501, !1) } function DI(t, e) { return new g(3404, !1) } function EI(t) { return new g(3502, !1) } function wI(t) { return new g(3503, !1) } function _I() { return new g(3300, !1) } function II(t) { return new g(3504, !1) } function bI(t) { return new g(3301, !1) } function CI(t, e) { return new g(3302, !1) } function SI(t) { return new g(3303, !1) } function MI(t, e) { return new g(3400, !1) } function TI(t) { return new g(3401, !1) } function NI(t) { return new g(3402, !1) } function xI(t, e) { return new g(3505, !1) } var AI = new Set(["-moz-outline-radius", "-moz-outline-radius-bottomleft", "-moz-outline-radius-bottomright", "-moz-outline-radius-topleft", "-moz-outline-radius-topright", "-ms-grid-columns", "-ms-grid-rows", "-webkit-line-clamp", "-webkit-text-fill-color", "-webkit-text-stroke", "-webkit-text-stroke-color", "accent-color", "all", "backdrop-filter", "background", "background-color", "background-position", "background-size", "block-size", "border", "border-block-end", "border-block-end-color", "border-block-end-width", "border-block-start", "border-block-start-color", "border-block-start-width", "border-bottom", "border-bottom-color", "border-bottom-left-radius", "border-bottom-right-radius", "border-bottom-width", "border-color", "border-end-end-radius", "border-end-start-radius", "border-image-outset", "border-image-slice", "border-image-width", "border-inline-end", "border-inline-end-color", "border-inline-end-width", "border-inline-start", "border-inline-start-color", "border-inline-start-width", "border-left", "border-left-color", "border-left-width", "border-radius", "border-right", "border-right-color", "border-right-width", "border-start-end-radius", "border-start-start-radius", "border-top", "border-top-color", "border-top-left-radius", "border-top-right-radius", "border-top-width", "border-width", "bottom", "box-shadow", "caret-color", "clip", "clip-path", "color", "column-count", "column-gap", "column-rule", "column-rule-color", "column-rule-width", "column-width", "columns", "filter", "flex", "flex-basis", "flex-grow", "flex-shrink", "font", "font-size", "font-size-adjust", "font-stretch", "font-variation-settings", "font-weight", "gap", "grid-column-gap", "grid-gap", "grid-row-gap", "grid-template-columns", "grid-template-rows", "height", "inline-size", "input-security", "inset", "inset-block", "inset-block-end", "inset-block-start", "inset-inline", "inset-inline-end", "inset-inline-start", "left", "letter-spacing", "line-clamp", "line-height", "margin", "margin-block-end", "margin-block-start", "margin-bottom", "margin-inline-end", "margin-inline-start", "margin-left", "margin-right", "margin-top", "mask", "mask-border", "mask-position", "mask-size", "max-block-size", "max-height", "max-inline-size", "max-lines", "max-width", "min-block-size", "min-height", "min-inline-size", "min-width", "object-position", "offset", "offset-anchor", "offset-distance", "offset-path", "offset-position", "offset-rotate", "opacity", "order", "outline", "outline-color", "outline-offset", "outline-width", "padding", "padding-block-end", "padding-block-start", "padding-bottom", "padding-inline-end", "padding-inline-start", "padding-left", "padding-right", "padding-top", "perspective", "perspective-origin", "right", "rotate", "row-gap", "scale", "scroll-margin", "scroll-margin-block", "scroll-margin-block-end", "scroll-margin-block-start", "scroll-margin-bottom", "scroll-margin-inline", "scroll-margin-inline-end", "scroll-margin-inline-start", "scroll-margin-left", "scroll-margin-right", "scroll-margin-top", "scroll-padding", "scroll-padding-block", "scroll-padding-block-end", "scroll-padding-block-start", "scroll-padding-bottom", "scroll-padding-inline", "scroll-padding-inline-end", "scroll-padding-inline-start", "scroll-padding-left", "scroll-padding-right", "scroll-padding-top", "scroll-snap-coordinate", "scroll-snap-destination", "scrollbar-color", "shape-image-threshold", "shape-margin", "shape-outside", "tab-size", "text-decoration", "text-decoration-color", "text-decoration-thickness", "text-emphasis", "text-emphasis-color", "text-indent", "text-shadow", "text-underline-offset", "top", "transform", "transform-origin", "translate", "vertical-align", "visibility", "width", "word-spacing", "z-index", "zoom"]); function Ct(t) { switch (t.length) { case 0: return new bt; case 1: return t[0]; default: return new hr(t) } } function Bp(t, e, n = new Map, r = new Map) { let o = [], i = [], s = -1, a = null; if (e.forEach(l => { let u = l.get("offset"), c = u == s, d = c && a || new Map; l.forEach((h, f) => { let p = f, m = h; if (f !== "offset") switch (p = t.normalizePropertyName(p, o), m) { case pi: m = n.get(f); break; case ze: m = r.get(f); break; default: m = t.normalizeStyleValue(f, p, m, o); break }d.set(p, m) }), c || i.push(d), a = d, s = u }), o.length) throw EI(o); return i } function lu(t, e, n, r) { switch (e) { case "start": t.onStart(() => r(n && Ll(n, "start", t))); break; case "done": t.onDone(() => r(n && Ll(n, "done", t))); break; case "destroy": t.onDestroy(() => r(n && Ll(n, "destroy", t))); break } } function Ll(t, e, n) { let r = n.totalTime, o = !!n.disabled, i = uu(t.element, t.triggerName, t.fromState, t.toState, e || t.phaseName, r ?? t.totalTime, o), s = t._data; return s != null && (i._data = s), i } function uu(t, e, n, r, o = "", i = 0, s) { return { element: t, triggerName: e, fromState: n, toState: r, phaseName: o, totalTime: i, disabled: !!s } } function Ee(t, e, n) { let r = t.get(e); return r || t.set(e, r = n), r } function Ip(t) { let e = t.indexOf(":"), n = t.substring(1, e), r = t.slice(e + 1); return [n, r] } var OI = typeof document > "u" ? null : document.documentElement; function cu(t) { let e = t.parentNode || t.host || null; return e === OI ? null : e } function PI(t) { return t.substring(1, 6) == "ebkit" } var Kt = null, bp = !1; function FI(t) { Kt || (Kt = RI() || {}, bp = Kt.style ? "WebkitAppearance" in Kt.style : !1); let e = !0; return Kt.style && !PI(t) && (e = t in Kt.style, !e && bp && (e = "Webkit" + t.charAt(0).toUpperCase() + t.slice(1) in Kt.style)), e } function zP(t) { return AI.has(t) } function RI() { return typeof document < "u" ? document.body : null } function $p(t, e) { for (; e;) { if (e === t) return !0; e = cu(e) } return !1 } function Hp(t, e, n) { if (n) return Array.from(t.querySelectorAll(e)); let r = t.querySelector(e); return r ? [r] : [] } var Up = (() => { class t { validateStyleProperty(n) { return FI(n) } containsElement(n, r) { return $p(n, r) } getParentElement(n) { return cu(n) } query(n, r, o) { return Hp(n, r, o) } computeStyle(n, r, o) { return o || "" } animate(n, r, o, i, s, a = [], l) { return new bt(o, i) } static { this.\u0275fac = function (r) { return new (r || t) } } static { this.\u0275prov = $({ token: t, factory: t.\u0275fac }) } } return t })(), Cp = class { static { this.NOOP = new Up } }, Ul = class { }, zl = class { normalizePropertyName(e, n) { return e } normalizeStyleValue(e, n, r, o) { return r } }, kI = 1e3, zp = "{{", LI = "}}", du = "ng-enter", Ei = "ng-leave", mi = "ng-trigger", wi = ".ng-trigger", Sp = "ng-animating", ql = ".ng-animating"; function it(t) { if (typeof t == "number") return t; let e = t.match(/^(-?[\.\d]+)(m?s)/); return !e || e.length < 2 ? 0 : Gl(parseFloat(e[1]), e[2]) } function Gl(t, e) { switch (e) { case "s": return t * kI; default: return t } } function _i(t, e, n) { return t.hasOwnProperty("duration") ? t : jI(t, e, n) } function jI(t, e, n) { let r = /^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i, o, i = 0, s = ""; if (typeof t == "string") { let a = t.match(r); if (a === null) return e.push(_p(t)), { duration: 0, delay: 0, easing: "" }; o = Gl(parseFloat(a[1]), a[2]); let l = a[3]; l != null && (i = Gl(parseFloat(l), a[4])); let u = a[5]; u && (s = u) } else o = t; if (!n) { let a = !1, l = e.length; o < 0 && (e.push(J_()), a = !0), i < 0 && (e.push(X_()), a = !0), a && e.splice(l, 0, _p(t)) } return { duration: o, delay: i, easing: s } } function VI(t) { return t.length ? t[0] instanceof Map ? t : t.map(e => new Map(Object.entries(e))) : [] } function Mp(t) { return Array.isArray(t) ? new Map(...t) : new Map(t) } function qe(t, e, n) { e.forEach((r, o) => { let i = fu(o); n && !n.has(o) && n.set(o, t.style[i]), t.style[i] = r }) } function Jt(t, e) { e.forEach((n, r) => { let o = fu(r); t.style[o] = "" }) } function pr(t) { return Array.isArray(t) ? t.length == 1 ? t[0] : wp(t) : t } function BI(t, e, n) { let r = e.params || {}, o = qp(t); o.length && o.forEach(i => { r.hasOwnProperty(i) || n.push(eI(i)) }) } var Wl = new RegExp(`${zp}\\s*(.+?)\\s*${LI}`, "g"); function qp(t) { let e = []; if (typeof t == "string") { let n; for (; n = Wl.exec(t);)e.push(n[1]); Wl.lastIndex = 0 } return e } function gr(t, e, n) { let r = `${t}`, o = r.replace(Wl, (i, s) => { let a = e[s]; return a == null && (n.push(tI(s)), a = ""), a.toString() }); return o == r ? t : o } var $I = /-+([a-z0-9])/g; function fu(t) { return t.replace($I, (...e) => e[1].toUpperCase()) } function qP(t) { return t.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase() } function HI(t, e) { return t === 0 || e === 0 } function UI(t, e, n) { if (n.size && e.length) { let r = e[0], o = []; if (n.forEach((i, s) => { r.has(s) || o.push(s), r.set(s, i) }), o.length) for (let i = 1; i < e.length; i++) { let s = e[i]; o.forEach(a => s.set(a, hu(t, a))) } } return e } function De(t, e, n) { switch (e.type) { case N.Trigger: return t.visitTrigger(e, n); case N.State: return t.visitState(e, n); case N.Transition: return t.visitTransition(e, n); case N.Sequence: return t.visitSequence(e, n); case N.Group: return t.visitGroup(e, n); case N.Animate: return t.visitAnimate(e, n); case N.Keyframes: return t.visitKeyframes(e, n); case N.Style: return t.visitStyle(e, n); case N.Reference: return t.visitReference(e, n); case N.AnimateChild: return t.visitAnimateChild(e, n); case N.AnimateRef: return t.visitAnimateRef(e, n); case N.Query: return t.visitQuery(e, n); case N.Stagger: return t.visitStagger(e, n); default: throw nI(e.type) } } function hu(t, e) { return window.getComputedStyle(t)[e] } var zI = new Set(["width", "height", "minWidth", "minHeight", "maxWidth", "maxHeight", "left", "top", "bottom", "right", "fontSize", "outlineWidth", "outlineOffset", "paddingTop", "paddingLeft", "paddingBottom", "paddingRight", "marginTop", "marginLeft", "marginBottom", "marginRight", "borderRadius", "borderWidth", "borderTopWidth", "borderLeftWidth", "borderRightWidth", "borderBottomWidth", "textIndent", "perspective"]), Ql = class extends Ul { normalizePropertyName(e, n) { return fu(e) } normalizeStyleValue(e, n, r, o) { let i = "", s = r.toString().trim(); if (zI.has(n) && r !== 0 && r !== "0") if (typeof r == "number") i = "px"; else { let a = r.match(/^[+-]?[\d\.]+([a-z]*)$/); a && a[1].length == 0 && o.push(rI(e, r)) } return s + i } }; var Ii = "*"; function qI(t, e) { let n = []; return typeof t == "string" ? t.split(/\s*,\s*/).forEach(r => GI(r, n, e)) : n.push(t), n } function GI(t, e, n) { if (t[0] == ":") { let l = WI(t, n); if (typeof l == "function") { e.push(l); return } t = l } let r = t.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/); if (r == null || r.length < 4) return n.push(mI(t)), e; let o = r[1], i = r[2], s = r[3]; e.push(Tp(o, s)); let a = o == Ii && s == Ii; i[0] == "<" && !a && e.push(Tp(s, o)) } function WI(t, e) { switch (t) { case ":enter": return "void => *"; case ":leave": return "* => void"; case ":increment": return (n, r) => parseFloat(r) > parseFloat(n); case ":decrement": return (n, r) => parseFloat(r) < parseFloat(n); default: return e.push(gI(t)), "* => *" } } var gi = new Set(["true", "1"]), yi = new Set(["false", "0"]); function Tp(t, e) { let n = gi.has(t) || yi.has(t), r = gi.has(e) || yi.has(e); return (o, i) => { let s = t == Ii || t == o, a = e == Ii || e == i; return !s && n && typeof o == "boolean" && (s = o ? gi.has(t) : yi.has(t)), !a && r && typeof i == "boolean" && (a = i ? gi.has(e) : yi.has(e)), s && a } } var Gp = ":self", QI = new RegExp(`s*${Gp}s*,?`, "g"); function pu(t, e, n, r) { return new Zl(t).build(e, n, r) } var Np = "", Zl = class { constructor(e) { this._driver = e } build(e, n, r) { let o = new Kl(n); return this._resetContextStyleTimingState(o), De(this, pr(e), o) } _resetContextStyleTimingState(e) { e.currentQuerySelector = Np, e.collectedStyles = new Map, e.collectedStyles.set(Np, new Map), e.currentTime = 0 } visitTrigger(e, n) { let r = n.queryCount = 0, o = n.depCount = 0, i = [], s = []; return e.name.charAt(0) == "@" && n.errors.push(oI()), e.definitions.forEach(a => { if (this._resetContextStyleTimingState(n), a.type == N.State) { let l = a, u = l.name; u.toString().split(/\s*,\s*/).forEach(c => { l.name = c, i.push(this.visitState(l, n)) }), l.name = u } else if (a.type == N.Transition) { let l = this.visitTransition(a, n); r += l.queryCount, o += l.depCount, s.push(l) } else n.errors.push(iI()) }), { type: N.Trigger, name: e.name, states: i, transitions: s, queryCount: r, depCount: o, options: null } } visitState(e, n) { let r = this.visitStyle(e.styles, n), o = e.options && e.options.params || null; if (r.containsDynamicStyles) { let i = new Set, s = o || {}; r.styles.forEach(a => { a instanceof Map && a.forEach(l => { qp(l).forEach(u => { s.hasOwnProperty(u) || i.add(u) }) }) }), i.size && n.errors.push(sI(e.name, [...i.values()])) } return { type: N.State, name: e.name, style: r, options: o ? { params: o } : null } } visitTransition(e, n) { n.queryCount = 0, n.depCount = 0; let r = De(this, pr(e.animation), n), o = qI(e.expr, n.errors); return { type: N.Transition, matchers: o, animation: r, queryCount: n.queryCount, depCount: n.depCount, options: Yt(e.options) } } visitSequence(e, n) { return { type: N.Sequence, steps: e.steps.map(r => De(this, r, n)), options: Yt(e.options) } } visitGroup(e, n) { let r = n.currentTime, o = 0, i = e.steps.map(s => { n.currentTime = r; let a = De(this, s, n); return o = Math.max(o, n.currentTime), a }); return n.currentTime = o, { type: N.Group, steps: i, options: Yt(e.options) } } visitAnimate(e, n) { let r = JI(e.timings, n.errors); n.currentAnimateTimings = r; let o, i = e.styles ? e.styles : kl({}); if (i.type == N.Keyframes) o = this.visitKeyframes(i, n); else { let s = e.styles, a = !1; if (!s) { a = !0; let u = {}; r.easing && (u.easing = r.easing), s = kl(u) } n.currentTime += r.duration + r.delay; let l = this.visitStyle(s, n); l.isEmptyStep = a, o = l } return n.currentAnimateTimings = null, { type: N.Animate, timings: r, style: o, options: null } } visitStyle(e, n) { let r = this._makeStyleAst(e, n); return this._validateStyleAst(r, n), r } _makeStyleAst(e, n) { let r = [], o = Array.isArray(e.styles) ? e.styles : [e.styles]; for (let a of o) typeof a == "string" ? a === ze ? r.push(a) : n.errors.push(aI(a)) : r.push(new Map(Object.entries(a))); let i = !1, s = null; return r.forEach(a => { if (a instanceof Map && (a.has("easing") && (s = a.get("easing"), a.delete("easing")), !i)) { for (let l of a.values()) if (l.toString().indexOf(zp) >= 0) { i = !0; break } } }), { type: N.Style, styles: r, easing: s, offset: e.offset, containsDynamicStyles: i, options: null } } _validateStyleAst(e, n) { let r = n.currentAnimateTimings, o = n.currentTime, i = n.currentTime; r && i > 0 && (i -= r.duration + r.delay), e.styles.forEach(s => { typeof s != "string" && s.forEach((a, l) => { let u = n.collectedStyles.get(n.currentQuerySelector), c = u.get(l), d = !0; c && (i != o && i >= c.startTime && o <= c.endTime && (n.errors.push(lI(l, c.startTime, c.endTime, i, o)), d = !1), i = c.startTime), d && u.set(l, { startTime: i, endTime: o }), n.options && BI(a, n.options, n.errors) }) }) } visitKeyframes(e, n) { let r = { type: N.Keyframes, styles: [], options: null }; if (!n.currentAnimateTimings) return n.errors.push(uI()), r; let o = 1, i = 0, s = [], a = !1, l = !1, u = 0, c = e.steps.map(v => { let b = this._makeStyleAst(v, n), j = b.offset != null ? b.offset : YI(b.styles), k = 0; return j != null && (i++, k = b.offset = j), l = l || k < 0 || k > 1, a = a || k < u, u = k, s.push(k), b }); l && n.errors.push(cI()), a && n.errors.push(dI()); let d = e.steps.length, h = 0; i > 0 && i < d ? n.errors.push(fI()) : i == 0 && (h = o / (d - 1)); let f = d - 1, p = n.currentTime, m = n.currentAnimateTimings, D = m.duration; return c.forEach((v, b) => { let j = h > 0 ? b == f ? 1 : h * b : s[b], k = j * D; n.currentTime = p + m.delay + k, m.duration = k, this._validateStyleAst(v, n), v.offset = j, r.styles.push(v) }), r } visitReference(e, n) { return { type: N.Reference, animation: De(this, pr(e.animation), n), options: Yt(e.options) } } visitAnimateChild(e, n) { return n.depCount++, { type: N.AnimateChild, options: Yt(e.options) } } visitAnimateRef(e, n) { return { type: N.AnimateRef, animation: this.visitReference(e.animation, n), options: Yt(e.options) } } visitQuery(e, n) { let r = n.currentQuerySelector, o = e.options || {}; n.queryCount++, n.currentQuery = e; let [i, s] = ZI(e.selector); n.currentQuerySelector = r.length ? r + " " + i : i, Ee(n.collectedStyles, n.currentQuerySelector, new Map); let a = De(this, pr(e.animation), n); return n.currentQuery = null, n.currentQuerySelector = r, { type: N.Query, selector: i, limit: o.limit || 0, optional: !!o.optional, includeSelf: s, animation: a, originalSelector: e.selector, options: Yt(e.options) } } visitStagger(e, n) { n.currentQuery || n.errors.push(hI()); let r = e.timings === "full" ? { duration: 0, delay: 0, easing: "full" } : _i(e.timings, n.errors, !0); return { type: N.Stagger, animation: De(this, pr(e.animation), n), timings: r, options: null } } }; function ZI(t) { let e = !!t.split(/\s*,\s*/).find(n => n == Gp); return e && (t = t.replace(QI, "")), t = t.replace(/@\*/g, wi).replace(/@\w+/g, n => wi + "-" + n.slice(1)).replace(/:animating/g, ql), [t, e] } function KI(t) { return t ? me({}, t) : null } var Kl = class { constructor(e) { this.errors = e, this.queryCount = 0, this.depCount = 0, this.currentTransition = null, this.currentQuery = null, this.currentQuerySelector = null, this.currentAnimateTimings = null, this.currentTime = 0, this.collectedStyles = new Map, this.options = null, this.unsupportedCSSPropertiesFound = new Set } }; function YI(t) { if (typeof t == "string") return null; let e = null; if (Array.isArray(t)) t.forEach(n => { if (n instanceof Map && n.has("offset")) { let r = n; e = parseFloat(r.get("offset")), r.delete("offset") } }); else if (t instanceof Map && t.has("offset")) { let n = t; e = parseFloat(n.get("offset")), n.delete("offset") } return e } function JI(t, e) { if (t.hasOwnProperty("duration")) return t; if (typeof t == "number") { let i = _i(t, e).duration; return jl(i, 0, "") } let n = t; if (n.split(/\s+/).some(i => i.charAt(0) == "{" && i.charAt(1) == "{")) { let i = jl(0, 0, ""); return i.dynamic = !0, i.strValue = n, i } let o = _i(n, e); return jl(o.duration, o.delay, o.easing) } function Yt(t) { return t ? (t = me({}, t), t.params && (t.params = KI(t.params))) : t = {}, t } function jl(t, e, n) { return { duration: t, delay: e, easing: n } } function mu(t, e, n, r, o, i, s = null, a = !1) { return { type: 1, element: t, keyframes: e, preStyleProps: n, postStyleProps: r, duration: o, delay: i, totalTime: o + i, easing: s, subTimeline: a } } var Ln = class { constructor() { this._map = new Map } get(e) { return this._map.get(e) || [] } append(e, n) { let r = this._map.get(e); r || this._map.set(e, r = []), r.push(...n) } has(e) { return this._map.has(e) } clear() { this._map.clear() } }, XI = 1, eb = ":enter", tb = new RegExp(eb, "g"), nb = ":leave", rb = new RegExp(nb, "g"); function gu(t, e, n, r, o, i = new Map, s = new Map, a, l, u = []) { return new Yl().buildKeyframes(t, e, n, r, o, i, s, a, l, u) } var Yl = class { buildKeyframes(e, n, r, o, i, s, a, l, u, c = []) { u = u || new Ln; let d = new Jl(e, n, u, o, i, c, []); d.options = l; let h = l.delay ? it(l.delay) : 0; d.currentTimeline.delayNextStep(h), d.currentTimeline.setStyles([s], null, d.errors, l), De(this, r, d); let f = d.timelines.filter(p => p.containsAnimation()); if (f.length && a.size) { let p; for (let m = f.length - 1; m >= 0; m--) { let D = f[m]; if (D.element === n) { p = D; break } } p && !p.allowOnlyTimelineStyles() && p.setStyles([a], null, d.errors, l) } return f.length ? f.map(p => p.buildKeyframes()) : [mu(n, [], [], [], 0, h, "", !1)] } visitTrigger(e, n) { } visitState(e, n) { } visitTransition(e, n) { } visitAnimateChild(e, n) { let r = n.subInstructions.get(n.element); if (r) { let o = n.createSubContext(e.options), i = n.currentTimeline.currentTime, s = this._visitSubInstructions(r, o, o.options); i != s && n.transformIntoNewTimeline(s) } n.previousNode = e } visitAnimateRef(e, n) { let r = n.createSubContext(e.options); r.transformIntoNewTimeline(), this._applyAnimationRefDelays([e.options, e.animation.options], n, r), this.visitReference(e.animation, r), n.transformIntoNewTimeline(r.currentTimeline.currentTime), n.previousNode = e } _applyAnimationRefDelays(e, n, r) { for (let o of e) { let i = o?.delay; if (i) { let s = typeof i == "number" ? i : it(gr(i, o?.params ?? {}, n.errors)); r.delayNextStep(s) } } } _visitSubInstructions(e, n, r) { let i = n.currentTimeline.currentTime, s = r.duration != null ? it(r.duration) : null, a = r.delay != null ? it(r.delay) : null; return s !== 0 && e.forEach(l => { let u = n.appendInstructionToTimeline(l, s, a); i = Math.max(i, u.duration + u.delay) }), i } visitReference(e, n) { n.updateOptions(e.options, !0), De(this, e.animation, n), n.previousNode = e } visitSequence(e, n) { let r = n.subContextCount, o = n, i = e.options; if (i && (i.params || i.delay) && (o = n.createSubContext(i), o.transformIntoNewTimeline(), i.delay != null)) { o.previousNode.type == N.Style && (o.currentTimeline.snapshotCurrentStyles(), o.previousNode = bi); let s = it(i.delay); o.delayNextStep(s) } e.steps.length && (e.steps.forEach(s => De(this, s, o)), o.currentTimeline.applyStylesToKeyframe(), o.subContextCount > r && o.transformIntoNewTimeline()), n.previousNode = e } visitGroup(e, n) { let r = [], o = n.currentTimeline.currentTime, i = e.options && e.options.delay ? it(e.options.delay) : 0; e.steps.forEach(s => { let a = n.createSubContext(e.options); i && a.delayNextStep(i), De(this, s, a), o = Math.max(o, a.currentTimeline.currentTime), r.push(a.currentTimeline) }), r.forEach(s => n.currentTimeline.mergeTimelineCollectedStyles(s)), n.transformIntoNewTimeline(o), n.previousNode = e } _visitTiming(e, n) { if (e.dynamic) { let r = e.strValue, o = n.params ? gr(r, n.params, n.errors) : r; return _i(o, n.errors) } else return { duration: e.duration, delay: e.delay, easing: e.easing } } visitAnimate(e, n) { let r = n.currentAnimateTimings = this._visitTiming(e.timings, n), o = n.currentTimeline; r.delay && (n.incrementTime(r.delay), o.snapshotCurrentStyles()); let i = e.style; i.type == N.Keyframes ? this.visitKeyframes(i, n) : (n.incrementTime(r.duration), this.visitStyle(i, n), o.applyStylesToKeyframe()), n.currentAnimateTimings = null, n.previousNode = e } visitStyle(e, n) { let r = n.currentTimeline, o = n.currentAnimateTimings; !o && r.hasCurrentStyleProperties() && r.forwardFrame(); let i = o && o.easing || e.easing; e.isEmptyStep ? r.applyEmptyStep(i) : r.setStyles(e.styles, i, n.errors, n.options), n.previousNode = e } visitKeyframes(e, n) { let r = n.currentAnimateTimings, o = n.currentTimeline.duration, i = r.duration, a = n.createSubContext().currentTimeline; a.easing = r.easing, e.styles.forEach(l => { let u = l.offset || 0; a.forwardTime(u * i), a.setStyles(l.styles, l.easing, n.errors, n.options), a.applyStylesToKeyframe() }), n.currentTimeline.mergeTimelineCollectedStyles(a), n.transformIntoNewTimeline(o + i), n.previousNode = e } visitQuery(e, n) { let r = n.currentTimeline.currentTime, o = e.options || {}, i = o.delay ? it(o.delay) : 0; i && (n.previousNode.type === N.Style || r == 0 && n.currentTimeline.hasCurrentStyleProperties()) && (n.currentTimeline.snapshotCurrentStyles(), n.previousNode = bi); let s = r, a = n.invokeQuery(e.selector, e.originalSelector, e.limit, e.includeSelf, !!o.optional, n.errors); n.currentQueryTotal = a.length; let l = null; a.forEach((u, c) => { n.currentQueryIndex = c; let d = n.createSubContext(e.options, u); i && d.delayNextStep(i), u === n.element && (l = d.currentTimeline), De(this, e.animation, d), d.currentTimeline.applyStylesToKeyframe(); let h = d.currentTimeline.currentTime; s = Math.max(s, h) }), n.currentQueryIndex = 0, n.currentQueryTotal = 0, n.transformIntoNewTimeline(s), l && (n.currentTimeline.mergeTimelineCollectedStyles(l), n.currentTimeline.snapshotCurrentStyles()), n.previousNode = e } visitStagger(e, n) { let r = n.parentContext, o = n.currentTimeline, i = e.timings, s = Math.abs(i.duration), a = s * (n.currentQueryTotal - 1), l = s * n.currentQueryIndex; switch (i.duration < 0 ? "reverse" : i.easing) { case "reverse": l = a - l; break; case "full": l = r.currentStaggerTime; break }let c = n.currentTimeline; l && c.delayNextStep(l); let d = c.currentTime; De(this, e.animation, n), n.previousNode = e, r.currentStaggerTime = o.currentTime - d + (o.startTime - r.currentTimeline.startTime) } }, bi = {}, Jl = class t { constructor(e, n, r, o, i, s, a, l) { this._driver = e, this.element = n, this.subInstructions = r, this._enterClassName = o, this._leaveClassName = i, this.errors = s, this.timelines = a, this.parentContext = null, this.currentAnimateTimings = null, this.previousNode = bi, this.subContextCount = 0, this.options = {}, this.currentQueryIndex = 0, this.currentQueryTotal = 0, this.currentStaggerTime = 0, this.currentTimeline = l || new Ci(this._driver, n, 0), a.push(this.currentTimeline) } get params() { return this.options.params } updateOptions(e, n) { if (!e) return; let r = e, o = this.options; r.duration != null && (o.duration = it(r.duration)), r.delay != null && (o.delay = it(r.delay)); let i = r.params; if (i) { let s = o.params; s || (s = this.options.params = {}), Object.keys(i).forEach(a => { (!n || !s.hasOwnProperty(a)) && (s[a] = gr(i[a], s, this.errors)) }) } } _copyOptions() { let e = {}; if (this.options) { let n = this.options.params; if (n) { let r = e.params = {}; Object.keys(n).forEach(o => { r[o] = n[o] }) } } return e } createSubContext(e = null, n, r) { let o = n || this.element, i = new t(this._driver, o, this.subInstructions, this._enterClassName, this._leaveClassName, this.errors, this.timelines, this.currentTimeline.fork(o, r || 0)); return i.previousNode = this.previousNode, i.currentAnimateTimings = this.currentAnimateTimings, i.options = this._copyOptions(), i.updateOptions(e), i.currentQueryIndex = this.currentQueryIndex, i.currentQueryTotal = this.currentQueryTotal, i.parentContext = this, this.subContextCount++, i } transformIntoNewTimeline(e) { return this.previousNode = bi, this.currentTimeline = this.currentTimeline.fork(this.element, e), this.timelines.push(this.currentTimeline), this.currentTimeline } appendInstructionToTimeline(e, n, r) { let o = { duration: n ?? e.duration, delay: this.currentTimeline.currentTime + (r ?? 0) + e.delay, easing: "" }, i = new Xl(this._driver, e.element, e.keyframes, e.preStyleProps, e.postStyleProps, o, e.stretchStartingKeyframe); return this.timelines.push(i), o } incrementTime(e) { this.currentTimeline.forwardTime(this.currentTimeline.duration + e) } delayNextStep(e) { e > 0 && this.currentTimeline.delayNextStep(e) } invokeQuery(e, n, r, o, i, s) { let a = []; if (o && a.push(this.element), e.length > 0) { e = e.replace(tb, "." + this._enterClassName), e = e.replace(rb, "." + this._leaveClassName); let l = r != 1, u = this._driver.query(this.element, e, l); r !== 0 && (u = r < 0 ? u.slice(u.length + r, u.length) : u.slice(0, r)), a.push(...u) } return !i && a.length == 0 && s.push(pI(n)), a } }, Ci = class t { constructor(e, n, r, o) { this._driver = e, this.element = n, this.startTime = r, this._elementTimelineStylesLookup = o, this.duration = 0, this.easing = null, this._previousKeyframe = new Map, this._currentKeyframe = new Map, this._keyframes = new Map, this._styleSummary = new Map, this._localTimelineStyles = new Map, this._pendingStyles = new Map, this._backFill = new Map, this._currentEmptyStepKeyframe = null, this._elementTimelineStylesLookup || (this._elementTimelineStylesLookup = new Map), this._globalTimelineStyles = this._elementTimelineStylesLookup.get(n), this._globalTimelineStyles || (this._globalTimelineStyles = this._localTimelineStyles, this._elementTimelineStylesLookup.set(n, this._localTimelineStyles)), this._loadKeyframe() } containsAnimation() { switch (this._keyframes.size) { case 0: return !1; case 1: return this.hasCurrentStyleProperties(); default: return !0 } } hasCurrentStyleProperties() { return this._currentKeyframe.size > 0 } get currentTime() { return this.startTime + this.duration } delayNextStep(e) { let n = this._keyframes.size === 1 && this._pendingStyles.size; this.duration || n ? (this.forwardTime(this.currentTime + e), n && this.snapshotCurrentStyles()) : this.startTime += e } fork(e, n) { return this.applyStylesToKeyframe(), new t(this._driver, e, n || this.currentTime, this._elementTimelineStylesLookup) } _loadKeyframe() { this._currentKeyframe && (this._previousKeyframe = this._currentKeyframe), this._currentKeyframe = this._keyframes.get(this.duration), this._currentKeyframe || (this._currentKeyframe = new Map, this._keyframes.set(this.duration, this._currentKeyframe)) } forwardFrame() { this.duration += XI, this._loadKeyframe() } forwardTime(e) { this.applyStylesToKeyframe(), this.duration = e, this._loadKeyframe() } _updateStyle(e, n) { this._localTimelineStyles.set(e, n), this._globalTimelineStyles.set(e, n), this._styleSummary.set(e, { time: this.currentTime, value: n }) } allowOnlyTimelineStyles() { return this._currentEmptyStepKeyframe !== this._currentKeyframe } applyEmptyStep(e) { e && this._previousKeyframe.set("easing", e); for (let [n, r] of this._globalTimelineStyles) this._backFill.set(n, r || ze), this._currentKeyframe.set(n, ze); this._currentEmptyStepKeyframe = this._currentKeyframe } setStyles(e, n, r, o) { n && this._previousKeyframe.set("easing", n); let i = o && o.params || {}, s = ob(e, this._globalTimelineStyles); for (let [a, l] of s) { let u = gr(l, i, r); this._pendingStyles.set(a, u), this._localTimelineStyles.has(a) || this._backFill.set(a, this._globalTimelineStyles.get(a) ?? ze), this._updateStyle(a, u) } } applyStylesToKeyframe() { this._pendingStyles.size != 0 && (this._pendingStyles.forEach((e, n) => { this._currentKeyframe.set(n, e) }), this._pendingStyles.clear(), this._localTimelineStyles.forEach((e, n) => { this._currentKeyframe.has(n) || this._currentKeyframe.set(n, e) })) } snapshotCurrentStyles() { for (let [e, n] of this._localTimelineStyles) this._pendingStyles.set(e, n), this._updateStyle(e, n) } getFinalKeyframe() { return this._keyframes.get(this.duration) } get properties() { let e = []; for (let n in this._currentKeyframe) e.push(n); return e } mergeTimelineCollectedStyles(e) { e._styleSummary.forEach((n, r) => { let o = this._styleSummary.get(r); (!o || n.time > o.time) && this._updateStyle(r, n.value) }) } buildKeyframes() { this.applyStylesToKeyframe(); let e = new Set, n = new Set, r = this._keyframes.size === 1 && this.duration === 0, o = []; this._keyframes.forEach((a, l) => { let u = new Map([...this._backFill, ...a]); u.forEach((c, d) => { c === pi ? e.add(d) : c === ze && n.add(d) }), r || u.set("offset", l / this.duration), o.push(u) }); let i = [...e.values()], s = [...n.values()]; if (r) { let a = o[0], l = new Map(a); a.set("offset", 0), l.set("offset", 1), o = [a, l] } return mu(this.element, o, i, s, this.duration, this.startTime, this.easing, !1) } }, Xl = class extends Ci { constructor(e, n, r, o, i, s, a = !1) { super(e, n, s.delay), this.keyframes = r, this.preStyleProps = o, this.postStyleProps = i, this._stretchStartingKeyframe = a, this.timings = { duration: s.duration, delay: s.delay, easing: s.easing } } containsAnimation() { return this.keyframes.length > 1 } buildKeyframes() { let e = this.keyframes, { delay: n, duration: r, easing: o } = this.timings; if (this._stretchStartingKeyframe && n) { let i = [], s = r + n, a = n / s, l = new Map(e[0]); l.set("offset", 0), i.push(l); let u = new Map(e[0]); u.set("offset", xp(a)), i.push(u); let c = e.length - 1; for (let d = 1; d <= c; d++) { let h = new Map(e[d]), f = h.get("offset"), p = n + f * r; h.set("offset", xp(p / s)), i.push(h) } r = s, n = 0, o = "", e = i } return mu(this.element, e, this.preStyleProps, this.postStyleProps, r, n, o, !0) } }; function xp(t, e = 3) { let n = Math.pow(10, e - 1); return Math.round(t * n) / n } function ob(t, e) { let n = new Map, r; return t.forEach(o => { if (o === "*") { r ??= e.keys(); for (let i of r) n.set(i, ze) } else for (let [i, s] of o) n.set(i, s) }), n } function Ap(t, e, n, r, o, i, s, a, l, u, c, d, h) { return { type: 0, element: t, triggerName: e, isRemovalTransition: o, fromState: n, fromStyles: i, toState: r, toStyles: s, timelines: a, queriedElements: l, preStyleProps: u, postStyleProps: c, totalTime: d, errors: h } } var Vl = {}, Si = class { constructor(e, n, r) { this._triggerName = e, this.ast = n, this._stateStyles = r } match(e, n, r, o) { return ib(this.ast.matchers, e, n, r, o) } buildStyles(e, n, r) { let o = this._stateStyles.get("*"); return e !== void 0 && (o = this._stateStyles.get(e?.toString()) || o), o ? o.buildStyles(n, r) : new Map } build(e, n, r, o, i, s, a, l, u, c) { let d = [], h = this.ast.options && this.ast.options.params || Vl, f = a && a.params || Vl, p = this.buildStyles(r, f, d), m = l && l.params || Vl, D = this.buildStyles(o, m, d), v = new Set, b = new Map, j = new Map, k = o === "void", re = { params: Wp(m, h), delay: this.ast.options?.delay }, U = c ? [] : gu(e, n, this.ast.animation, i, s, p, D, re, u, d), G = 0; return U.forEach(Z => { G = Math.max(Z.duration + Z.delay, G) }), d.length ? Ap(n, this._triggerName, r, o, k, p, D, [], [], b, j, G, d) : (U.forEach(Z => { let Ge = Z.element, Xt = Ee(b, Ge, new Set); Z.preStyleProps.forEach(St => Xt.add(St)); let yu = Ee(j, Ge, new Set); Z.postStyleProps.forEach(St => yu.add(St)), Ge !== n && v.add(Ge) }), Ap(n, this._triggerName, r, o, k, p, D, U, [...v.values()], b, j, G)) } }; function ib(t, e, n, r, o) { return t.some(i => i(e, n, r, o)) } function Wp(t, e) { let n = me({}, e); return Object.entries(t).forEach(([r, o]) => { o != null && (n[r] = o) }), n } var eu = class { constructor(e, n, r) { this.styles = e, this.defaultParams = n, this.normalizer = r } buildStyles(e, n) { let r = new Map, o = Wp(e, this.defaultParams); return this.styles.styles.forEach(i => { typeof i != "string" && i.forEach((s, a) => { s && (s = gr(s, o, n)); let l = this.normalizer.normalizePropertyName(a, n); s = this.normalizer.normalizeStyleValue(a, l, s, n), r.set(a, s) }) }), r } }; function sb(t, e, n) { return new tu(t, e, n) } var tu = class { constructor(e, n, r) { this.name = e, this.ast = n, this._normalizer = r, this.transitionFactories = [], this.states = new Map, n.states.forEach(o => { let i = o.options && o.options.params || {}; this.states.set(o.name, new eu(o.style, i, r)) }), Op(this.states, "true", "1"), Op(this.states, "false", "0"), n.transitions.forEach(o => { this.transitionFactories.push(new Si(e, o, this.states)) }), this.fallbackTransition = ab(e, this.states, this._normalizer) } get containsQueries() { return this.ast.queryCount > 0 } matchTransition(e, n, r, o) { return this.transitionFactories.find(s => s.match(e, n, r, o)) || null } matchStyles(e, n, r) { return this.fallbackTransition.buildStyles(e, n, r) } }; function ab(t, e, n) { let r = [(s, a) => !0], o = { type: N.Sequence, steps: [], options: null }, i = { type: N.Transition, animation: o, matchers: r, options: null, queryCount: 0, depCount: 0 }; return new Si(t, i, e) } function Op(t, e, n) { t.has(e) ? t.has(n) || t.set(n, t.get(e)) : t.has(n) && t.set(e, t.get(n)) } var lb = new Ln, nu = class { constructor(e, n, r) { this.bodyNode = e, this._driver = n, this._normalizer = r, this._animations = new Map, this._playersById = new Map, this.players = [] } register(e, n) { let r = [], o = [], i = pu(this._driver, n, r, o); if (r.length) throw wI(r); o.length && void 0, this._animations.set(e, i) } _buildPlayer(e, n, r) { let o = e.element, i = Bp(this._normalizer, e.keyframes, n, r); return this._driver.animate(o, i, e.duration, e.delay, e.easing, [], !0) } create(e, n, r = {}) { let o = [], i = this._animations.get(e), s, a = new Map; if (i ? (s = gu(this._driver, n, i, du, Ei, new Map, new Map, r, lb, o), s.forEach(c => { let d = Ee(a, c.element, new Map); c.postStyleProps.forEach(h => d.set(h, null)) })) : (o.push(_I()), s = []), o.length) throw II(o); a.forEach((c, d) => { c.forEach((h, f) => { c.set(f, this._driver.computeStyle(d, f, ze)) }) }); let l = s.map(c => { let d = a.get(c.element); return this._buildPlayer(c, new Map, d) }), u = Ct(l); return this._playersById.set(e, u), u.onDestroy(() => this.destroy(e)), this.players.push(u), u } destroy(e) { let n = this._getPlayer(e); n.destroy(), this._playersById.delete(e); let r = this.players.indexOf(n); r >= 0 && this.players.splice(r, 1) } _getPlayer(e) { let n = this._playersById.get(e); if (!n) throw bI(e); return n } listen(e, n, r, o) { let i = uu(n, "", "", ""); return lu(this._getPlayer(e), r, i, o), () => { } } command(e, n, r, o) { if (r == "register") { this.register(e, o[0]); return } if (r == "create") { let s = o[0] || {}; this.create(e, n, s); return } let i = this._getPlayer(e); switch (r) { case "play": i.play(); break; case "pause": i.pause(); break; case "reset": i.reset(); break; case "restart": i.restart(); break; case "finish": i.finish(); break; case "init": i.init(); break; case "setPosition": i.setPosition(parseFloat(o[0])); break; case "destroy": this.destroy(e); break } } }, Pp = "ng-animate-queued", ub = ".ng-animate-queued", Bl = "ng-animate-disabled", cb = ".ng-animate-disabled", db = "ng-star-inserted", fb = ".ng-star-inserted", hb = [], Qp = { namespaceId: "", setForRemoval: !1, setForMove: !1, hasAnimation: !1, removedBeforeQueried: !1 }, pb = { namespaceId: "", setForMove: !1, setForRemoval: !1, hasAnimation: !1, removedBeforeQueried: !0 }, Fe = "__ng_removed", yr = class { get params() { return this.options.params } constructor(e, n = "") { this.namespaceId = n; let r = e && e.hasOwnProperty("value"), o = r ? e.value : e; if (this.value = gb(o), r) { let i = e, { value: s } = i, a = bu(i, ["value"]); this.options = a } else this.options = {}; this.options.params || (this.options.params = {}) } absorbOptions(e) { let n = e.params; if (n) { let r = this.options.params; Object.keys(n).forEach(o => { r[o] == null && (r[o] = n[o]) }) } } }, mr = "void", $l = new yr(mr), ru = class { constructor(e, n, r) { this.id = e, this.hostElement = n, this._engine = r, this.players = [], this._triggers = new Map, this._queue = [], this._elementListeners = new Map, this._hostClassName = "ng-tns-" + e, Se(n, this._hostClassName) } listen(e, n, r, o) { if (!this._triggers.has(n)) throw CI(r, n); if (r == null || r.length == 0) throw SI(n); if (!yb(r)) throw MI(r, n); let i = Ee(this._elementListeners, e, []), s = { name: n, phase: r, callback: o }; i.push(s); let a = Ee(this._engine.statesByElement, e, new Map); return a.has(n) || (Se(e, mi), Se(e, mi + "-" + n), a.set(n, $l)), () => { this._engine.afterFlush(() => { let l = i.indexOf(s); l >= 0 && i.splice(l, 1), this._triggers.has(n) || a.delete(n) }) } } register(e, n) { return this._triggers.has(e) ? !1 : (this._triggers.set(e, n), !0) } _getTrigger(e) { let n = this._triggers.get(e); if (!n) throw TI(e); return n } trigger(e, n, r, o = !0) { let i = this._getTrigger(n), s = new vr(this.id, n, e), a = this._engine.statesByElement.get(e); a || (Se(e, mi), Se(e, mi + "-" + n), this._engine.statesByElement.set(e, a = new Map)); let l = a.get(n), u = new yr(r, this.id); if (!(r && r.hasOwnProperty("value")) && l && u.absorbOptions(l.options), a.set(n, u), l || (l = $l), !(u.value === mr) && l.value === u.value) { if (!Eb(l.params, u.params)) { let m = [], D = i.matchStyles(l.value, l.params, m), v = i.matchStyles(u.value, u.params, m); m.length ? this._engine.reportError(m) : this._engine.afterFlush(() => { Jt(e, D), qe(e, v) }) } return } let h = Ee(this._engine.playersByElement, e, []); h.forEach(m => { m.namespaceId == this.id && m.triggerName == n && m.queued && m.destroy() }); let f = i.matchTransition(l.value, u.value, e, u.params), p = !1; if (!f) { if (!o) return; f = i.fallbackTransition, p = !0 } return this._engine.totalQueuedPlayers++, this._queue.push({ element: e, triggerName: n, transition: f, fromState: l, toState: u, player: s, isFallbackTransition: p }), p || (Se(e, Pp), s.onStart(() => { kn(e, Pp) })), s.onDone(() => { let m = this.players.indexOf(s); m >= 0 && this.players.splice(m, 1); let D = this._engine.playersByElement.get(e); if (D) { let v = D.indexOf(s); v >= 0 && D.splice(v, 1) } }), this.players.push(s), h.push(s), s } deregister(e) { this._triggers.delete(e), this._engine.statesByElement.forEach(n => n.delete(e)), this._elementListeners.forEach((n, r) => { this._elementListeners.set(r, n.filter(o => o.name != e)) }) } clearElementCache(e) { this._engine.statesByElement.delete(e), this._elementListeners.delete(e); let n = this._engine.playersByElement.get(e); n && (n.forEach(r => r.destroy()), this._engine.playersByElement.delete(e)) } _signalRemovalForInnerTriggers(e, n) { let r = this._engine.driver.query(e, wi, !0); r.forEach(o => { if (o[Fe]) return; let i = this._engine.fetchNamespacesByElement(o); i.size ? i.forEach(s => s.triggerLeaveAnimation(o, n, !1, !0)) : this.clearElementCache(o) }), this._engine.afterFlushAnimationsDone(() => r.forEach(o => this.clearElementCache(o))) } triggerLeaveAnimation(e, n, r, o) { let i = this._engine.statesByElement.get(e), s = new Map; if (i) { let a = []; if (i.forEach((l, u) => { if (s.set(u, l.value), this._triggers.has(u)) { let c = this.trigger(e, u, mr, o); c && a.push(c) } }), a.length) return this._engine.markElementAsRemoved(this.id, e, !0, n, s), r && Ct(a).onDone(() => this._engine.processLeaveNode(e)), !0 } return !1 } prepareLeaveAnimationListeners(e) { let n = this._elementListeners.get(e), r = this._engine.statesByElement.get(e); if (n && r) { let o = new Set; n.forEach(i => { let s = i.name; if (o.has(s)) return; o.add(s); let l = this._triggers.get(s).fallbackTransition, u = r.get(s) || $l, c = new yr(mr), d = new vr(this.id, s, e); this._engine.totalQueuedPlayers++, this._queue.push({ element: e, triggerName: s, transition: l, fromState: u, toState: c, player: d, isFallbackTransition: !0 }) }) } } removeNode(e, n) { let r = this._engine; if (e.childElementCount && this._signalRemovalForInnerTriggers(e, n), this.triggerLeaveAnimation(e, n, !0)) return; let o = !1; if (r.totalAnimations) { let i = r.players.length ? r.playersByQueriedElement.get(e) : []; if (i && i.length) o = !0; else { let s = e; for (; s = s.parentNode;)if (r.statesByElement.get(s)) { o = !0; break } } } if (this.prepareLeaveAnimationListeners(e), o) r.markElementAsRemoved(this.id, e, !1, n); else { let i = e[Fe]; (!i || i === Qp) && (r.afterFlush(() => this.clearElementCache(e)), r.destroyInnerAnimations(e), r._onRemovalComplete(e, n)) } } insertNode(e, n) { Se(e, this._hostClassName) } drainQueuedTransitions(e) { let n = []; return this._queue.forEach(r => { let o = r.player; if (o.destroyed) return; let i = r.element, s = this._elementListeners.get(i); s && s.forEach(a => { if (a.name == r.triggerName) { let l = uu(i, r.triggerName, r.fromState.value, r.toState.value); l._data = e, lu(r.player, a.phase, l, a.callback) } }), o.markedForDestroy ? this._engine.afterFlush(() => { o.destroy() }) : n.push(r) }), this._queue = [], n.sort((r, o) => { let i = r.transition.ast.depCount, s = o.transition.ast.depCount; return i == 0 || s == 0 ? i - s : this._engine.driver.containsElement(r.element, o.element) ? 1 : -1 }) } destroy(e) { this.players.forEach(n => n.destroy()), this._signalRemovalForInnerTriggers(this.hostElement, e) } }, ou = class { _onRemovalComplete(e, n) { this.onRemovalComplete(e, n) } constructor(e, n, r) { this.bodyNode = e, this.driver = n, this._normalizer = r, this.players = [], this.newHostElements = new Map, this.playersByElement = new Map, this.playersByQueriedElement = new Map, this.statesByElement = new Map, this.disabledNodes = new Set, this.totalAnimations = 0, this.totalQueuedPlayers = 0, this._namespaceLookup = {}, this._namespaceList = [], this._flushFns = [], this._whenQuietFns = [], this.namespacesByHostElement = new Map, this.collectedEnterElements = [], this.collectedLeaveElements = [], this.onRemovalComplete = (o, i) => { } } get queuedPlayers() { let e = []; return this._namespaceList.forEach(n => { n.players.forEach(r => { r.queued && e.push(r) }) }), e } createNamespace(e, n) { let r = new ru(e, n, this); return this.bodyNode && this.driver.containsElement(this.bodyNode, n) ? this._balanceNamespaceList(r, n) : (this.newHostElements.set(n, r), this.collectEnterElement(n)), this._namespaceLookup[e] = r } _balanceNamespaceList(e, n) { let r = this._namespaceList, o = this.namespacesByHostElement; if (r.length - 1 >= 0) { let s = !1, a = this.driver.getParentElement(n); for (; a;) { let l = o.get(a); if (l) { let u = r.indexOf(l); r.splice(u + 1, 0, e), s = !0; break } a = this.driver.getParentElement(a) } s || r.unshift(e) } else r.push(e); return o.set(n, e), e } register(e, n) { let r = this._namespaceLookup[e]; return r || (r = this.createNamespace(e, n)), r } registerTrigger(e, n, r) { let o = this._namespaceLookup[e]; o && o.register(n, r) && this.totalAnimations++ } destroy(e, n) { e && (this.afterFlush(() => { }), this.afterFlushAnimationsDone(() => { let r = this._fetchNamespace(e); this.namespacesByHostElement.delete(r.hostElement); let o = this._namespaceList.indexOf(r); o >= 0 && this._namespaceList.splice(o, 1), r.destroy(n), delete this._namespaceLookup[e] })) } _fetchNamespace(e) { return this._namespaceLookup[e] } fetchNamespacesByElement(e) { let n = new Set, r = this.statesByElement.get(e); if (r) { for (let o of r.values()) if (o.namespaceId) { let i = this._fetchNamespace(o.namespaceId); i && n.add(i) } } return n } trigger(e, n, r, o) { if (vi(n)) { let i = this._fetchNamespace(e); if (i) return i.trigger(n, r, o), !0 } return !1 } insertNode(e, n, r, o) { if (!vi(n)) return; let i = n[Fe]; if (i && i.setForRemoval) { i.setForRemoval = !1, i.setForMove = !0; let s = this.collectedLeaveElements.indexOf(n); s >= 0 && this.collectedLeaveElements.splice(s, 1) } if (e) { let s = this._fetchNamespace(e); s && s.insertNode(n, r) } o && this.collectEnterElement(n) } collectEnterElement(e) { this.collectedEnterElements.push(e) } markElementAsDisabled(e, n) { n ? this.disabledNodes.has(e) || (this.disabledNodes.add(e), Se(e, Bl)) : this.disabledNodes.has(e) && (this.disabledNodes.delete(e), kn(e, Bl)) } removeNode(e, n, r) { if (vi(n)) { let o = e ? this._fetchNamespace(e) : null; o ? o.removeNode(n, r) : this.markElementAsRemoved(e, n, !1, r); let i = this.namespacesByHostElement.get(n); i && i.id !== e && i.removeNode(n, r) } else this._onRemovalComplete(n, r) } markElementAsRemoved(e, n, r, o, i) { this.collectedLeaveElements.push(n), n[Fe] = { namespaceId: e, setForRemoval: o, hasAnimation: r, removedBeforeQueried: !1, previousTriggersValues: i } } listen(e, n, r, o, i) { return vi(n) ? this._fetchNamespace(e).listen(n, r, o, i) : () => { } } _buildInstruction(e, n, r, o, i) { return e.transition.build(this.driver, e.element, e.fromState.value, e.toState.value, r, o, e.fromState.options, e.toState.options, n, i) } destroyInnerAnimations(e) { let n = this.driver.query(e, wi, !0); n.forEach(r => this.destroyActiveAnimationsForElement(r)), this.playersByQueriedElement.size != 0 && (n = this.driver.query(e, ql, !0), n.forEach(r => this.finishActiveQueriedAnimationOnElement(r))) } destroyActiveAnimationsForElement(e) { let n = this.playersByElement.get(e); n && n.forEach(r => { r.queued ? r.markedForDestroy = !0 : r.destroy() }) } finishActiveQueriedAnimationOnElement(e) { let n = this.playersByQueriedElement.get(e); n && n.forEach(r => r.finish()) } whenRenderingDone() { return new Promise(e => { if (this.players.length) return Ct(this.players).onDone(() => e()); e() }) } processLeaveNode(e) { let n = e[Fe]; if (n && n.setForRemoval) { if (e[Fe] = Qp, n.namespaceId) { this.destroyInnerAnimations(e); let r = this._fetchNamespace(n.namespaceId); r && r.clearElementCache(e) } this._onRemovalComplete(e, n.setForRemoval) } e.classList?.contains(Bl) && this.markElementAsDisabled(e, !1), this.driver.query(e, cb, !0).forEach(r => { this.markElementAsDisabled(r, !1) }) } flush(e = -1) { let n = []; if (this.newHostElements.size && (this.newHostElements.forEach((r, o) => this._balanceNamespaceList(r, o)), this.newHostElements.clear()), this.totalAnimations && this.collectedEnterElements.length) for (let r = 0; r < this.collectedEnterElements.length; r++) { let o = this.collectedEnterElements[r]; Se(o, db) } if (this._namespaceList.length && (this.totalQueuedPlayers || this.collectedLeaveElements.length)) { let r = []; try { n = this._flushAnimations(r, e) } finally { for (let o = 0; o < r.length; o++)r[o]() } } else for (let r = 0; r < this.collectedLeaveElements.length; r++) { let o = this.collectedLeaveElements[r]; this.processLeaveNode(o) } if (this.totalQueuedPlayers = 0, this.collectedEnterElements.length = 0, this.collectedLeaveElements.length = 0, this._flushFns.forEach(r => r()), this._flushFns = [], this._whenQuietFns.length) { let r = this._whenQuietFns; this._whenQuietFns = [], n.length ? Ct(n).onDone(() => { r.forEach(o => o()) }) : r.forEach(o => o()) } } reportError(e) { throw NI(e) } _flushAnimations(e, n) { let r = new Ln, o = [], i = new Map, s = [], a = new Map, l = new Map, u = new Map, c = new Set; this.disabledNodes.forEach(y => { c.add(y); let w = this.driver.query(y, ub, !0); for (let C = 0; C < w.length; C++)c.add(w[C]) }); let d = this.bodyNode, h = Array.from(this.statesByElement.keys()), f = kp(h, this.collectedEnterElements), p = new Map, m = 0; f.forEach((y, w) => { let C = du + m++; p.set(w, C), y.forEach(L => Se(L, C)) }); let D = [], v = new Set, b = new Set; for (let y = 0; y < this.collectedLeaveElements.length; y++) { let w = this.collectedLeaveElements[y], C = w[Fe]; C && C.setForRemoval && (D.push(w), v.add(w), C.hasAnimation ? this.driver.query(w, fb, !0).forEach(L => v.add(L)) : b.add(w)) } let j = new Map, k = kp(h, Array.from(v)); k.forEach((y, w) => { let C = Ei + m++; j.set(w, C), y.forEach(L => Se(L, C)) }), e.push(() => { f.forEach((y, w) => { let C = p.get(w); y.forEach(L => kn(L, C)) }), k.forEach((y, w) => { let C = j.get(w); y.forEach(L => kn(L, C)) }), D.forEach(y => { this.processLeaveNode(y) }) }); let re = [], U = []; for (let y = this._namespaceList.length - 1; y >= 0; y--)this._namespaceList[y].drainQueuedTransitions(n).forEach(C => { let L = C.player, K = C.element; if (re.push(L), this.collectedEnterElements.length) { let oe = K[Fe]; if (oe && oe.setForMove) { if (oe.previousTriggersValues && oe.previousTriggersValues.has(C.triggerName)) { let Mt = oe.previousTriggersValues.get(C.triggerName), we = this.statesByElement.get(C.element); if (we && we.has(C.triggerName)) { let Dr = we.get(C.triggerName); Dr.value = Mt, we.set(C.triggerName, Dr) } } L.destroy(); return } } let Re = !d || !this.driver.containsElement(d, K), pe = j.get(K), st = p.get(K), q = this._buildInstruction(C, r, st, pe, Re); if (q.errors && q.errors.length) { U.push(q); return } if (Re) { L.onStart(() => Jt(K, q.fromStyles)), L.onDestroy(() => qe(K, q.toStyles)), o.push(L); return } if (C.isFallbackTransition) { L.onStart(() => Jt(K, q.fromStyles)), L.onDestroy(() => qe(K, q.toStyles)), o.push(L); return } let Eu = []; q.timelines.forEach(oe => { oe.stretchStartingKeyframe = !0, this.disabledNodes.has(oe.element) || Eu.push(oe) }), q.timelines = Eu, r.append(K, q.timelines); let Yp = { instruction: q, player: L, element: K }; s.push(Yp), q.queriedElements.forEach(oe => Ee(a, oe, []).push(L)), q.preStyleProps.forEach((oe, Mt) => { if (oe.size) { let we = l.get(Mt); we || l.set(Mt, we = new Set), oe.forEach((Dr, Ai) => we.add(Ai)) } }), q.postStyleProps.forEach((oe, Mt) => { let we = u.get(Mt); we || u.set(Mt, we = new Set), oe.forEach((Dr, Ai) => we.add(Ai)) }) }); if (U.length) { let y = []; U.forEach(w => { y.push(xI(w.triggerName, w.errors)) }), re.forEach(w => w.destroy()), this.reportError(y) } let G = new Map, Z = new Map; s.forEach(y => { let w = y.element; r.has(w) && (Z.set(w, w), this._beforeAnimationBuild(y.player.namespaceId, y.instruction, G)) }), o.forEach(y => { let w = y.element; this._getPreviousPlayers(w, !1, y.namespaceId, y.triggerName, null).forEach(L => { Ee(G, w, []).push(L), L.destroy() }) }); let Ge = D.filter(y => Lp(y, l, u)), Xt = new Map; Rp(Xt, this.driver, b, u, ze).forEach(y => { Lp(y, l, u) && Ge.push(y) }); let St = new Map; f.forEach((y, w) => { Rp(St, this.driver, new Set(y), l, pi) }), Ge.forEach(y => { let w = Xt.get(y), C = St.get(y); Xt.set(y, new Map([...w?.entries() ?? [], ...C?.entries() ?? []])) }); let xi = [], vu = [], Du = {}; s.forEach(y => { let { element: w, player: C, instruction: L } = y; if (r.has(w)) { if (c.has(w)) { C.onDestroy(() => qe(w, L.toStyles)), C.disabled = !0, C.overrideTotalTime(L.totalTime), o.push(C); return } let K = Du; if (Z.size > 1) { let pe = w, st = []; for (; pe = pe.parentNode;) { let q = Z.get(pe); if (q) { K = q; break } st.push(pe) } st.forEach(q => Z.set(q, K)) } let Re = this._buildAnimation(C.namespaceId, L, G, i, St, Xt); if (C.setRealPlayer(Re), K === Du) xi.push(C); else { let pe = this.playersByElement.get(K); pe && pe.length && (C.parentPlayer = Ct(pe)), o.push(C) } } else Jt(w, L.fromStyles), C.onDestroy(() => qe(w, L.toStyles)), vu.push(C), c.has(w) && o.push(C) }), vu.forEach(y => { let w = i.get(y.element); if (w && w.length) { let C = Ct(w); y.setRealPlayer(C) } }), o.forEach(y => { y.parentPlayer ? y.syncPlayerEvents(y.parentPlayer) : y.destroy() }); for (let y = 0; y < D.length; y++) { let w = D[y], C = w[Fe]; if (kn(w, Ei), C && C.hasAnimation) continue; let L = []; if (a.size) { let Re = a.get(w); Re && Re.length && L.push(...Re); let pe = this.driver.query(w, ql, !0); for (let st = 0; st < pe.length; st++) { let q = a.get(pe[st]); q && q.length && L.push(...q) } } let K = L.filter(Re => !Re.destroyed); K.length ? vb(this, w, K) : this.processLeaveNode(w) } return D.length = 0, xi.forEach(y => { this.players.push(y), y.onDone(() => { y.destroy(); let w = this.players.indexOf(y); this.players.splice(w, 1) }), y.play() }), xi } afterFlush(e) { this._flushFns.push(e) } afterFlushAnimationsDone(e) { this._whenQuietFns.push(e) } _getPreviousPlayers(e, n, r, o, i) { let s = []; if (n) { let a = this.playersByQueriedElement.get(e); a && (s = a) } else { let a = this.playersByElement.get(e); if (a) { let l = !i || i == mr; a.forEach(u => { u.queued || !l && u.triggerName != o || s.push(u) }) } } return (r || o) && (s = s.filter(a => !(r && r != a.namespaceId || o && o != a.triggerName))), s } _beforeAnimationBuild(e, n, r) { let o = n.triggerName, i = n.element, s = n.isRemovalTransition ? void 0 : e, a = n.isRemovalTransition ? void 0 : o; for (let l of n.timelines) { let u = l.element, c = u !== i, d = Ee(r, u, []); this._getPreviousPlayers(u, c, s, a, n.toState).forEach(f => { let p = f.getRealPlayer(); p.beforeDestroy && p.beforeDestroy(), f.destroy(), d.push(f) }) } Jt(i, n.fromStyles) } _buildAnimation(e, n, r, o, i, s) { let a = n.triggerName, l = n.element, u = [], c = new Set, d = new Set, h = n.timelines.map(p => { let m = p.element; c.add(m); let D = m[Fe]; if (D && D.removedBeforeQueried) return new bt(p.duration, p.delay); let v = m !== l, b = Db((r.get(m) || hb).map(G => G.getRealPlayer())).filter(G => { let Z = G; return Z.element ? Z.element === m : !1 }), j = i.get(m), k = s.get(m), re = Bp(this._normalizer, p.keyframes, j, k), U = this._buildPlayer(p, re, b); if (p.subTimeline && o && d.add(m), v) { let G = new vr(e, a, m); G.setRealPlayer(U), u.push(G) } return U }); u.forEach(p => { Ee(this.playersByQueriedElement, p.element, []).push(p), p.onDone(() => mb(this.playersByQueriedElement, p.element, p)) }), c.forEach(p => Se(p, Sp)); let f = Ct(h); return f.onDestroy(() => { c.forEach(p => kn(p, Sp)), qe(l, n.toStyles) }), d.forEach(p => { Ee(o, p, []).push(f) }), f } _buildPlayer(e, n, r) { return n.length > 0 ? this.driver.animate(e.element, n, e.duration, e.delay, e.easing, r) : new bt(e.duration, e.delay) } }, vr = class { constructor(e, n, r) { this.namespaceId = e, this.triggerName = n, this.element = r, this._player = new bt, this._containsRealPlayer = !1, this._queuedCallbacks = new Map, this.destroyed = !1, this.parentPlayer = null, this.markedForDestroy = !1, this.disabled = !1, this.queued = !0, this.totalTime = 0 } setRealPlayer(e) { this._containsRealPlayer || (this._player = e, this._queuedCallbacks.forEach((n, r) => { n.forEach(o => lu(e, r, void 0, o)) }), this._queuedCallbacks.clear(), this._containsRealPlayer = !0, this.overrideTotalTime(e.totalTime), this.queued = !1) } getRealPlayer() { return this._player } overrideTotalTime(e) { this.totalTime = e } syncPlayerEvents(e) { let n = this._player; n.triggerCallback && e.onStart(() => n.triggerCallback("start")), e.onDone(() => this.finish()), e.onDestroy(() => this.destroy()) } _queueEvent(e, n) { Ee(this._queuedCallbacks, e, []).push(n) } onDone(e) { this.queued && this._queueEvent("done", e), this._player.onDone(e) } onStart(e) { this.queued && this._queueEvent("start", e), this._player.onStart(e) } onDestroy(e) { this.queued && this._queueEvent("destroy", e), this._player.onDestroy(e) } init() { this._player.init() } hasStarted() { return this.queued ? !1 : this._player.hasStarted() } play() { !this.queued && this._player.play() } pause() { !this.queued && this._player.pause() } restart() { !this.queued && this._player.restart() } finish() { this._player.finish() } destroy() { this.destroyed = !0, this._player.destroy() } reset() { !this.queued && this._player.reset() } setPosition(e) { this.queued || this._player.setPosition(e) } getPosition() { return this.queued ? 0 : this._player.getPosition() } triggerCallback(e) { let n = this._player; n.triggerCallback && n.triggerCallback(e) } }; function mb(t, e, n) { let r = t.get(e); if (r) { if (r.length) { let o = r.indexOf(n); r.splice(o, 1) } r.length == 0 && t.delete(e) } return r } function gb(t) { return t ?? null } function vi(t) { return t && t.nodeType === 1 } function yb(t) { return t == "start" || t == "done" } function Fp(t, e) { let n = t.style.display; return t.style.display = e ?? "none", n } function Rp(t, e, n, r, o) { let i = []; n.forEach(l => i.push(Fp(l))); let s = []; r.forEach((l, u) => { let c = new Map; l.forEach(d => { let h = e.computeStyle(u, d, o); c.set(d, h), (!h || h.length == 0) && (u[Fe] = pb, s.push(u)) }), t.set(u, c) }); let a = 0; return n.forEach(l => Fp(l, i[a++])), s } function kp(t, e) { let n = new Map; if (t.forEach(a => n.set(a, [])), e.length == 0) return n; let r = 1, o = new Set(e), i = new Map; function s(a) { if (!a) return r; let l = i.get(a); if (l) return l; let u = a.parentNode; return n.has(u) ? l = u : o.has(u) ? l = r : l = s(u), i.set(a, l), l } return e.forEach(a => { let l = s(a); l !== r && n.get(l).push(a) }), n } function Se(t, e) { t.classList?.add(e) } function kn(t, e) { t.classList?.remove(e) } function vb(t, e, n) { Ct(n).onDone(() => t.processLeaveNode(e)) } function Db(t) { let e = []; return Zp(t, e), e } function Zp(t, e) { for (let n = 0; n < t.length; n++) { let r = t[n]; r instanceof hr ? Zp(r.players, e) : e.push(r) } } function Eb(t, e) { let n = Object.keys(t), r = Object.keys(e); if (n.length != r.length) return !1; for (let o = 0; o < n.length; o++) { let i = n[o]; if (!e.hasOwnProperty(i) || t[i] !== e[i]) return !1 } return !0 } function Lp(t, e, n) { let r = n.get(t); if (!r) return !1; let o = e.get(t); return o ? r.forEach(i => o.add(i)) : e.set(t, r), n.delete(t), !0 } var Mi = class { constructor(e, n, r) { this._driver = n, this._normalizer = r, this._triggerCache = {}, this.onRemovalComplete = (o, i) => { }, this._transitionEngine = new ou(e.body, n, r), this._timelineEngine = new nu(e.body, n, r), this._transitionEngine.onRemovalComplete = (o, i) => this.onRemovalComplete(o, i) } registerTrigger(e, n, r, o, i) { let s = e + "-" + o, a = this._triggerCache[s]; if (!a) { let l = [], u = [], c = pu(this._driver, i, l, u); if (l.length) throw DI(o, l); u.length && void 0, a = sb(o, c, this._normalizer), this._triggerCache[s] = a } this._transitionEngine.registerTrigger(n, o, a) } register(e, n) { this._transitionEngine.register(e, n) } destroy(e, n) { this._transitionEngine.destroy(e, n) } onInsert(e, n, r, o) { this._transitionEngine.insertNode(e, n, r, o) } onRemove(e, n, r) { this._transitionEngine.removeNode(e, n, r) } disableAnimations(e, n) { this._transitionEngine.markElementAsDisabled(e, n) } process(e, n, r, o) { if (r.charAt(0) == "@") { let [i, s] = Ip(r), a = o; this._timelineEngine.command(i, n, s, a) } else this._transitionEngine.trigger(e, n, r, o) } listen(e, n, r, o, i) { if (r.charAt(0) == "@") { let [s, a] = Ip(r); return this._timelineEngine.listen(s, n, a, i) } return this._transitionEngine.listen(e, n, r, o, i) } flush(e = -1) { this._transitionEngine.flush(e) } get players() { return [...this._transitionEngine.players, ...this._timelineEngine.players] } whenRenderingDone() { return this._transitionEngine.whenRenderingDone() } afterFlushAnimationsDone(e) { this._transitionEngine.afterFlushAnimationsDone(e) } }; function wb(t, e) { let n = null, r = null; return Array.isArray(e) && e.length ? (n = Hl(e[0]), e.length > 1 && (r = Hl(e[e.length - 1]))) : e instanceof Map && (n = Hl(e)), n || r ? new iu(t, n, r) : null } var iu = class t { static { this.initialStylesByElement = new WeakMap } constructor(e, n, r) { this._element = e, this._startStyles = n, this._endStyles = r, this._state = 0; let o = t.initialStylesByElement.get(e); o || t.initialStylesByElement.set(e, o = new Map), this._initialStyles = o } start() { this._state < 1 && (this._startStyles && qe(this._element, this._startStyles, this._initialStyles), this._state = 1) } finish() { this.start(), this._state < 2 && (qe(this._element, this._initialStyles), this._endStyles && (qe(this._element, this._endStyles), this._endStyles = null), this._state = 1) } destroy() { this.finish(), this._state < 3 && (t.initialStylesByElement.delete(this._element), this._startStyles && (Jt(this._element, this._startStyles), this._endStyles = null), this._endStyles && (Jt(this._element, this._endStyles), this._endStyles = null), qe(this._element, this._initialStyles), this._state = 3) } }; function Hl(t) { let e = null; return t.forEach((n, r) => { _b(r) && (e = e || new Map, e.set(r, n)) }), e } function _b(t) { return t === "display" || t === "position" } var Ti = class { constructor(e, n, r, o) { this.element = e, this.keyframes = n, this.options = r, this._specialStyles = o, this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this._initialized = !1, this._finished = !1, this._started = !1, this._destroyed = !1, this._originalOnDoneFns = [], this._originalOnStartFns = [], this.time = 0, this.parentPlayer = null, this.currentSnapshot = new Map, this._duration = r.duration, this._delay = r.delay || 0, this.time = this._duration + this._delay } _onFinish() { this._finished || (this._finished = !0, this._onDoneFns.forEach(e => e()), this._onDoneFns = []) } init() { this._buildPlayer(), this._preparePlayerBeforeStart() } _buildPlayer() { if (this._initialized) return; this._initialized = !0; let e = this.keyframes; this.domPlayer = this._triggerWebAnimation(this.element, e, this.options), this._finalKeyframe = e.length ? e[e.length - 1] : new Map; let n = () => this._onFinish(); this.domPlayer.addEventListener("finish", n), this.onDestroy(() => { this.domPlayer.removeEventListener("finish", n) }) } _preparePlayerBeforeStart() { this._delay ? this._resetDomPlayerState() : this.domPlayer.pause() } _convertKeyframesToObject(e) { let n = []; return e.forEach(r => { n.push(Object.fromEntries(r)) }), n } _triggerWebAnimation(e, n, r) { return e.animate(this._convertKeyframesToObject(n), r) } onStart(e) { this._originalOnStartFns.push(e), this._onStartFns.push(e) } onDone(e) { this._originalOnDoneFns.push(e), this._onDoneFns.push(e) } onDestroy(e) { this._onDestroyFns.push(e) } play() { this._buildPlayer(), this.hasStarted() || (this._onStartFns.forEach(e => e()), this._onStartFns = [], this._started = !0, this._specialStyles && this._specialStyles.start()), this.domPlayer.play() } pause() { this.init(), this.domPlayer.pause() } finish() { this.init(), this._specialStyles && this._specialStyles.finish(), this._onFinish(), this.domPlayer.finish() } reset() { this._resetDomPlayerState(), this._destroyed = !1, this._finished = !1, this._started = !1, this._onStartFns = this._originalOnStartFns, this._onDoneFns = this._originalOnDoneFns } _resetDomPlayerState() { this.domPlayer && this.domPlayer.cancel() } restart() { this.reset(), this.play() } hasStarted() { return this._started } destroy() { this._destroyed || (this._destroyed = !0, this._resetDomPlayerState(), this._onFinish(), this._specialStyles && this._specialStyles.destroy(), this._onDestroyFns.forEach(e => e()), this._onDestroyFns = []) } setPosition(e) { this.domPlayer === void 0 && this.init(), this.domPlayer.currentTime = e * this.time } getPosition() { return +(this.domPlayer.currentTime ?? 0) / this.time } get totalTime() { return this._delay + this._duration } beforeDestroy() { let e = new Map; this.hasStarted() && this._finalKeyframe.forEach((r, o) => { o !== "offset" && e.set(o, this._finished ? r : hu(this.element, o)) }), this.currentSnapshot = e } triggerCallback(e) { let n = e === "start" ? this._onStartFns : this._onDoneFns; n.forEach(r => r()), n.length = 0 } }, su = class { validateStyleProperty(e) { return !0 } validateAnimatableStyleProperty(e) { return !0 } containsElement(e, n) { return $p(e, n) } getParentElement(e) { return cu(e) } query(e, n, r) { return Hp(e, n, r) } computeStyle(e, n, r) { return hu(e, n) } animate(e, n, r, o, i, s = []) { let a = o == 0 ? "both" : "forwards", l = { duration: r, delay: o, fill: a }; i && (l.easing = i); let u = new Map, c = s.filter(f => f instanceof Ti); HI(r, o) && c.forEach(f => { f.currentSnapshot.forEach((p, m) => u.set(m, p)) }); let d = VI(n).map(f => new Map(f)); d = UI(e, d, u); let h = wb(e, d); return new Ti(e, d, l, h) } }; function GP(t, e) { return t === "noop" ? new Mi(e, new Up, new zl) : new Mi(e, new su, new Ql) } var jp = class { constructor(e, n) { this._driver = e; let r = [], o = [], i = pu(e, n, r, o); if (r.length) throw yI(r); o.length && void 0, this._animationAst = i } buildTimelines(e, n, r, o, i) { let s = Array.isArray(n) ? Mp(n) : n, a = Array.isArray(r) ? Mp(r) : r, l = []; i = i || new Ln; let u = gu(this._driver, e, this._animationAst, du, Ei, s, a, o, i, l); if (l.length) throw vI(l); return u } }, Di = "@", Kp = "@.disabled", Ni = class { constructor(e, n, r, o) { this.namespaceId = e, this.delegate = n, this.engine = r, this._onDestroy = o, this.\u0275type = 0 } get data() { return this.delegate.data } destroyNode(e) { this.delegate.destroyNode?.(e) } destroy() { this.engine.destroy(this.namespaceId, this.delegate), this.engine.afterFlushAnimationsDone(() => { queueMicrotask(() => { this.delegate.destroy() }) }), this._onDestroy?.() } createElement(e, n) { return this.delegate.createElement(e, n) } createComment(e) { return this.delegate.createComment(e) } createText(e) { return this.delegate.createText(e) } appendChild(e, n) { this.delegate.appendChild(e, n), this.engine.onInsert(this.namespaceId, n, e, !1) } insertBefore(e, n, r, o = !0) { this.delegate.insertBefore(e, n, r), this.engine.onInsert(this.namespaceId, n, e, o) } removeChild(e, n, r) { this.parentNode(n) && this.engine.onRemove(this.namespaceId, n, this.delegate) } selectRootElement(e, n) { return this.delegate.selectRootElement(e, n) } parentNode(e) { return this.delegate.parentNode(e) } nextSibling(e) { return this.delegate.nextSibling(e) } setAttribute(e, n, r, o) { this.delegate.setAttribute(e, n, r, o) } removeAttribute(e, n, r) { this.delegate.removeAttribute(e, n, r) } addClass(e, n) { this.delegate.addClass(e, n) } removeClass(e, n) { this.delegate.removeClass(e, n) } setStyle(e, n, r, o) { this.delegate.setStyle(e, n, r, o) } removeStyle(e, n, r) { this.delegate.removeStyle(e, n, r) } setProperty(e, n, r) { n.charAt(0) == Di && n == Kp ? this.disableAnimations(e, !!r) : this.delegate.setProperty(e, n, r) } setValue(e, n) { this.delegate.setValue(e, n) } listen(e, n, r) { return this.delegate.listen(e, n, r) } disableAnimations(e, n) { this.engine.disableAnimations(e, n) } }, au = class extends Ni { constructor(e, n, r, o, i) { super(n, r, o, i), this.factory = e, this.namespaceId = n } setProperty(e, n, r) { n.charAt(0) == Di ? n.charAt(1) == "." && n == Kp ? (r = r === void 0 ? !0 : !!r, this.disableAnimations(e, r)) : this.engine.process(this.namespaceId, e, n.slice(1), r) : this.delegate.setProperty(e, n, r) } listen(e, n, r) { if (n.charAt(0) == Di) { let o = Ib(e), i = n.slice(1), s = ""; return i.charAt(0) != Di && ([i, s] = bb(i)), this.engine.listen(this.namespaceId, o, i, s, a => { let l = a._data || -1; this.factory.scheduleListenerCallback(l, r, a) }) } return this.delegate.listen(e, n, r) } }; function Ib(t) { switch (t) { case "body": return document.body; case "document": return document; case "window": return window; default: return t } } function bb(t) { let e = t.indexOf("."), n = t.substring(0, e), r = t.slice(e + 1); return [n, r] } var Vp = class { constructor(e, n, r) { this.delegate = e, this.engine = n, this._zone = r, this._currentId = 0, this._microtaskId = 1, this._animationCallbacksBuffer = [], this._rendererCache = new Map, this._cdRecurDepth = 0, n.onRemovalComplete = (o, i) => { i?.removeChild(null, o) } } createRenderer(e, n) { let r = "", o = this.delegate.createRenderer(e, n); if (!e || !n?.data?.animation) { let u = this._rendererCache, c = u.get(o); if (!c) { let d = () => u.delete(o); c = new Ni(r, o, this.engine, d), u.set(o, c) } return c } let i = n.id, s = n.id + "-" + this._currentId; this._currentId++, this.engine.register(s, e); let a = u => { Array.isArray(u) ? u.forEach(a) : this.engine.registerTrigger(i, s, e, u.name, u) }; return n.data.animation.forEach(a), new au(this, s, o, this.engine) } begin() { this._cdRecurDepth++, this.delegate.begin && this.delegate.begin() } _scheduleCountTask() { queueMicrotask(() => { this._microtaskId++ }) } scheduleListenerCallback(e, n, r) { if (e >= 0 && e < this._microtaskId) { this._zone.run(() => n(r)); return } let o = this._animationCallbacksBuffer; o.length == 0 && queueMicrotask(() => { this._zone.run(() => { o.forEach(i => { let [s, a] = i; s(a) }), this._animationCallbacksBuffer = [] }) }), o.push([n, r]) } end() { this._cdRecurDepth--, this._cdRecurDepth == 0 && this._zone.runOutsideAngular(() => { this._scheduleCountTask(), this.engine.flush(this._microtaskId) }), this.delegate.end && this.delegate.end() } whenRenderingDone() { return this.engine.whenRenderingDone() } }; export { me as a, We as b, bu as c, tm as d, W as e, dm as f, P as g, Wi as h, Qi as i, _e as j, Bn as k, Hn as l, ym as m, vm as n, At as o, TS as p, Le as q, Sm as r, Mm as s, Tm as t, Pt as u, je as v, km as w, Ne as x, cn as y, jm as z, Vm as A, Ji as B, Ft as C, Gm as D, Wm as E, Rt as F, Qm as G, pc as H, Zm as I, Km as J, Ym as K, qn as L, dn as M, Xi as N, Jm as O, Xm as P, ng as Q, yc as R, ts as S, rg as T, og as U, ig as V, rs as W, sg as X, ag as Y, lg as Z, ug as _, cg as $, dg as aa, fg as ba, hg as ca, g as da, dd as ea, $ as fa, hd as ga, WA as ha, V as ia, O as ja, de as ka, R as la, QA as ma, Dd as na, Kn as oa, ZA as pa, Td as qa, ir as ra, Uo as sa, KA as ta, ny as ua, kd as va, mt as wa, YA as xa, JA as ya, Ua as za, XA as Aa, eO as Ba, tO as Ca, nO as Da, Jy as Ea, yt as Fa, Xo as Ga, Oe as Ha, ge as Ia, _n as Ja, _t as Ka, rO as La, oO as Ma, gv as Na, Nf as Oa, iO as Pa, sO as Qa, On as Ra, il as Sa, aO as Ta, lO as Ua, uO as Va, cO as Wa, dO as Xa, Of as Ya, jv as Za, ti as _a, fO as $a, Bv as ab, hO as bb, er as cb, pO as db, ne as eb, mO as fb, bn as gb, Sn as hb, Mn as ib, xo as jb, ui as kb, Fn as lb, It as mb, DO as nb, FE as ob, EO as pb, $E as qb, la as rb, HE as sb, WE as tb, KE as ub, YE as vb, XE as wb, fw as xb, kh as yb, hw as zb, wO as Ab, _O as Bb, IO as Cb, bO as Db, CO as Eb, SO as Fb, MO as Gb, Hh as Hb, Uh as Ib, Tw as Jb, zh as Kb, qh as Lb, Aw as Mb, TO as Nb, Pw as Ob, Fw as Pb, Hw as Qb, Uw as Rb, NO as Sb, xO as Tb, AO as Ub, OO as Vb, PO as Wb, FO as Xb, RO as Yb, kO as Zb, LO as _b, Zw as $b, Wh as ac, Kw as bc, Yw as cc, jO as dc, Jw as ec, VO as fc, BO as gc, $O as hc, HO as ic, UO as jc, zO as kc, qO as lc, GO as mc, WO as nc, QO as oc, di as pc, a_ as qc, fi as rc, ZO as sc, KO as tc, Il as uc, tp as vc, YO as wc, M_ as xc, T_ as yc, JO as zc, Cl as Ac, XO as Bc, Sl as Cc, DP as Dc, rp as Ec, fp as Fc, Pl as Gc, O_ as Hc, EP as Ic, wP as Jc, _P as Kc, IP as Lc, bP as Mc, CP as Nc, SP as Oc, MP as Pc, TP as Qc, NP as Rc, K_ as Sc, xP as Tc, AP as Uc, cp as Vc, FP as Wc, RP as Xc, kl as Yc, kP as Zc, LP as _c, jP as $c, VP as ad, cu as bd, FI as cd, zP as dd, $p as ed, Hp as fd, Up as gd, Cp as hd, Ul as id, zl as jd, VI as kd, qP as ld, HI as md, Ql as nd, Mi as od, Ti as pd, su as qd, GP as rd, jp as sd, Ni as td, au as ud, Vp as vd };